// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pixels.proto

#include "pixels.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace pixels {
namespace proto {
PROTOBUF_CONSTEXPR FileTail::FileTail(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.footer_)*/nullptr
  , /*decltype(_impl_.postscript_)*/nullptr
  , /*decltype(_impl_.footerlength_)*/0u
  , /*decltype(_impl_.postscriptlength_)*/0u} {}
struct FileTailDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FileTailDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FileTailDefaultTypeInternal() {}
  union {
    FileTail _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FileTailDefaultTypeInternal _FileTail_default_instance_;
PROTOBUF_CONSTEXPR PostScript::PostScript(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.writertimezone_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.magic_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.contentlength_)*/uint64_t{0u}
  , /*decltype(_impl_.version_)*/0u
  , /*decltype(_impl_.numberofrows_)*/0u
  , /*decltype(_impl_.compression_)*/0
  , /*decltype(_impl_.compressionblocksize_)*/0u
  , /*decltype(_impl_.pixelstride_)*/0u
  , /*decltype(_impl_.partitioned_)*/false
  , /*decltype(_impl_.columnchunkalignment_)*/0u} {}
struct PostScriptDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PostScriptDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PostScriptDefaultTypeInternal() {}
  union {
    PostScript _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PostScriptDefaultTypeInternal _PostScript_default_instance_;
PROTOBUF_CONSTEXPR Footer::Footer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.types_)*/{}
  , /*decltype(_impl_.columnstats_)*/{}
  , /*decltype(_impl_.rowgroupinfos_)*/{}
  , /*decltype(_impl_.rowgroupstats_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FooterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FooterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FooterDefaultTypeInternal() {}
  union {
    Footer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FooterDefaultTypeInternal _Footer_default_instance_;
PROTOBUF_CONSTEXPR Type::Type(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.subtypes_)*/{}
  , /*decltype(_impl_._subtypes_cached_byte_size_)*/{0}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.kind_)*/0
  , /*decltype(_impl_.maximumlength_)*/0u
  , /*decltype(_impl_.precision_)*/0u
  , /*decltype(_impl_.scale_)*/0u
  , /*decltype(_impl_.dimension_)*/0u} {}
struct TypeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TypeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TypeDefaultTypeInternal() {}
  union {
    Type _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TypeDefaultTypeInternal _Type_default_instance_;
PROTOBUF_CONSTEXPR PartitionInformation::PartitionInformation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.columnids_)*/{}
  , /*decltype(_impl_.hashvalue_)*/0} {}
struct PartitionInformationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PartitionInformationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PartitionInformationDefaultTypeInternal() {}
  union {
    PartitionInformation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PartitionInformationDefaultTypeInternal _PartitionInformation_default_instance_;
PROTOBUF_CONSTEXPR RowGroupInformation::RowGroupInformation(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.partitioninfo_)*/nullptr
  , /*decltype(_impl_.footeroffset_)*/uint64_t{0u}
  , /*decltype(_impl_.datalength_)*/0u
  , /*decltype(_impl_.footerlength_)*/0u
  , /*decltype(_impl_.numberofrows_)*/uint64_t{0u}} {}
struct RowGroupInformationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RowGroupInformationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RowGroupInformationDefaultTypeInternal() {}
  union {
    RowGroupInformation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RowGroupInformationDefaultTypeInternal _RowGroupInformation_default_instance_;
PROTOBUF_CONSTEXPR RowGroupStatistic::RowGroupStatistic(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.columnchunkstats_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RowGroupStatisticDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RowGroupStatisticDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RowGroupStatisticDefaultTypeInternal() {}
  union {
    RowGroupStatistic _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RowGroupStatisticDefaultTypeInternal _RowGroupStatistic_default_instance_;
PROTOBUF_CONSTEXPR IntegerStatistic::IntegerStatistic(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.minimum_)*/int64_t{0}
  , /*decltype(_impl_.maximum_)*/int64_t{0}
  , /*decltype(_impl_.sum_)*/int64_t{0}} {}
struct IntegerStatisticDefaultTypeInternal {
  PROTOBUF_CONSTEXPR IntegerStatisticDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~IntegerStatisticDefaultTypeInternal() {}
  union {
    IntegerStatistic _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IntegerStatisticDefaultTypeInternal _IntegerStatistic_default_instance_;
PROTOBUF_CONSTEXPR Integer128Statistic::Integer128Statistic(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.minimum_high_)*/uint64_t{0u}
  , /*decltype(_impl_.minimum_low_)*/uint64_t{0u}
  , /*decltype(_impl_.maximum_high_)*/int64_t{0}
  , /*decltype(_impl_.maximum_low_)*/int64_t{0}} {}
struct Integer128StatisticDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Integer128StatisticDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Integer128StatisticDefaultTypeInternal() {}
  union {
    Integer128Statistic _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Integer128StatisticDefaultTypeInternal _Integer128Statistic_default_instance_;
PROTOBUF_CONSTEXPR DoubleStatistic::DoubleStatistic(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.minimum_)*/0
  , /*decltype(_impl_.maximum_)*/0
  , /*decltype(_impl_.sum_)*/0} {}
struct DoubleStatisticDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DoubleStatisticDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DoubleStatisticDefaultTypeInternal() {}
  union {
    DoubleStatistic _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DoubleStatisticDefaultTypeInternal _DoubleStatistic_default_instance_;
PROTOBUF_CONSTEXPR StringStatistic::StringStatistic(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.minimum_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.maximum_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sum_)*/int64_t{0}} {}
struct StringStatisticDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StringStatisticDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StringStatisticDefaultTypeInternal() {}
  union {
    StringStatistic _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StringStatisticDefaultTypeInternal _StringStatistic_default_instance_;
PROTOBUF_CONSTEXPR BucketStatistic::BucketStatistic(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.count_)*/{}
  , /*decltype(_impl_._count_cached_byte_size_)*/{0}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BucketStatisticDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BucketStatisticDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BucketStatisticDefaultTypeInternal() {}
  union {
    BucketStatistic _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BucketStatisticDefaultTypeInternal _BucketStatistic_default_instance_;
PROTOBUF_CONSTEXPR TimestampStatistic::TimestampStatistic(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.minimum_)*/int64_t{0}
  , /*decltype(_impl_.maximum_)*/int64_t{0}} {}
struct TimestampStatisticDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TimestampStatisticDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TimestampStatisticDefaultTypeInternal() {}
  union {
    TimestampStatistic _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimestampStatisticDefaultTypeInternal _TimestampStatistic_default_instance_;
PROTOBUF_CONSTEXPR DateStatistic::DateStatistic(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.minimum_)*/0
  , /*decltype(_impl_.maximum_)*/0} {}
struct DateStatisticDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DateStatisticDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DateStatisticDefaultTypeInternal() {}
  union {
    DateStatistic _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DateStatisticDefaultTypeInternal _DateStatistic_default_instance_;
PROTOBUF_CONSTEXPR TimeStatistic::TimeStatistic(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.minimum_)*/0
  , /*decltype(_impl_.maximum_)*/0} {}
struct TimeStatisticDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TimeStatisticDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TimeStatisticDefaultTypeInternal() {}
  union {
    TimeStatistic _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimeStatisticDefaultTypeInternal _TimeStatistic_default_instance_;
PROTOBUF_CONSTEXPR BinaryStatistic::BinaryStatistic(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sum_)*/int64_t{0}} {}
struct BinaryStatisticDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BinaryStatisticDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BinaryStatisticDefaultTypeInternal() {}
  union {
    BinaryStatistic _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BinaryStatisticDefaultTypeInternal _BinaryStatistic_default_instance_;
PROTOBUF_CONSTEXPR ColumnStatistic::ColumnStatistic(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.intstatistics_)*/nullptr
  , /*decltype(_impl_.doublestatistics_)*/nullptr
  , /*decltype(_impl_.stringstatistics_)*/nullptr
  , /*decltype(_impl_.bucketstatistics_)*/nullptr
  , /*decltype(_impl_.binarystatistics_)*/nullptr
  , /*decltype(_impl_.timestampstatistics_)*/nullptr
  , /*decltype(_impl_.datestatistics_)*/nullptr
  , /*decltype(_impl_.timestatistics_)*/nullptr
  , /*decltype(_impl_.int128statistics_)*/nullptr
  , /*decltype(_impl_.numberofvalues_)*/uint64_t{0u}
  , /*decltype(_impl_.hasnull_)*/false} {}
struct ColumnStatisticDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ColumnStatisticDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ColumnStatisticDefaultTypeInternal() {}
  union {
    ColumnStatistic _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ColumnStatisticDefaultTypeInternal _ColumnStatistic_default_instance_;
PROTOBUF_CONSTEXPR PixelStatistic::PixelStatistic(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.statistic_)*/nullptr} {}
struct PixelStatisticDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PixelStatisticDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PixelStatisticDefaultTypeInternal() {}
  union {
    PixelStatistic _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PixelStatisticDefaultTypeInternal _PixelStatistic_default_instance_;
PROTOBUF_CONSTEXPR ColumnChunkIndex::ColumnChunkIndex(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pixelpositions_)*/{}
  , /*decltype(_impl_._pixelpositions_cached_byte_size_)*/{0}
  , /*decltype(_impl_.pixelstatistics_)*/{}
  , /*decltype(_impl_.chunkoffset_)*/uint64_t{0u}
  , /*decltype(_impl_.chunklength_)*/0u
  , /*decltype(_impl_.isnulloffset_)*/0u
  , /*decltype(_impl_.littleendian_)*/false
  , /*decltype(_impl_.nullspadding_)*/false
  , /*decltype(_impl_.isnullalignment_)*/0u} {}
struct ColumnChunkIndexDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ColumnChunkIndexDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ColumnChunkIndexDefaultTypeInternal() {}
  union {
    ColumnChunkIndex _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ColumnChunkIndexDefaultTypeInternal _ColumnChunkIndex_default_instance_;
PROTOBUF_CONSTEXPR RowGroupIndex::RowGroupIndex(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.columnchunkindexentries_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RowGroupIndexDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RowGroupIndexDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RowGroupIndexDefaultTypeInternal() {}
  union {
    RowGroupIndex _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RowGroupIndexDefaultTypeInternal _RowGroupIndex_default_instance_;
PROTOBUF_CONSTEXPR RowGroupEncoding::RowGroupEncoding(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.columnchunkencodings_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RowGroupEncodingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RowGroupEncodingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RowGroupEncodingDefaultTypeInternal() {}
  union {
    RowGroupEncoding _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RowGroupEncodingDefaultTypeInternal _RowGroupEncoding_default_instance_;
PROTOBUF_CONSTEXPR RowGroupFooter::RowGroupFooter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.rowgroupindexentry_)*/nullptr
  , /*decltype(_impl_.rowgroupencoding_)*/nullptr} {}
struct RowGroupFooterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RowGroupFooterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RowGroupFooterDefaultTypeInternal() {}
  union {
    RowGroupFooter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RowGroupFooterDefaultTypeInternal _RowGroupFooter_default_instance_;
PROTOBUF_CONSTEXPR ColumnEncoding::ColumnEncoding(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cascadeencoding_)*/nullptr
  , /*decltype(_impl_.kind_)*/0
  , /*decltype(_impl_.dictionarysize_)*/0u} {}
struct ColumnEncodingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ColumnEncodingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ColumnEncodingDefaultTypeInternal() {}
  union {
    ColumnEncoding _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ColumnEncodingDefaultTypeInternal _ColumnEncoding_default_instance_;
}  // namespace proto
}  // namespace pixels
static ::_pb::Metadata file_level_metadata_pixels_2eproto[23];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_pixels_2eproto[3];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_pixels_2eproto = nullptr;

const uint32_t TableStruct_pixels_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::pixels::proto::FileTail, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::FileTail, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::FileTail, _impl_.footer_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::FileTail, _impl_.postscript_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::FileTail, _impl_.footerlength_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::FileTail, _impl_.postscriptlength_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::pixels::proto::PostScript, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::PostScript, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::PostScript, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::PostScript, _impl_.contentlength_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::PostScript, _impl_.numberofrows_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::PostScript, _impl_.compression_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::PostScript, _impl_.compressionblocksize_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::PostScript, _impl_.pixelstride_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::PostScript, _impl_.writertimezone_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::PostScript, _impl_.partitioned_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::PostScript, _impl_.columnchunkalignment_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::PostScript, _impl_.magic_),
  3,
  2,
  4,
  5,
  6,
  7,
  0,
  8,
  9,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::Footer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::Footer, _impl_.types_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::Footer, _impl_.columnstats_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::Footer, _impl_.rowgroupinfos_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::Footer, _impl_.rowgroupstats_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::Type, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::Type, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::Type, _impl_.kind_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::Type, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::Type, _impl_.subtypes_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::Type, _impl_.maximumlength_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::Type, _impl_.precision_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::Type, _impl_.scale_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::Type, _impl_.dimension_),
  1,
  0,
  ~0u,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::pixels::proto::PartitionInformation, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::PartitionInformation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::PartitionInformation, _impl_.columnids_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::PartitionInformation, _impl_.hashvalue_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::pixels::proto::RowGroupInformation, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::RowGroupInformation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::RowGroupInformation, _impl_.footeroffset_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::RowGroupInformation, _impl_.datalength_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::RowGroupInformation, _impl_.footerlength_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::RowGroupInformation, _impl_.numberofrows_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::RowGroupInformation, _impl_.partitioninfo_),
  1,
  2,
  3,
  4,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::RowGroupStatistic, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::RowGroupStatistic, _impl_.columnchunkstats_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::IntegerStatistic, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::IntegerStatistic, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::IntegerStatistic, _impl_.minimum_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::IntegerStatistic, _impl_.maximum_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::IntegerStatistic, _impl_.sum_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::pixels::proto::Integer128Statistic, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::Integer128Statistic, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::Integer128Statistic, _impl_.minimum_high_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::Integer128Statistic, _impl_.minimum_low_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::Integer128Statistic, _impl_.maximum_high_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::Integer128Statistic, _impl_.maximum_low_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::pixels::proto::DoubleStatistic, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::DoubleStatistic, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::DoubleStatistic, _impl_.minimum_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::DoubleStatistic, _impl_.maximum_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::DoubleStatistic, _impl_.sum_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::pixels::proto::StringStatistic, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::StringStatistic, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::StringStatistic, _impl_.minimum_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::StringStatistic, _impl_.maximum_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::StringStatistic, _impl_.sum_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::BucketStatistic, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::BucketStatistic, _impl_.count_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::TimestampStatistic, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::TimestampStatistic, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::TimestampStatistic, _impl_.minimum_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::TimestampStatistic, _impl_.maximum_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::pixels::proto::DateStatistic, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::DateStatistic, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::DateStatistic, _impl_.minimum_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::DateStatistic, _impl_.maximum_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::pixels::proto::TimeStatistic, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::TimeStatistic, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::TimeStatistic, _impl_.minimum_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::TimeStatistic, _impl_.maximum_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::pixels::proto::BinaryStatistic, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::BinaryStatistic, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::BinaryStatistic, _impl_.sum_),
  0,
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnStatistic, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnStatistic, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnStatistic, _impl_.numberofvalues_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnStatistic, _impl_.intstatistics_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnStatistic, _impl_.doublestatistics_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnStatistic, _impl_.stringstatistics_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnStatistic, _impl_.bucketstatistics_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnStatistic, _impl_.binarystatistics_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnStatistic, _impl_.timestampstatistics_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnStatistic, _impl_.datestatistics_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnStatistic, _impl_.timestatistics_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnStatistic, _impl_.int128statistics_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnStatistic, _impl_.hasnull_),
  9,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  10,
  PROTOBUF_FIELD_OFFSET(::pixels::proto::PixelStatistic, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::PixelStatistic, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::PixelStatistic, _impl_.statistic_),
  0,
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnChunkIndex, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnChunkIndex, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnChunkIndex, _impl_.chunkoffset_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnChunkIndex, _impl_.chunklength_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnChunkIndex, _impl_.isnulloffset_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnChunkIndex, _impl_.pixelpositions_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnChunkIndex, _impl_.pixelstatistics_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnChunkIndex, _impl_.littleendian_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnChunkIndex, _impl_.nullspadding_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnChunkIndex, _impl_.isnullalignment_),
  0,
  1,
  2,
  ~0u,
  ~0u,
  3,
  4,
  5,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::RowGroupIndex, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::RowGroupIndex, _impl_.columnchunkindexentries_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::RowGroupEncoding, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::RowGroupEncoding, _impl_.columnchunkencodings_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::RowGroupFooter, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::RowGroupFooter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::RowGroupFooter, _impl_.rowgroupindexentry_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::RowGroupFooter, _impl_.rowgroupencoding_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnEncoding, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnEncoding, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnEncoding, _impl_.kind_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnEncoding, _impl_.dictionarysize_),
  PROTOBUF_FIELD_OFFSET(::pixels::proto::ColumnEncoding, _impl_.cascadeencoding_),
  1,
  2,
  0,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 10, -1, sizeof(::pixels::proto::FileTail)},
  { 14, 30, -1, sizeof(::pixels::proto::PostScript)},
  { 40, -1, -1, sizeof(::pixels::proto::Footer)},
  { 50, 63, -1, sizeof(::pixels::proto::Type)},
  { 70, 78, -1, sizeof(::pixels::proto::PartitionInformation)},
  { 80, 91, -1, sizeof(::pixels::proto::RowGroupInformation)},
  { 96, -1, -1, sizeof(::pixels::proto::RowGroupStatistic)},
  { 103, 112, -1, sizeof(::pixels::proto::IntegerStatistic)},
  { 115, 125, -1, sizeof(::pixels::proto::Integer128Statistic)},
  { 129, 138, -1, sizeof(::pixels::proto::DoubleStatistic)},
  { 141, 150, -1, sizeof(::pixels::proto::StringStatistic)},
  { 153, -1, -1, sizeof(::pixels::proto::BucketStatistic)},
  { 160, 168, -1, sizeof(::pixels::proto::TimestampStatistic)},
  { 170, 178, -1, sizeof(::pixels::proto::DateStatistic)},
  { 180, 188, -1, sizeof(::pixels::proto::TimeStatistic)},
  { 190, 197, -1, sizeof(::pixels::proto::BinaryStatistic)},
  { 198, 215, -1, sizeof(::pixels::proto::ColumnStatistic)},
  { 226, 233, -1, sizeof(::pixels::proto::PixelStatistic)},
  { 234, 248, -1, sizeof(::pixels::proto::ColumnChunkIndex)},
  { 256, -1, -1, sizeof(::pixels::proto::RowGroupIndex)},
  { 263, -1, -1, sizeof(::pixels::proto::RowGroupEncoding)},
  { 270, 278, -1, sizeof(::pixels::proto::RowGroupFooter)},
  { 280, 289, -1, sizeof(::pixels::proto::ColumnEncoding)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::pixels::proto::_FileTail_default_instance_._instance,
  &::pixels::proto::_PostScript_default_instance_._instance,
  &::pixels::proto::_Footer_default_instance_._instance,
  &::pixels::proto::_Type_default_instance_._instance,
  &::pixels::proto::_PartitionInformation_default_instance_._instance,
  &::pixels::proto::_RowGroupInformation_default_instance_._instance,
  &::pixels::proto::_RowGroupStatistic_default_instance_._instance,
  &::pixels::proto::_IntegerStatistic_default_instance_._instance,
  &::pixels::proto::_Integer128Statistic_default_instance_._instance,
  &::pixels::proto::_DoubleStatistic_default_instance_._instance,
  &::pixels::proto::_StringStatistic_default_instance_._instance,
  &::pixels::proto::_BucketStatistic_default_instance_._instance,
  &::pixels::proto::_TimestampStatistic_default_instance_._instance,
  &::pixels::proto::_DateStatistic_default_instance_._instance,
  &::pixels::proto::_TimeStatistic_default_instance_._instance,
  &::pixels::proto::_BinaryStatistic_default_instance_._instance,
  &::pixels::proto::_ColumnStatistic_default_instance_._instance,
  &::pixels::proto::_PixelStatistic_default_instance_._instance,
  &::pixels::proto::_ColumnChunkIndex_default_instance_._instance,
  &::pixels::proto::_RowGroupIndex_default_instance_._instance,
  &::pixels::proto::_RowGroupEncoding_default_instance_._instance,
  &::pixels::proto::_RowGroupFooter_default_instance_._instance,
  &::pixels::proto::_ColumnEncoding_default_instance_._instance,
};

const char descriptor_table_protodef_pixels_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\014pixels.proto\022\014pixels.proto\"\216\001\n\010FileTai"
  "l\022$\n\006footer\030\001 \001(\0132\024.pixels.proto.Footer\022"
  ",\n\npostscript\030\002 \001(\0132\030.pixels.proto.PostS"
  "cript\022\024\n\014footerLength\030\003 \001(\r\022\030\n\020postscrip"
  "tLength\030\004 \001(\r\"\214\002\n\nPostScript\022\017\n\007version\030"
  "\001 \001(\r\022\025\n\rcontentLength\030\002 \001(\004\022\024\n\014numberOf"
  "Rows\030\003 \001(\r\0222\n\013compression\030\004 \001(\0162\035.pixels"
  ".proto.CompressionKind\022\034\n\024compressionBlo"
  "ckSize\030\005 \001(\r\022\023\n\013pixelStride\030\006 \001(\r\022\026\n\016wri"
  "terTimezone\030\007 \001(\t\022\023\n\013partitioned\030\010 \001(\010\022\034"
  "\n\024columnChunkAlignment\030\t \001(\r\022\016\n\005magic\030\300>"
  " \001(\t\"\321\001\n\006Footer\022!\n\005types\030\001 \003(\0132\022.pixels."
  "proto.Type\0222\n\013columnStats\030\002 \003(\0132\035.pixels"
  ".proto.ColumnStatistic\0228\n\rrowGroupInfos\030"
  "\003 \003(\0132!.pixels.proto.RowGroupInformation"
  "\0226\n\rrowGroupStats\030\004 \003(\0132\037.pixels.proto.R"
  "owGroupStatistic\"\214\003\n\004Type\022%\n\004kind\030\001 \001(\0162"
  "\027.pixels.proto.Type.Kind\022\014\n\004name\030\002 \001(\t\022\024"
  "\n\010subtypes\030\003 \003(\rB\002\020\001\022\025\n\rmaximumLength\030\004 "
  "\001(\r\022\021\n\tprecision\030\005 \001(\r\022\r\n\005scale\030\006 \001(\r\022\021\n"
  "\tdimension\030\007 \001(\r\"\354\001\n\004Kind\022\013\n\007BOOLEAN\020\000\022\010"
  "\n\004BYTE\020\001\022\t\n\005SHORT\020\002\022\007\n\003INT\020\003\022\010\n\004LONG\020\004\022\t"
  "\n\005FLOAT\020\005\022\n\n\006DOUBLE\020\006\022\n\n\006STRING\020\007\022\n\n\006BIN"
  "ARY\020\010\022\r\n\tTIMESTAMP\020\t\022\t\n\005ARRAY\020\n\022\007\n\003MAP\020\013"
  "\022\n\n\006STRUCT\020\014\022\r\n\tVARBINARY\020\r\022\013\n\007DECIMAL\020\016"
  "\022\010\n\004DATE\020\017\022\013\n\007VARCHAR\020\020\022\010\n\004CHAR\020\021\022\010\n\004TIM"
  "E\020\022\022\n\n\006VECTOR\020\023\"<\n\024PartitionInformation\022"
  "\021\n\tcolumnIds\030\001 \003(\r\022\021\n\thashValue\030\002 \001(\005\"\246\001"
  "\n\023RowGroupInformation\022\024\n\014footerOffset\030\001 "
  "\001(\004\022\022\n\ndataLength\030\002 \001(\r\022\024\n\014footerLength\030"
  "\003 \001(\r\022\024\n\014numberOfRows\030\004 \001(\004\0229\n\rpartition"
  "Info\030\005 \001(\0132\".pixels.proto.PartitionInfor"
  "mation\"L\n\021RowGroupStatistic\0227\n\020columnChu"
  "nkStats\030\001 \003(\0132\035.pixels.proto.ColumnStati"
  "stic\"A\n\020IntegerStatistic\022\017\n\007minimum\030\001 \001("
  "\022\022\017\n\007maximum\030\002 \001(\022\022\013\n\003sum\030\003 \001(\022\"k\n\023Integ"
  "er128Statistic\022\024\n\014minimum_high\030\001 \001(\004\022\023\n\013"
  "minimum_low\030\002 \001(\004\022\024\n\014maximum_high\030\003 \001(\022\022"
  "\023\n\013maximum_low\030\004 \001(\022\"@\n\017DoubleStatistic\022"
  "\017\n\007minimum\030\001 \001(\001\022\017\n\007maximum\030\002 \001(\001\022\013\n\003sum"
  "\030\003 \001(\001\"@\n\017StringStatistic\022\017\n\007minimum\030\001 \001"
  "(\t\022\017\n\007maximum\030\002 \001(\t\022\013\n\003sum\030\003 \001(\022\"$\n\017Buck"
  "etStatistic\022\021\n\005count\030\001 \003(\004B\002\020\001\"6\n\022Timest"
  "ampStatistic\022\017\n\007minimum\030\001 \001(\022\022\017\n\007maximum"
  "\030\002 \001(\022\"1\n\rDateStatistic\022\017\n\007minimum\030\001 \001(\021"
  "\022\017\n\007maximum\030\002 \001(\021\"1\n\rTimeStatistic\022\017\n\007mi"
  "nimum\030\001 \001(\021\022\017\n\007maximum\030\002 \001(\021\"\036\n\017BinarySt"
  "atistic\022\013\n\003sum\030\001 \001(\022\"\273\004\n\017ColumnStatistic"
  "\022\026\n\016numberOfValues\030\001 \001(\004\0225\n\rintStatistic"
  "s\030\002 \001(\0132\036.pixels.proto.IntegerStatistic\022"
  "7\n\020doubleStatistics\030\003 \001(\0132\035.pixels.proto"
  ".DoubleStatistic\0227\n\020stringStatistics\030\004 \001"
  "(\0132\035.pixels.proto.StringStatistic\0227\n\020buc"
  "ketStatistics\030\005 \001(\0132\035.pixels.proto.Bucke"
  "tStatistic\0227\n\020binaryStatistics\030\006 \001(\0132\035.p"
  "ixels.proto.BinaryStatistic\022=\n\023timestamp"
  "Statistics\030\007 \001(\0132 .pixels.proto.Timestam"
  "pStatistic\0223\n\016dateStatistics\030\t \001(\0132\033.pix"
  "els.proto.DateStatistic\0223\n\016timeStatistic"
  "s\030\n \001(\0132\033.pixels.proto.TimeStatistic\022;\n\020"
  "int128Statistics\030\013 \001(\0132!.pixels.proto.In"
  "teger128Statistic\022\017\n\007hasNull\030\010 \001(\010\"B\n\016Pi"
  "xelStatistic\0220\n\tstatistic\030\001 \001(\0132\035.pixels"
  ".proto.ColumnStatistic\"\352\001\n\020ColumnChunkIn"
  "dex\022\023\n\013chunkOffset\030\001 \001(\004\022\023\n\013chunkLength\030"
  "\002 \001(\r\022\024\n\014isNullOffset\030\003 \001(\r\022\032\n\016pixelPosi"
  "tions\030\004 \003(\rB\002\020\001\0225\n\017pixelStatistics\030\005 \003(\013"
  "2\034.pixels.proto.PixelStatistic\022\024\n\014little"
  "Endian\030\006 \001(\010\022\024\n\014nullsPadding\030\007 \001(\010\022\027\n\017is"
  "NullAlignment\030\010 \001(\r\"P\n\rRowGroupIndex\022\?\n\027"
  "columnChunkIndexEntries\030\001 \003(\0132\036.pixels.p"
  "roto.ColumnChunkIndex\"N\n\020RowGroupEncodin"
  "g\022:\n\024columnChunkEncodings\030\001 \003(\0132\034.pixels"
  ".proto.ColumnEncoding\"\203\001\n\016RowGroupFooter"
  "\0227\n\022rowGroupIndexEntry\030\001 \001(\0132\033.pixels.pr"
  "oto.RowGroupIndex\0228\n\020rowGroupEncoding\030\002 "
  "\001(\0132\036.pixels.proto.RowGroupEncoding\"\301\001\n\016"
  "ColumnEncoding\022/\n\004kind\030\001 \002(\0162!.pixels.pr"
  "oto.ColumnEncoding.Kind\022\026\n\016dictionarySiz"
  "e\030\002 \001(\r\0225\n\017cascadeEncoding\030\003 \001(\0132\034.pixel"
  "s.proto.ColumnEncoding\"/\n\004Kind\022\010\n\004NONE\020\000"
  "\022\r\n\tRUNLENGTH\020\001\022\016\n\nDICTIONARY\020\002*M\n\017Compr"
  "essionKind\022\010\n\004NONE\020\000\022\010\n\004ZLIB\020\001\022\n\n\006SNAPPY"
  "\020\002\022\007\n\003LZO\020\003\022\007\n\003LZ4\020\004\022\010\n\004ZSTD\020\005B&\n\027io.pix"
  "elsdb.pixels.coreB\013PixelsProto"
  ;
static ::_pbi::once_flag descriptor_table_pixels_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_pixels_2eproto = {
    false, false, 3390, descriptor_table_protodef_pixels_2eproto,
    "pixels.proto",
    &descriptor_table_pixels_2eproto_once, nullptr, 0, 23,
    schemas, file_default_instances, TableStruct_pixels_2eproto::offsets,
    file_level_metadata_pixels_2eproto, file_level_enum_descriptors_pixels_2eproto,
    file_level_service_descriptors_pixels_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_pixels_2eproto_getter() {
  return &descriptor_table_pixels_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_pixels_2eproto(&descriptor_table_pixels_2eproto);
namespace pixels {
namespace proto {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Type_Kind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_pixels_2eproto);
  return file_level_enum_descriptors_pixels_2eproto[0];
}
bool Type_Kind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Type_Kind Type::BOOLEAN;
constexpr Type_Kind Type::BYTE;
constexpr Type_Kind Type::SHORT;
constexpr Type_Kind Type::INT;
constexpr Type_Kind Type::LONG;
constexpr Type_Kind Type::FLOAT;
constexpr Type_Kind Type::DOUBLE;
constexpr Type_Kind Type::STRING;
constexpr Type_Kind Type::BINARY;
constexpr Type_Kind Type::TIMESTAMP;
constexpr Type_Kind Type::ARRAY;
constexpr Type_Kind Type::MAP;
constexpr Type_Kind Type::STRUCT;
constexpr Type_Kind Type::VARBINARY;
constexpr Type_Kind Type::DECIMAL;
constexpr Type_Kind Type::DATE;
constexpr Type_Kind Type::VARCHAR;
constexpr Type_Kind Type::CHAR;
constexpr Type_Kind Type::TIME;
constexpr Type_Kind Type::VECTOR;
constexpr Type_Kind Type::Kind_MIN;
constexpr Type_Kind Type::Kind_MAX;
constexpr int Type::Kind_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ColumnEncoding_Kind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_pixels_2eproto);
  return file_level_enum_descriptors_pixels_2eproto[1];
}
bool ColumnEncoding_Kind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ColumnEncoding_Kind ColumnEncoding::NONE;
constexpr ColumnEncoding_Kind ColumnEncoding::RUNLENGTH;
constexpr ColumnEncoding_Kind ColumnEncoding::DICTIONARY;
constexpr ColumnEncoding_Kind ColumnEncoding::Kind_MIN;
constexpr ColumnEncoding_Kind ColumnEncoding::Kind_MAX;
constexpr int ColumnEncoding::Kind_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CompressionKind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_pixels_2eproto);
  return file_level_enum_descriptors_pixels_2eproto[2];
}
bool CompressionKind_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class FileTail::_Internal {
 public:
  using HasBits = decltype(std::declval<FileTail>()._impl_._has_bits_);
  static const ::pixels::proto::Footer& footer(const FileTail* msg);
  static void set_has_footer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::pixels::proto::PostScript& postscript(const FileTail* msg);
  static void set_has_postscript(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_footerlength(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_postscriptlength(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::pixels::proto::Footer&
FileTail::_Internal::footer(const FileTail* msg) {
  return *msg->_impl_.footer_;
}
const ::pixels::proto::PostScript&
FileTail::_Internal::postscript(const FileTail* msg) {
  return *msg->_impl_.postscript_;
}
FileTail::FileTail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pixels.proto.FileTail)
}
FileTail::FileTail(const FileTail& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FileTail* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.footer_){nullptr}
    , decltype(_impl_.postscript_){nullptr}
    , decltype(_impl_.footerlength_){}
    , decltype(_impl_.postscriptlength_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_footer()) {
    _this->_impl_.footer_ = new ::pixels::proto::Footer(*from._impl_.footer_);
  }
  if (from._internal_has_postscript()) {
    _this->_impl_.postscript_ = new ::pixels::proto::PostScript(*from._impl_.postscript_);
  }
  ::memcpy(&_impl_.footerlength_, &from._impl_.footerlength_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.postscriptlength_) -
    reinterpret_cast<char*>(&_impl_.footerlength_)) + sizeof(_impl_.postscriptlength_));
  // @@protoc_insertion_point(copy_constructor:pixels.proto.FileTail)
}

inline void FileTail::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.footer_){nullptr}
    , decltype(_impl_.postscript_){nullptr}
    , decltype(_impl_.footerlength_){0u}
    , decltype(_impl_.postscriptlength_){0u}
  };
}

FileTail::~FileTail() {
  // @@protoc_insertion_point(destructor:pixels.proto.FileTail)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FileTail::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.footer_;
  if (this != internal_default_instance()) delete _impl_.postscript_;
}

void FileTail::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FileTail::Clear() {
// @@protoc_insertion_point(message_clear_start:pixels.proto.FileTail)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.footer_ != nullptr);
      _impl_.footer_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.postscript_ != nullptr);
      _impl_.postscript_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.footerlength_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.postscriptlength_) -
        reinterpret_cast<char*>(&_impl_.footerlength_)) + sizeof(_impl_.postscriptlength_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FileTail::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .pixels.proto.Footer footer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_footer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .pixels.proto.PostScript postscript = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_postscript(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 footerLength = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_footerlength(&has_bits);
          _impl_.footerlength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 postscriptLength = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_postscriptlength(&has_bits);
          _impl_.postscriptlength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FileTail::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pixels.proto.FileTail)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .pixels.proto.Footer footer = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::footer(this),
        _Internal::footer(this).GetCachedSize(), target, stream);
  }

  // optional .pixels.proto.PostScript postscript = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::postscript(this),
        _Internal::postscript(this).GetCachedSize(), target, stream);
  }

  // optional uint32 footerLength = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_footerlength(), target);
  }

  // optional uint32 postscriptLength = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_postscriptlength(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pixels.proto.FileTail)
  return target;
}

size_t FileTail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pixels.proto.FileTail)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .pixels.proto.Footer footer = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.footer_);
    }

    // optional .pixels.proto.PostScript postscript = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.postscript_);
    }

    // optional uint32 footerLength = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_footerlength());
    }

    // optional uint32 postscriptLength = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_postscriptlength());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FileTail::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FileTail::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FileTail::GetClassData() const { return &_class_data_; }


void FileTail::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FileTail*>(&to_msg);
  auto& from = static_cast<const FileTail&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pixels.proto.FileTail)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_footer()->::pixels::proto::Footer::MergeFrom(
          from._internal_footer());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_postscript()->::pixels::proto::PostScript::MergeFrom(
          from._internal_postscript());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.footerlength_ = from._impl_.footerlength_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.postscriptlength_ = from._impl_.postscriptlength_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FileTail::CopyFrom(const FileTail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pixels.proto.FileTail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileTail::IsInitialized() const {
  return true;
}

void FileTail::InternalSwap(FileTail* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FileTail, _impl_.postscriptlength_)
      + sizeof(FileTail::_impl_.postscriptlength_)
      - PROTOBUF_FIELD_OFFSET(FileTail, _impl_.footer_)>(
          reinterpret_cast<char*>(&_impl_.footer_),
          reinterpret_cast<char*>(&other->_impl_.footer_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FileTail::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pixels_2eproto_getter, &descriptor_table_pixels_2eproto_once,
      file_level_metadata_pixels_2eproto[0]);
}

// ===================================================================

class PostScript::_Internal {
 public:
  using HasBits = decltype(std::declval<PostScript>()._impl_._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_contentlength(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_numberofrows(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_compression(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_compressionblocksize(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_pixelstride(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_writertimezone(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_partitioned(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_columnchunkalignment(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_magic(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

PostScript::PostScript(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pixels.proto.PostScript)
}
PostScript::PostScript(const PostScript& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PostScript* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.writertimezone_){}
    , decltype(_impl_.magic_){}
    , decltype(_impl_.contentlength_){}
    , decltype(_impl_.version_){}
    , decltype(_impl_.numberofrows_){}
    , decltype(_impl_.compression_){}
    , decltype(_impl_.compressionblocksize_){}
    , decltype(_impl_.pixelstride_){}
    , decltype(_impl_.partitioned_){}
    , decltype(_impl_.columnchunkalignment_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.writertimezone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.writertimezone_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_writertimezone()) {
    _this->_impl_.writertimezone_.Set(from._internal_writertimezone(), 
      _this->GetArenaForAllocation());
  }
  _impl_.magic_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.magic_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_magic()) {
    _this->_impl_.magic_.Set(from._internal_magic(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.contentlength_, &from._impl_.contentlength_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.columnchunkalignment_) -
    reinterpret_cast<char*>(&_impl_.contentlength_)) + sizeof(_impl_.columnchunkalignment_));
  // @@protoc_insertion_point(copy_constructor:pixels.proto.PostScript)
}

inline void PostScript::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.writertimezone_){}
    , decltype(_impl_.magic_){}
    , decltype(_impl_.contentlength_){uint64_t{0u}}
    , decltype(_impl_.version_){0u}
    , decltype(_impl_.numberofrows_){0u}
    , decltype(_impl_.compression_){0}
    , decltype(_impl_.compressionblocksize_){0u}
    , decltype(_impl_.pixelstride_){0u}
    , decltype(_impl_.partitioned_){false}
    , decltype(_impl_.columnchunkalignment_){0u}
  };
  _impl_.writertimezone_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.writertimezone_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.magic_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.magic_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PostScript::~PostScript() {
  // @@protoc_insertion_point(destructor:pixels.proto.PostScript)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PostScript::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.writertimezone_.Destroy();
  _impl_.magic_.Destroy();
}

void PostScript::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PostScript::Clear() {
// @@protoc_insertion_point(message_clear_start:pixels.proto.PostScript)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.writertimezone_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.magic_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.contentlength_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.pixelstride_) -
        reinterpret_cast<char*>(&_impl_.contentlength_)) + sizeof(_impl_.pixelstride_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.partitioned_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.columnchunkalignment_) -
        reinterpret_cast<char*>(&_impl_.partitioned_)) + sizeof(_impl_.columnchunkalignment_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PostScript::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 contentLength = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_contentlength(&has_bits);
          _impl_.contentlength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 numberOfRows = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_numberofrows(&has_bits);
          _impl_.numberofrows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .pixels.proto.CompressionKind compression = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pixels::proto::CompressionKind_IsValid(val))) {
            _internal_set_compression(static_cast<::pixels::proto::CompressionKind>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 compressionBlockSize = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_compressionblocksize(&has_bits);
          _impl_.compressionblocksize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 pixelStride = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_pixelstride(&has_bits);
          _impl_.pixelstride_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string writerTimezone = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_writertimezone();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "pixels.proto.PostScript.writerTimezone");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool partitioned = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_partitioned(&has_bits);
          _impl_.partitioned_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 columnChunkAlignment = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_columnchunkalignment(&has_bits);
          _impl_.columnchunkalignment_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string magic = 8000;
      case 8000:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 2)) {
          auto str = _internal_mutable_magic();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "pixels.proto.PostScript.magic");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PostScript::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pixels.proto.PostScript)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 version = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_version(), target);
  }

  // optional uint64 contentLength = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_contentlength(), target);
  }

  // optional uint32 numberOfRows = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_numberofrows(), target);
  }

  // optional .pixels.proto.CompressionKind compression = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_compression(), target);
  }

  // optional uint32 compressionBlockSize = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_compressionblocksize(), target);
  }

  // optional uint32 pixelStride = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_pixelstride(), target);
  }

  // optional string writerTimezone = 7;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_writertimezone().data(), static_cast<int>(this->_internal_writertimezone().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "pixels.proto.PostScript.writerTimezone");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_writertimezone(), target);
  }

  // optional bool partitioned = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_partitioned(), target);
  }

  // optional uint32 columnChunkAlignment = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_columnchunkalignment(), target);
  }

  // optional string magic = 8000;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_magic().data(), static_cast<int>(this->_internal_magic().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "pixels.proto.PostScript.magic");
    target = stream->WriteStringMaybeAliased(
        8000, this->_internal_magic(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pixels.proto.PostScript)
  return target;
}

size_t PostScript::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pixels.proto.PostScript)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string writerTimezone = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_writertimezone());
    }

    // optional string magic = 8000;
    if (cached_has_bits & 0x00000002u) {
      total_size += 3 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_magic());
    }

    // optional uint64 contentLength = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_contentlength());
    }

    // optional uint32 version = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version());
    }

    // optional uint32 numberOfRows = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_numberofrows());
    }

    // optional .pixels.proto.CompressionKind compression = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_compression());
    }

    // optional uint32 compressionBlockSize = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_compressionblocksize());
    }

    // optional uint32 pixelStride = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_pixelstride());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional bool partitioned = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional uint32 columnChunkAlignment = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_columnchunkalignment());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PostScript::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PostScript::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PostScript::GetClassData() const { return &_class_data_; }


void PostScript::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PostScript*>(&to_msg);
  auto& from = static_cast<const PostScript&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pixels.proto.PostScript)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_writertimezone(from._internal_writertimezone());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_magic(from._internal_magic());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.contentlength_ = from._impl_.contentlength_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.numberofrows_ = from._impl_.numberofrows_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.compression_ = from._impl_.compression_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.compressionblocksize_ = from._impl_.compressionblocksize_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.pixelstride_ = from._impl_.pixelstride_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.partitioned_ = from._impl_.partitioned_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.columnchunkalignment_ = from._impl_.columnchunkalignment_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PostScript::CopyFrom(const PostScript& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pixels.proto.PostScript)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PostScript::IsInitialized() const {
  return true;
}

void PostScript::InternalSwap(PostScript* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.writertimezone_, lhs_arena,
      &other->_impl_.writertimezone_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.magic_, lhs_arena,
      &other->_impl_.magic_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PostScript, _impl_.columnchunkalignment_)
      + sizeof(PostScript::_impl_.columnchunkalignment_)
      - PROTOBUF_FIELD_OFFSET(PostScript, _impl_.contentlength_)>(
          reinterpret_cast<char*>(&_impl_.contentlength_),
          reinterpret_cast<char*>(&other->_impl_.contentlength_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PostScript::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pixels_2eproto_getter, &descriptor_table_pixels_2eproto_once,
      file_level_metadata_pixels_2eproto[1]);
}

// ===================================================================

class Footer::_Internal {
 public:
};

Footer::Footer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pixels.proto.Footer)
}
Footer::Footer(const Footer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Footer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.types_){from._impl_.types_}
    , decltype(_impl_.columnstats_){from._impl_.columnstats_}
    , decltype(_impl_.rowgroupinfos_){from._impl_.rowgroupinfos_}
    , decltype(_impl_.rowgroupstats_){from._impl_.rowgroupstats_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pixels.proto.Footer)
}

inline void Footer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.types_){arena}
    , decltype(_impl_.columnstats_){arena}
    , decltype(_impl_.rowgroupinfos_){arena}
    , decltype(_impl_.rowgroupstats_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Footer::~Footer() {
  // @@protoc_insertion_point(destructor:pixels.proto.Footer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Footer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.types_.~RepeatedPtrField();
  _impl_.columnstats_.~RepeatedPtrField();
  _impl_.rowgroupinfos_.~RepeatedPtrField();
  _impl_.rowgroupstats_.~RepeatedPtrField();
}

void Footer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Footer::Clear() {
// @@protoc_insertion_point(message_clear_start:pixels.proto.Footer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.types_.Clear();
  _impl_.columnstats_.Clear();
  _impl_.rowgroupinfos_.Clear();
  _impl_.rowgroupstats_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Footer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .pixels.proto.Type types = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_types(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .pixels.proto.ColumnStatistic columnStats = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_columnstats(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .pixels.proto.RowGroupInformation rowGroupInfos = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_rowgroupinfos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .pixels.proto.RowGroupStatistic rowGroupStats = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_rowgroupstats(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Footer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pixels.proto.Footer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .pixels.proto.Type types = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_types_size()); i < n; i++) {
    const auto& repfield = this->_internal_types(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .pixels.proto.ColumnStatistic columnStats = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_columnstats_size()); i < n; i++) {
    const auto& repfield = this->_internal_columnstats(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .pixels.proto.RowGroupInformation rowGroupInfos = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_rowgroupinfos_size()); i < n; i++) {
    const auto& repfield = this->_internal_rowgroupinfos(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .pixels.proto.RowGroupStatistic rowGroupStats = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_rowgroupstats_size()); i < n; i++) {
    const auto& repfield = this->_internal_rowgroupstats(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pixels.proto.Footer)
  return target;
}

size_t Footer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pixels.proto.Footer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pixels.proto.Type types = 1;
  total_size += 1UL * this->_internal_types_size();
  for (const auto& msg : this->_impl_.types_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .pixels.proto.ColumnStatistic columnStats = 2;
  total_size += 1UL * this->_internal_columnstats_size();
  for (const auto& msg : this->_impl_.columnstats_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .pixels.proto.RowGroupInformation rowGroupInfos = 3;
  total_size += 1UL * this->_internal_rowgroupinfos_size();
  for (const auto& msg : this->_impl_.rowgroupinfos_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .pixels.proto.RowGroupStatistic rowGroupStats = 4;
  total_size += 1UL * this->_internal_rowgroupstats_size();
  for (const auto& msg : this->_impl_.rowgroupstats_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Footer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Footer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Footer::GetClassData() const { return &_class_data_; }


void Footer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Footer*>(&to_msg);
  auto& from = static_cast<const Footer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pixels.proto.Footer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.types_.MergeFrom(from._impl_.types_);
  _this->_impl_.columnstats_.MergeFrom(from._impl_.columnstats_);
  _this->_impl_.rowgroupinfos_.MergeFrom(from._impl_.rowgroupinfos_);
  _this->_impl_.rowgroupstats_.MergeFrom(from._impl_.rowgroupstats_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Footer::CopyFrom(const Footer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pixels.proto.Footer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Footer::IsInitialized() const {
  return true;
}

void Footer::InternalSwap(Footer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.types_.InternalSwap(&other->_impl_.types_);
  _impl_.columnstats_.InternalSwap(&other->_impl_.columnstats_);
  _impl_.rowgroupinfos_.InternalSwap(&other->_impl_.rowgroupinfos_);
  _impl_.rowgroupstats_.InternalSwap(&other->_impl_.rowgroupstats_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Footer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pixels_2eproto_getter, &descriptor_table_pixels_2eproto_once,
      file_level_metadata_pixels_2eproto[2]);
}

// ===================================================================

class Type::_Internal {
 public:
  using HasBits = decltype(std::declval<Type>()._impl_._has_bits_);
  static void set_has_kind(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_maximumlength(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_precision(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_dimension(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

Type::Type(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pixels.proto.Type)
}
Type::Type(const Type& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Type* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subtypes_){from._impl_.subtypes_}
    , /*decltype(_impl_._subtypes_cached_byte_size_)*/{0}
    , decltype(_impl_.name_){}
    , decltype(_impl_.kind_){}
    , decltype(_impl_.maximumlength_){}
    , decltype(_impl_.precision_){}
    , decltype(_impl_.scale_){}
    , decltype(_impl_.dimension_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.kind_, &from._impl_.kind_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.dimension_) -
    reinterpret_cast<char*>(&_impl_.kind_)) + sizeof(_impl_.dimension_));
  // @@protoc_insertion_point(copy_constructor:pixels.proto.Type)
}

inline void Type::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.subtypes_){arena}
    , /*decltype(_impl_._subtypes_cached_byte_size_)*/{0}
    , decltype(_impl_.name_){}
    , decltype(_impl_.kind_){0}
    , decltype(_impl_.maximumlength_){0u}
    , decltype(_impl_.precision_){0u}
    , decltype(_impl_.scale_){0u}
    , decltype(_impl_.dimension_){0u}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Type::~Type() {
  // @@protoc_insertion_point(destructor:pixels.proto.Type)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Type::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.subtypes_.~RepeatedField();
  _impl_.name_.Destroy();
}

void Type::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Type::Clear() {
// @@protoc_insertion_point(message_clear_start:pixels.proto.Type)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.subtypes_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&_impl_.kind_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.dimension_) -
        reinterpret_cast<char*>(&_impl_.kind_)) + sizeof(_impl_.dimension_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Type::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .pixels.proto.Type.Kind kind = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pixels::proto::Type_Kind_IsValid(val))) {
            _internal_set_kind(static_cast<::pixels::proto::Type_Kind>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "pixels.proto.Type.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 subtypes = 3 [packed = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_subtypes(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_subtypes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 maximumLength = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_maximumlength(&has_bits);
          _impl_.maximumlength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 precision = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_precision(&has_bits);
          _impl_.precision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 scale = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_scale(&has_bits);
          _impl_.scale_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 dimension = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_dimension(&has_bits);
          _impl_.dimension_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Type::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pixels.proto.Type)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .pixels.proto.Type.Kind kind = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_kind(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "pixels.proto.Type.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // repeated uint32 subtypes = 3 [packed = true];
  {
    int byte_size = _impl_._subtypes_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          3, _internal_subtypes(), byte_size, target);
    }
  }

  // optional uint32 maximumLength = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_maximumlength(), target);
  }

  // optional uint32 precision = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_precision(), target);
  }

  // optional uint32 scale = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_scale(), target);
  }

  // optional uint32 dimension = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_dimension(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pixels.proto.Type)
  return target;
}

size_t Type::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pixels.proto.Type)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 subtypes = 3 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.subtypes_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._subtypes_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional .pixels.proto.Type.Kind kind = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_kind());
    }

    // optional uint32 maximumLength = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_maximumlength());
    }

    // optional uint32 precision = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_precision());
    }

    // optional uint32 scale = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_scale());
    }

    // optional uint32 dimension = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dimension());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Type::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Type::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Type::GetClassData() const { return &_class_data_; }


void Type::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Type*>(&to_msg);
  auto& from = static_cast<const Type&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pixels.proto.Type)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.subtypes_.MergeFrom(from._impl_.subtypes_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.kind_ = from._impl_.kind_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.maximumlength_ = from._impl_.maximumlength_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.precision_ = from._impl_.precision_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.scale_ = from._impl_.scale_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.dimension_ = from._impl_.dimension_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Type::CopyFrom(const Type& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pixels.proto.Type)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Type::IsInitialized() const {
  return true;
}

void Type::InternalSwap(Type* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.subtypes_.InternalSwap(&other->_impl_.subtypes_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Type, _impl_.dimension_)
      + sizeof(Type::_impl_.dimension_)
      - PROTOBUF_FIELD_OFFSET(Type, _impl_.kind_)>(
          reinterpret_cast<char*>(&_impl_.kind_),
          reinterpret_cast<char*>(&other->_impl_.kind_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Type::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pixels_2eproto_getter, &descriptor_table_pixels_2eproto_once,
      file_level_metadata_pixels_2eproto[3]);
}

// ===================================================================

class PartitionInformation::_Internal {
 public:
  using HasBits = decltype(std::declval<PartitionInformation>()._impl_._has_bits_);
  static void set_has_hashvalue(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

PartitionInformation::PartitionInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pixels.proto.PartitionInformation)
}
PartitionInformation::PartitionInformation(const PartitionInformation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PartitionInformation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.columnids_){from._impl_.columnids_}
    , decltype(_impl_.hashvalue_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.hashvalue_ = from._impl_.hashvalue_;
  // @@protoc_insertion_point(copy_constructor:pixels.proto.PartitionInformation)
}

inline void PartitionInformation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.columnids_){arena}
    , decltype(_impl_.hashvalue_){0}
  };
}

PartitionInformation::~PartitionInformation() {
  // @@protoc_insertion_point(destructor:pixels.proto.PartitionInformation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PartitionInformation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.columnids_.~RepeatedField();
}

void PartitionInformation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PartitionInformation::Clear() {
// @@protoc_insertion_point(message_clear_start:pixels.proto.PartitionInformation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.columnids_.Clear();
  _impl_.hashvalue_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PartitionInformation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 columnIds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_columnids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_columnids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 hashValue = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_hashvalue(&has_bits);
          _impl_.hashvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PartitionInformation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pixels.proto.PartitionInformation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 columnIds = 1;
  for (int i = 0, n = this->_internal_columnids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_columnids(i), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 hashValue = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_hashvalue(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pixels.proto.PartitionInformation)
  return target;
}

size_t PartitionInformation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pixels.proto.PartitionInformation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 columnIds = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.columnids_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_columnids_size());
    total_size += data_size;
  }

  // optional int32 hashValue = 2;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_hashvalue());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PartitionInformation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PartitionInformation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PartitionInformation::GetClassData() const { return &_class_data_; }


void PartitionInformation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PartitionInformation*>(&to_msg);
  auto& from = static_cast<const PartitionInformation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pixels.proto.PartitionInformation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.columnids_.MergeFrom(from._impl_.columnids_);
  if (from._internal_has_hashvalue()) {
    _this->_internal_set_hashvalue(from._internal_hashvalue());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PartitionInformation::CopyFrom(const PartitionInformation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pixels.proto.PartitionInformation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PartitionInformation::IsInitialized() const {
  return true;
}

void PartitionInformation::InternalSwap(PartitionInformation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.columnids_.InternalSwap(&other->_impl_.columnids_);
  swap(_impl_.hashvalue_, other->_impl_.hashvalue_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PartitionInformation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pixels_2eproto_getter, &descriptor_table_pixels_2eproto_once,
      file_level_metadata_pixels_2eproto[4]);
}

// ===================================================================

class RowGroupInformation::_Internal {
 public:
  using HasBits = decltype(std::declval<RowGroupInformation>()._impl_._has_bits_);
  static void set_has_footeroffset(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_datalength(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_footerlength(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_numberofrows(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::pixels::proto::PartitionInformation& partitioninfo(const RowGroupInformation* msg);
  static void set_has_partitioninfo(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::pixels::proto::PartitionInformation&
RowGroupInformation::_Internal::partitioninfo(const RowGroupInformation* msg) {
  return *msg->_impl_.partitioninfo_;
}
RowGroupInformation::RowGroupInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pixels.proto.RowGroupInformation)
}
RowGroupInformation::RowGroupInformation(const RowGroupInformation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RowGroupInformation* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.partitioninfo_){nullptr}
    , decltype(_impl_.footeroffset_){}
    , decltype(_impl_.datalength_){}
    , decltype(_impl_.footerlength_){}
    , decltype(_impl_.numberofrows_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_partitioninfo()) {
    _this->_impl_.partitioninfo_ = new ::pixels::proto::PartitionInformation(*from._impl_.partitioninfo_);
  }
  ::memcpy(&_impl_.footeroffset_, &from._impl_.footeroffset_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.numberofrows_) -
    reinterpret_cast<char*>(&_impl_.footeroffset_)) + sizeof(_impl_.numberofrows_));
  // @@protoc_insertion_point(copy_constructor:pixels.proto.RowGroupInformation)
}

inline void RowGroupInformation::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.partitioninfo_){nullptr}
    , decltype(_impl_.footeroffset_){uint64_t{0u}}
    , decltype(_impl_.datalength_){0u}
    , decltype(_impl_.footerlength_){0u}
    , decltype(_impl_.numberofrows_){uint64_t{0u}}
  };
}

RowGroupInformation::~RowGroupInformation() {
  // @@protoc_insertion_point(destructor:pixels.proto.RowGroupInformation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RowGroupInformation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.partitioninfo_;
}

void RowGroupInformation::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RowGroupInformation::Clear() {
// @@protoc_insertion_point(message_clear_start:pixels.proto.RowGroupInformation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.partitioninfo_ != nullptr);
    _impl_.partitioninfo_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.footeroffset_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.numberofrows_) -
        reinterpret_cast<char*>(&_impl_.footeroffset_)) + sizeof(_impl_.numberofrows_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RowGroupInformation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 footerOffset = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_footeroffset(&has_bits);
          _impl_.footeroffset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 dataLength = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_datalength(&has_bits);
          _impl_.datalength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 footerLength = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_footerlength(&has_bits);
          _impl_.footerlength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 numberOfRows = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_numberofrows(&has_bits);
          _impl_.numberofrows_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .pixels.proto.PartitionInformation partitionInfo = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_partitioninfo(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RowGroupInformation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pixels.proto.RowGroupInformation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 footerOffset = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_footeroffset(), target);
  }

  // optional uint32 dataLength = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_datalength(), target);
  }

  // optional uint32 footerLength = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_footerlength(), target);
  }

  // optional uint64 numberOfRows = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_numberofrows(), target);
  }

  // optional .pixels.proto.PartitionInformation partitionInfo = 5;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::partitioninfo(this),
        _Internal::partitioninfo(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pixels.proto.RowGroupInformation)
  return target;
}

size_t RowGroupInformation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pixels.proto.RowGroupInformation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .pixels.proto.PartitionInformation partitionInfo = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.partitioninfo_);
    }

    // optional uint64 footerOffset = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_footeroffset());
    }

    // optional uint32 dataLength = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_datalength());
    }

    // optional uint32 footerLength = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_footerlength());
    }

    // optional uint64 numberOfRows = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_numberofrows());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RowGroupInformation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RowGroupInformation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RowGroupInformation::GetClassData() const { return &_class_data_; }


void RowGroupInformation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RowGroupInformation*>(&to_msg);
  auto& from = static_cast<const RowGroupInformation&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pixels.proto.RowGroupInformation)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_partitioninfo()->::pixels::proto::PartitionInformation::MergeFrom(
          from._internal_partitioninfo());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.footeroffset_ = from._impl_.footeroffset_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.datalength_ = from._impl_.datalength_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.footerlength_ = from._impl_.footerlength_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.numberofrows_ = from._impl_.numberofrows_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RowGroupInformation::CopyFrom(const RowGroupInformation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pixels.proto.RowGroupInformation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RowGroupInformation::IsInitialized() const {
  return true;
}

void RowGroupInformation::InternalSwap(RowGroupInformation* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RowGroupInformation, _impl_.numberofrows_)
      + sizeof(RowGroupInformation::_impl_.numberofrows_)
      - PROTOBUF_FIELD_OFFSET(RowGroupInformation, _impl_.partitioninfo_)>(
          reinterpret_cast<char*>(&_impl_.partitioninfo_),
          reinterpret_cast<char*>(&other->_impl_.partitioninfo_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RowGroupInformation::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pixels_2eproto_getter, &descriptor_table_pixels_2eproto_once,
      file_level_metadata_pixels_2eproto[5]);
}

// ===================================================================

class RowGroupStatistic::_Internal {
 public:
};

RowGroupStatistic::RowGroupStatistic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pixels.proto.RowGroupStatistic)
}
RowGroupStatistic::RowGroupStatistic(const RowGroupStatistic& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RowGroupStatistic* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.columnchunkstats_){from._impl_.columnchunkstats_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pixels.proto.RowGroupStatistic)
}

inline void RowGroupStatistic::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.columnchunkstats_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RowGroupStatistic::~RowGroupStatistic() {
  // @@protoc_insertion_point(destructor:pixels.proto.RowGroupStatistic)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RowGroupStatistic::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.columnchunkstats_.~RepeatedPtrField();
}

void RowGroupStatistic::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RowGroupStatistic::Clear() {
// @@protoc_insertion_point(message_clear_start:pixels.proto.RowGroupStatistic)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.columnchunkstats_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RowGroupStatistic::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .pixels.proto.ColumnStatistic columnChunkStats = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_columnchunkstats(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RowGroupStatistic::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pixels.proto.RowGroupStatistic)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .pixels.proto.ColumnStatistic columnChunkStats = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_columnchunkstats_size()); i < n; i++) {
    const auto& repfield = this->_internal_columnchunkstats(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pixels.proto.RowGroupStatistic)
  return target;
}

size_t RowGroupStatistic::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pixels.proto.RowGroupStatistic)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pixels.proto.ColumnStatistic columnChunkStats = 1;
  total_size += 1UL * this->_internal_columnchunkstats_size();
  for (const auto& msg : this->_impl_.columnchunkstats_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RowGroupStatistic::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RowGroupStatistic::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RowGroupStatistic::GetClassData() const { return &_class_data_; }


void RowGroupStatistic::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RowGroupStatistic*>(&to_msg);
  auto& from = static_cast<const RowGroupStatistic&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pixels.proto.RowGroupStatistic)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.columnchunkstats_.MergeFrom(from._impl_.columnchunkstats_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RowGroupStatistic::CopyFrom(const RowGroupStatistic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pixels.proto.RowGroupStatistic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RowGroupStatistic::IsInitialized() const {
  return true;
}

void RowGroupStatistic::InternalSwap(RowGroupStatistic* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.columnchunkstats_.InternalSwap(&other->_impl_.columnchunkstats_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RowGroupStatistic::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pixels_2eproto_getter, &descriptor_table_pixels_2eproto_once,
      file_level_metadata_pixels_2eproto[6]);
}

// ===================================================================

class IntegerStatistic::_Internal {
 public:
  using HasBits = decltype(std::declval<IntegerStatistic>()._impl_._has_bits_);
  static void set_has_minimum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_maximum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sum(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

IntegerStatistic::IntegerStatistic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pixels.proto.IntegerStatistic)
}
IntegerStatistic::IntegerStatistic(const IntegerStatistic& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  IntegerStatistic* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.minimum_){}
    , decltype(_impl_.maximum_){}
    , decltype(_impl_.sum_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.minimum_, &from._impl_.minimum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sum_) -
    reinterpret_cast<char*>(&_impl_.minimum_)) + sizeof(_impl_.sum_));
  // @@protoc_insertion_point(copy_constructor:pixels.proto.IntegerStatistic)
}

inline void IntegerStatistic::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.minimum_){int64_t{0}}
    , decltype(_impl_.maximum_){int64_t{0}}
    , decltype(_impl_.sum_){int64_t{0}}
  };
}

IntegerStatistic::~IntegerStatistic() {
  // @@protoc_insertion_point(destructor:pixels.proto.IntegerStatistic)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void IntegerStatistic::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IntegerStatistic::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void IntegerStatistic::Clear() {
// @@protoc_insertion_point(message_clear_start:pixels.proto.IntegerStatistic)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.minimum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.sum_) -
        reinterpret_cast<char*>(&_impl_.minimum_)) + sizeof(_impl_.sum_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IntegerStatistic::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional sint64 minimum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_minimum(&has_bits);
          _impl_.minimum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint64 maximum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_maximum(&has_bits);
          _impl_.maximum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint64 sum = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_sum(&has_bits);
          _impl_.sum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IntegerStatistic::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pixels.proto.IntegerStatistic)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional sint64 minimum = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(1, this->_internal_minimum(), target);
  }

  // optional sint64 maximum = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(2, this->_internal_maximum(), target);
  }

  // optional sint64 sum = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(3, this->_internal_sum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pixels.proto.IntegerStatistic)
  return target;
}

size_t IntegerStatistic::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pixels.proto.IntegerStatistic)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional sint64 minimum = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(this->_internal_minimum());
    }

    // optional sint64 maximum = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(this->_internal_maximum());
    }

    // optional sint64 sum = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(this->_internal_sum());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IntegerStatistic::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    IntegerStatistic::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IntegerStatistic::GetClassData() const { return &_class_data_; }


void IntegerStatistic::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<IntegerStatistic*>(&to_msg);
  auto& from = static_cast<const IntegerStatistic&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pixels.proto.IntegerStatistic)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.minimum_ = from._impl_.minimum_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.maximum_ = from._impl_.maximum_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sum_ = from._impl_.sum_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IntegerStatistic::CopyFrom(const IntegerStatistic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pixels.proto.IntegerStatistic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IntegerStatistic::IsInitialized() const {
  return true;
}

void IntegerStatistic::InternalSwap(IntegerStatistic* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IntegerStatistic, _impl_.sum_)
      + sizeof(IntegerStatistic::_impl_.sum_)
      - PROTOBUF_FIELD_OFFSET(IntegerStatistic, _impl_.minimum_)>(
          reinterpret_cast<char*>(&_impl_.minimum_),
          reinterpret_cast<char*>(&other->_impl_.minimum_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IntegerStatistic::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pixels_2eproto_getter, &descriptor_table_pixels_2eproto_once,
      file_level_metadata_pixels_2eproto[7]);
}

// ===================================================================

class Integer128Statistic::_Internal {
 public:
  using HasBits = decltype(std::declval<Integer128Statistic>()._impl_._has_bits_);
  static void set_has_minimum_high(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_minimum_low(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_maximum_high(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_maximum_low(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Integer128Statistic::Integer128Statistic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pixels.proto.Integer128Statistic)
}
Integer128Statistic::Integer128Statistic(const Integer128Statistic& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Integer128Statistic* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.minimum_high_){}
    , decltype(_impl_.minimum_low_){}
    , decltype(_impl_.maximum_high_){}
    , decltype(_impl_.maximum_low_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.minimum_high_, &from._impl_.minimum_high_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.maximum_low_) -
    reinterpret_cast<char*>(&_impl_.minimum_high_)) + sizeof(_impl_.maximum_low_));
  // @@protoc_insertion_point(copy_constructor:pixels.proto.Integer128Statistic)
}

inline void Integer128Statistic::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.minimum_high_){uint64_t{0u}}
    , decltype(_impl_.minimum_low_){uint64_t{0u}}
    , decltype(_impl_.maximum_high_){int64_t{0}}
    , decltype(_impl_.maximum_low_){int64_t{0}}
  };
}

Integer128Statistic::~Integer128Statistic() {
  // @@protoc_insertion_point(destructor:pixels.proto.Integer128Statistic)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Integer128Statistic::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Integer128Statistic::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Integer128Statistic::Clear() {
// @@protoc_insertion_point(message_clear_start:pixels.proto.Integer128Statistic)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.minimum_high_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.maximum_low_) -
        reinterpret_cast<char*>(&_impl_.minimum_high_)) + sizeof(_impl_.maximum_low_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Integer128Statistic::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 minimum_high = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_minimum_high(&has_bits);
          _impl_.minimum_high_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 minimum_low = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_minimum_low(&has_bits);
          _impl_.minimum_low_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint64 maximum_high = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_maximum_high(&has_bits);
          _impl_.maximum_high_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint64 maximum_low = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_maximum_low(&has_bits);
          _impl_.maximum_low_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Integer128Statistic::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pixels.proto.Integer128Statistic)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 minimum_high = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_minimum_high(), target);
  }

  // optional uint64 minimum_low = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_minimum_low(), target);
  }

  // optional sint64 maximum_high = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(3, this->_internal_maximum_high(), target);
  }

  // optional sint64 maximum_low = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(4, this->_internal_maximum_low(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pixels.proto.Integer128Statistic)
  return target;
}

size_t Integer128Statistic::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pixels.proto.Integer128Statistic)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 minimum_high = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_minimum_high());
    }

    // optional uint64 minimum_low = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_minimum_low());
    }

    // optional sint64 maximum_high = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(this->_internal_maximum_high());
    }

    // optional sint64 maximum_low = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(this->_internal_maximum_low());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Integer128Statistic::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Integer128Statistic::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Integer128Statistic::GetClassData() const { return &_class_data_; }


void Integer128Statistic::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Integer128Statistic*>(&to_msg);
  auto& from = static_cast<const Integer128Statistic&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pixels.proto.Integer128Statistic)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.minimum_high_ = from._impl_.minimum_high_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.minimum_low_ = from._impl_.minimum_low_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.maximum_high_ = from._impl_.maximum_high_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.maximum_low_ = from._impl_.maximum_low_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Integer128Statistic::CopyFrom(const Integer128Statistic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pixels.proto.Integer128Statistic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Integer128Statistic::IsInitialized() const {
  return true;
}

void Integer128Statistic::InternalSwap(Integer128Statistic* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Integer128Statistic, _impl_.maximum_low_)
      + sizeof(Integer128Statistic::_impl_.maximum_low_)
      - PROTOBUF_FIELD_OFFSET(Integer128Statistic, _impl_.minimum_high_)>(
          reinterpret_cast<char*>(&_impl_.minimum_high_),
          reinterpret_cast<char*>(&other->_impl_.minimum_high_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Integer128Statistic::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pixels_2eproto_getter, &descriptor_table_pixels_2eproto_once,
      file_level_metadata_pixels_2eproto[8]);
}

// ===================================================================

class DoubleStatistic::_Internal {
 public:
  using HasBits = decltype(std::declval<DoubleStatistic>()._impl_._has_bits_);
  static void set_has_minimum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_maximum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sum(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

DoubleStatistic::DoubleStatistic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pixels.proto.DoubleStatistic)
}
DoubleStatistic::DoubleStatistic(const DoubleStatistic& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DoubleStatistic* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.minimum_){}
    , decltype(_impl_.maximum_){}
    , decltype(_impl_.sum_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.minimum_, &from._impl_.minimum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.sum_) -
    reinterpret_cast<char*>(&_impl_.minimum_)) + sizeof(_impl_.sum_));
  // @@protoc_insertion_point(copy_constructor:pixels.proto.DoubleStatistic)
}

inline void DoubleStatistic::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.minimum_){0}
    , decltype(_impl_.maximum_){0}
    , decltype(_impl_.sum_){0}
  };
}

DoubleStatistic::~DoubleStatistic() {
  // @@protoc_insertion_point(destructor:pixels.proto.DoubleStatistic)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DoubleStatistic::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DoubleStatistic::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DoubleStatistic::Clear() {
// @@protoc_insertion_point(message_clear_start:pixels.proto.DoubleStatistic)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.minimum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.sum_) -
        reinterpret_cast<char*>(&_impl_.minimum_)) + sizeof(_impl_.sum_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DoubleStatistic::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional double minimum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_minimum(&has_bits);
          _impl_.minimum_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double maximum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_maximum(&has_bits);
          _impl_.maximum_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional double sum = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_sum(&has_bits);
          _impl_.sum_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DoubleStatistic::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pixels.proto.DoubleStatistic)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional double minimum = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(1, this->_internal_minimum(), target);
  }

  // optional double maximum = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(2, this->_internal_maximum(), target);
  }

  // optional double sum = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_sum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pixels.proto.DoubleStatistic)
  return target;
}

size_t DoubleStatistic::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pixels.proto.DoubleStatistic)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional double minimum = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional double maximum = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional double sum = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DoubleStatistic::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DoubleStatistic::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DoubleStatistic::GetClassData() const { return &_class_data_; }


void DoubleStatistic::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DoubleStatistic*>(&to_msg);
  auto& from = static_cast<const DoubleStatistic&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pixels.proto.DoubleStatistic)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.minimum_ = from._impl_.minimum_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.maximum_ = from._impl_.maximum_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sum_ = from._impl_.sum_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DoubleStatistic::CopyFrom(const DoubleStatistic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pixels.proto.DoubleStatistic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DoubleStatistic::IsInitialized() const {
  return true;
}

void DoubleStatistic::InternalSwap(DoubleStatistic* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DoubleStatistic, _impl_.sum_)
      + sizeof(DoubleStatistic::_impl_.sum_)
      - PROTOBUF_FIELD_OFFSET(DoubleStatistic, _impl_.minimum_)>(
          reinterpret_cast<char*>(&_impl_.minimum_),
          reinterpret_cast<char*>(&other->_impl_.minimum_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DoubleStatistic::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pixels_2eproto_getter, &descriptor_table_pixels_2eproto_once,
      file_level_metadata_pixels_2eproto[9]);
}

// ===================================================================

class StringStatistic::_Internal {
 public:
  using HasBits = decltype(std::declval<StringStatistic>()._impl_._has_bits_);
  static void set_has_minimum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_maximum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sum(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

StringStatistic::StringStatistic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pixels.proto.StringStatistic)
}
StringStatistic::StringStatistic(const StringStatistic& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StringStatistic* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.minimum_){}
    , decltype(_impl_.maximum_){}
    , decltype(_impl_.sum_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.minimum_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.minimum_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_minimum()) {
    _this->_impl_.minimum_.Set(from._internal_minimum(), 
      _this->GetArenaForAllocation());
  }
  _impl_.maximum_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.maximum_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_maximum()) {
    _this->_impl_.maximum_.Set(from._internal_maximum(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.sum_ = from._impl_.sum_;
  // @@protoc_insertion_point(copy_constructor:pixels.proto.StringStatistic)
}

inline void StringStatistic::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.minimum_){}
    , decltype(_impl_.maximum_){}
    , decltype(_impl_.sum_){int64_t{0}}
  };
  _impl_.minimum_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.minimum_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.maximum_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.maximum_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StringStatistic::~StringStatistic() {
  // @@protoc_insertion_point(destructor:pixels.proto.StringStatistic)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StringStatistic::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.minimum_.Destroy();
  _impl_.maximum_.Destroy();
}

void StringStatistic::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StringStatistic::Clear() {
// @@protoc_insertion_point(message_clear_start:pixels.proto.StringStatistic)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.minimum_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.maximum_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.sum_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StringStatistic::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string minimum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_minimum();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "pixels.proto.StringStatistic.minimum");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string maximum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_maximum();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "pixels.proto.StringStatistic.maximum");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional sint64 sum = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_sum(&has_bits);
          _impl_.sum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StringStatistic::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pixels.proto.StringStatistic)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string minimum = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_minimum().data(), static_cast<int>(this->_internal_minimum().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "pixels.proto.StringStatistic.minimum");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_minimum(), target);
  }

  // optional string maximum = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_maximum().data(), static_cast<int>(this->_internal_maximum().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "pixels.proto.StringStatistic.maximum");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_maximum(), target);
  }

  // optional sint64 sum = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(3, this->_internal_sum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pixels.proto.StringStatistic)
  return target;
}

size_t StringStatistic::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pixels.proto.StringStatistic)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string minimum = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_minimum());
    }

    // optional string maximum = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_maximum());
    }

    // optional sint64 sum = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(this->_internal_sum());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StringStatistic::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StringStatistic::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StringStatistic::GetClassData() const { return &_class_data_; }


void StringStatistic::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StringStatistic*>(&to_msg);
  auto& from = static_cast<const StringStatistic&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pixels.proto.StringStatistic)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_minimum(from._internal_minimum());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_maximum(from._internal_maximum());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sum_ = from._impl_.sum_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StringStatistic::CopyFrom(const StringStatistic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pixels.proto.StringStatistic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StringStatistic::IsInitialized() const {
  return true;
}

void StringStatistic::InternalSwap(StringStatistic* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.minimum_, lhs_arena,
      &other->_impl_.minimum_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.maximum_, lhs_arena,
      &other->_impl_.maximum_, rhs_arena
  );
  swap(_impl_.sum_, other->_impl_.sum_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StringStatistic::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pixels_2eproto_getter, &descriptor_table_pixels_2eproto_once,
      file_level_metadata_pixels_2eproto[10]);
}

// ===================================================================

class BucketStatistic::_Internal {
 public:
};

BucketStatistic::BucketStatistic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pixels.proto.BucketStatistic)
}
BucketStatistic::BucketStatistic(const BucketStatistic& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BucketStatistic* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.count_){from._impl_.count_}
    , /*decltype(_impl_._count_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pixels.proto.BucketStatistic)
}

inline void BucketStatistic::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.count_){arena}
    , /*decltype(_impl_._count_cached_byte_size_)*/{0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BucketStatistic::~BucketStatistic() {
  // @@protoc_insertion_point(destructor:pixels.proto.BucketStatistic)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BucketStatistic::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.count_.~RepeatedField();
}

void BucketStatistic::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BucketStatistic::Clear() {
// @@protoc_insertion_point(message_clear_start:pixels.proto.BucketStatistic)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.count_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BucketStatistic::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 count = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_count(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_count(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BucketStatistic::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pixels.proto.BucketStatistic)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 count = 1 [packed = true];
  {
    int byte_size = _impl_._count_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt64Packed(
          1, _internal_count(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pixels.proto.BucketStatistic)
  return target;
}

size_t BucketStatistic::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pixels.proto.BucketStatistic)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 count = 1 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt64Size(this->_impl_.count_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._count_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BucketStatistic::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BucketStatistic::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BucketStatistic::GetClassData() const { return &_class_data_; }


void BucketStatistic::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BucketStatistic*>(&to_msg);
  auto& from = static_cast<const BucketStatistic&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pixels.proto.BucketStatistic)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.count_.MergeFrom(from._impl_.count_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BucketStatistic::CopyFrom(const BucketStatistic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pixels.proto.BucketStatistic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BucketStatistic::IsInitialized() const {
  return true;
}

void BucketStatistic::InternalSwap(BucketStatistic* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.count_.InternalSwap(&other->_impl_.count_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BucketStatistic::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pixels_2eproto_getter, &descriptor_table_pixels_2eproto_once,
      file_level_metadata_pixels_2eproto[11]);
}

// ===================================================================

class TimestampStatistic::_Internal {
 public:
  using HasBits = decltype(std::declval<TimestampStatistic>()._impl_._has_bits_);
  static void set_has_minimum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_maximum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TimestampStatistic::TimestampStatistic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pixels.proto.TimestampStatistic)
}
TimestampStatistic::TimestampStatistic(const TimestampStatistic& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TimestampStatistic* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.minimum_){}
    , decltype(_impl_.maximum_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.minimum_, &from._impl_.minimum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.maximum_) -
    reinterpret_cast<char*>(&_impl_.minimum_)) + sizeof(_impl_.maximum_));
  // @@protoc_insertion_point(copy_constructor:pixels.proto.TimestampStatistic)
}

inline void TimestampStatistic::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.minimum_){int64_t{0}}
    , decltype(_impl_.maximum_){int64_t{0}}
  };
}

TimestampStatistic::~TimestampStatistic() {
  // @@protoc_insertion_point(destructor:pixels.proto.TimestampStatistic)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TimestampStatistic::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TimestampStatistic::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TimestampStatistic::Clear() {
// @@protoc_insertion_point(message_clear_start:pixels.proto.TimestampStatistic)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.minimum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.maximum_) -
        reinterpret_cast<char*>(&_impl_.minimum_)) + sizeof(_impl_.maximum_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TimestampStatistic::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional sint64 minimum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_minimum(&has_bits);
          _impl_.minimum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint64 maximum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_maximum(&has_bits);
          _impl_.maximum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TimestampStatistic::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pixels.proto.TimestampStatistic)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional sint64 minimum = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(1, this->_internal_minimum(), target);
  }

  // optional sint64 maximum = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(2, this->_internal_maximum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pixels.proto.TimestampStatistic)
  return target;
}

size_t TimestampStatistic::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pixels.proto.TimestampStatistic)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional sint64 minimum = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(this->_internal_minimum());
    }

    // optional sint64 maximum = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(this->_internal_maximum());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TimestampStatistic::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TimestampStatistic::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TimestampStatistic::GetClassData() const { return &_class_data_; }


void TimestampStatistic::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TimestampStatistic*>(&to_msg);
  auto& from = static_cast<const TimestampStatistic&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pixels.proto.TimestampStatistic)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.minimum_ = from._impl_.minimum_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.maximum_ = from._impl_.maximum_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TimestampStatistic::CopyFrom(const TimestampStatistic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pixels.proto.TimestampStatistic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimestampStatistic::IsInitialized() const {
  return true;
}

void TimestampStatistic::InternalSwap(TimestampStatistic* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TimestampStatistic, _impl_.maximum_)
      + sizeof(TimestampStatistic::_impl_.maximum_)
      - PROTOBUF_FIELD_OFFSET(TimestampStatistic, _impl_.minimum_)>(
          reinterpret_cast<char*>(&_impl_.minimum_),
          reinterpret_cast<char*>(&other->_impl_.minimum_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TimestampStatistic::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pixels_2eproto_getter, &descriptor_table_pixels_2eproto_once,
      file_level_metadata_pixels_2eproto[12]);
}

// ===================================================================

class DateStatistic::_Internal {
 public:
  using HasBits = decltype(std::declval<DateStatistic>()._impl_._has_bits_);
  static void set_has_minimum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_maximum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

DateStatistic::DateStatistic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pixels.proto.DateStatistic)
}
DateStatistic::DateStatistic(const DateStatistic& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DateStatistic* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.minimum_){}
    , decltype(_impl_.maximum_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.minimum_, &from._impl_.minimum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.maximum_) -
    reinterpret_cast<char*>(&_impl_.minimum_)) + sizeof(_impl_.maximum_));
  // @@protoc_insertion_point(copy_constructor:pixels.proto.DateStatistic)
}

inline void DateStatistic::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.minimum_){0}
    , decltype(_impl_.maximum_){0}
  };
}

DateStatistic::~DateStatistic() {
  // @@protoc_insertion_point(destructor:pixels.proto.DateStatistic)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DateStatistic::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DateStatistic::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DateStatistic::Clear() {
// @@protoc_insertion_point(message_clear_start:pixels.proto.DateStatistic)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.minimum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.maximum_) -
        reinterpret_cast<char*>(&_impl_.minimum_)) + sizeof(_impl_.maximum_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DateStatistic::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional sint32 minimum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_minimum(&has_bits);
          _impl_.minimum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint32 maximum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_maximum(&has_bits);
          _impl_.maximum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DateStatistic::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pixels.proto.DateStatistic)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional sint32 minimum = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(1, this->_internal_minimum(), target);
  }

  // optional sint32 maximum = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(2, this->_internal_maximum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pixels.proto.DateStatistic)
  return target;
}

size_t DateStatistic::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pixels.proto.DateStatistic)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional sint32 minimum = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_minimum());
    }

    // optional sint32 maximum = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_maximum());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DateStatistic::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DateStatistic::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DateStatistic::GetClassData() const { return &_class_data_; }


void DateStatistic::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DateStatistic*>(&to_msg);
  auto& from = static_cast<const DateStatistic&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pixels.proto.DateStatistic)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.minimum_ = from._impl_.minimum_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.maximum_ = from._impl_.maximum_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DateStatistic::CopyFrom(const DateStatistic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pixels.proto.DateStatistic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DateStatistic::IsInitialized() const {
  return true;
}

void DateStatistic::InternalSwap(DateStatistic* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DateStatistic, _impl_.maximum_)
      + sizeof(DateStatistic::_impl_.maximum_)
      - PROTOBUF_FIELD_OFFSET(DateStatistic, _impl_.minimum_)>(
          reinterpret_cast<char*>(&_impl_.minimum_),
          reinterpret_cast<char*>(&other->_impl_.minimum_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DateStatistic::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pixels_2eproto_getter, &descriptor_table_pixels_2eproto_once,
      file_level_metadata_pixels_2eproto[13]);
}

// ===================================================================

class TimeStatistic::_Internal {
 public:
  using HasBits = decltype(std::declval<TimeStatistic>()._impl_._has_bits_);
  static void set_has_minimum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_maximum(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

TimeStatistic::TimeStatistic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pixels.proto.TimeStatistic)
}
TimeStatistic::TimeStatistic(const TimeStatistic& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TimeStatistic* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.minimum_){}
    , decltype(_impl_.maximum_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.minimum_, &from._impl_.minimum_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.maximum_) -
    reinterpret_cast<char*>(&_impl_.minimum_)) + sizeof(_impl_.maximum_));
  // @@protoc_insertion_point(copy_constructor:pixels.proto.TimeStatistic)
}

inline void TimeStatistic::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.minimum_){0}
    , decltype(_impl_.maximum_){0}
  };
}

TimeStatistic::~TimeStatistic() {
  // @@protoc_insertion_point(destructor:pixels.proto.TimeStatistic)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TimeStatistic::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TimeStatistic::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TimeStatistic::Clear() {
// @@protoc_insertion_point(message_clear_start:pixels.proto.TimeStatistic)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.minimum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.maximum_) -
        reinterpret_cast<char*>(&_impl_.minimum_)) + sizeof(_impl_.maximum_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TimeStatistic::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional sint32 minimum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_minimum(&has_bits);
          _impl_.minimum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint32 maximum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_maximum(&has_bits);
          _impl_.maximum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TimeStatistic::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pixels.proto.TimeStatistic)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional sint32 minimum = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(1, this->_internal_minimum(), target);
  }

  // optional sint32 maximum = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(2, this->_internal_maximum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pixels.proto.TimeStatistic)
  return target;
}

size_t TimeStatistic::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pixels.proto.TimeStatistic)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional sint32 minimum = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_minimum());
    }

    // optional sint32 maximum = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_maximum());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TimeStatistic::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TimeStatistic::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TimeStatistic::GetClassData() const { return &_class_data_; }


void TimeStatistic::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TimeStatistic*>(&to_msg);
  auto& from = static_cast<const TimeStatistic&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pixels.proto.TimeStatistic)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.minimum_ = from._impl_.minimum_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.maximum_ = from._impl_.maximum_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TimeStatistic::CopyFrom(const TimeStatistic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pixels.proto.TimeStatistic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimeStatistic::IsInitialized() const {
  return true;
}

void TimeStatistic::InternalSwap(TimeStatistic* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TimeStatistic, _impl_.maximum_)
      + sizeof(TimeStatistic::_impl_.maximum_)
      - PROTOBUF_FIELD_OFFSET(TimeStatistic, _impl_.minimum_)>(
          reinterpret_cast<char*>(&_impl_.minimum_),
          reinterpret_cast<char*>(&other->_impl_.minimum_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TimeStatistic::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pixels_2eproto_getter, &descriptor_table_pixels_2eproto_once,
      file_level_metadata_pixels_2eproto[14]);
}

// ===================================================================

class BinaryStatistic::_Internal {
 public:
  using HasBits = decltype(std::declval<BinaryStatistic>()._impl_._has_bits_);
  static void set_has_sum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

BinaryStatistic::BinaryStatistic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pixels.proto.BinaryStatistic)
}
BinaryStatistic::BinaryStatistic(const BinaryStatistic& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BinaryStatistic* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sum_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.sum_ = from._impl_.sum_;
  // @@protoc_insertion_point(copy_constructor:pixels.proto.BinaryStatistic)
}

inline void BinaryStatistic::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sum_){int64_t{0}}
  };
}

BinaryStatistic::~BinaryStatistic() {
  // @@protoc_insertion_point(destructor:pixels.proto.BinaryStatistic)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BinaryStatistic::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BinaryStatistic::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BinaryStatistic::Clear() {
// @@protoc_insertion_point(message_clear_start:pixels.proto.BinaryStatistic)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sum_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BinaryStatistic::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional sint64 sum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_sum(&has_bits);
          _impl_.sum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BinaryStatistic::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pixels.proto.BinaryStatistic)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional sint64 sum = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt64ToArray(1, this->_internal_sum(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pixels.proto.BinaryStatistic)
  return target;
}

size_t BinaryStatistic::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pixels.proto.BinaryStatistic)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional sint64 sum = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::SInt64SizePlusOne(this->_internal_sum());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BinaryStatistic::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BinaryStatistic::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BinaryStatistic::GetClassData() const { return &_class_data_; }


void BinaryStatistic::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BinaryStatistic*>(&to_msg);
  auto& from = static_cast<const BinaryStatistic&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pixels.proto.BinaryStatistic)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_sum()) {
    _this->_internal_set_sum(from._internal_sum());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BinaryStatistic::CopyFrom(const BinaryStatistic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pixels.proto.BinaryStatistic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BinaryStatistic::IsInitialized() const {
  return true;
}

void BinaryStatistic::InternalSwap(BinaryStatistic* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.sum_, other->_impl_.sum_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BinaryStatistic::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pixels_2eproto_getter, &descriptor_table_pixels_2eproto_once,
      file_level_metadata_pixels_2eproto[15]);
}

// ===================================================================

class ColumnStatistic::_Internal {
 public:
  using HasBits = decltype(std::declval<ColumnStatistic>()._impl_._has_bits_);
  static void set_has_numberofvalues(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::pixels::proto::IntegerStatistic& intstatistics(const ColumnStatistic* msg);
  static void set_has_intstatistics(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::pixels::proto::DoubleStatistic& doublestatistics(const ColumnStatistic* msg);
  static void set_has_doublestatistics(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::pixels::proto::StringStatistic& stringstatistics(const ColumnStatistic* msg);
  static void set_has_stringstatistics(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::pixels::proto::BucketStatistic& bucketstatistics(const ColumnStatistic* msg);
  static void set_has_bucketstatistics(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::pixels::proto::BinaryStatistic& binarystatistics(const ColumnStatistic* msg);
  static void set_has_binarystatistics(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::pixels::proto::TimestampStatistic& timestampstatistics(const ColumnStatistic* msg);
  static void set_has_timestampstatistics(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::pixels::proto::DateStatistic& datestatistics(const ColumnStatistic* msg);
  static void set_has_datestatistics(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::pixels::proto::TimeStatistic& timestatistics(const ColumnStatistic* msg);
  static void set_has_timestatistics(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::pixels::proto::Integer128Statistic& int128statistics(const ColumnStatistic* msg);
  static void set_has_int128statistics(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_hasnull(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

const ::pixels::proto::IntegerStatistic&
ColumnStatistic::_Internal::intstatistics(const ColumnStatistic* msg) {
  return *msg->_impl_.intstatistics_;
}
const ::pixels::proto::DoubleStatistic&
ColumnStatistic::_Internal::doublestatistics(const ColumnStatistic* msg) {
  return *msg->_impl_.doublestatistics_;
}
const ::pixels::proto::StringStatistic&
ColumnStatistic::_Internal::stringstatistics(const ColumnStatistic* msg) {
  return *msg->_impl_.stringstatistics_;
}
const ::pixels::proto::BucketStatistic&
ColumnStatistic::_Internal::bucketstatistics(const ColumnStatistic* msg) {
  return *msg->_impl_.bucketstatistics_;
}
const ::pixels::proto::BinaryStatistic&
ColumnStatistic::_Internal::binarystatistics(const ColumnStatistic* msg) {
  return *msg->_impl_.binarystatistics_;
}
const ::pixels::proto::TimestampStatistic&
ColumnStatistic::_Internal::timestampstatistics(const ColumnStatistic* msg) {
  return *msg->_impl_.timestampstatistics_;
}
const ::pixels::proto::DateStatistic&
ColumnStatistic::_Internal::datestatistics(const ColumnStatistic* msg) {
  return *msg->_impl_.datestatistics_;
}
const ::pixels::proto::TimeStatistic&
ColumnStatistic::_Internal::timestatistics(const ColumnStatistic* msg) {
  return *msg->_impl_.timestatistics_;
}
const ::pixels::proto::Integer128Statistic&
ColumnStatistic::_Internal::int128statistics(const ColumnStatistic* msg) {
  return *msg->_impl_.int128statistics_;
}
ColumnStatistic::ColumnStatistic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pixels.proto.ColumnStatistic)
}
ColumnStatistic::ColumnStatistic(const ColumnStatistic& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ColumnStatistic* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.intstatistics_){nullptr}
    , decltype(_impl_.doublestatistics_){nullptr}
    , decltype(_impl_.stringstatistics_){nullptr}
    , decltype(_impl_.bucketstatistics_){nullptr}
    , decltype(_impl_.binarystatistics_){nullptr}
    , decltype(_impl_.timestampstatistics_){nullptr}
    , decltype(_impl_.datestatistics_){nullptr}
    , decltype(_impl_.timestatistics_){nullptr}
    , decltype(_impl_.int128statistics_){nullptr}
    , decltype(_impl_.numberofvalues_){}
    , decltype(_impl_.hasnull_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_intstatistics()) {
    _this->_impl_.intstatistics_ = new ::pixels::proto::IntegerStatistic(*from._impl_.intstatistics_);
  }
  if (from._internal_has_doublestatistics()) {
    _this->_impl_.doublestatistics_ = new ::pixels::proto::DoubleStatistic(*from._impl_.doublestatistics_);
  }
  if (from._internal_has_stringstatistics()) {
    _this->_impl_.stringstatistics_ = new ::pixels::proto::StringStatistic(*from._impl_.stringstatistics_);
  }
  if (from._internal_has_bucketstatistics()) {
    _this->_impl_.bucketstatistics_ = new ::pixels::proto::BucketStatistic(*from._impl_.bucketstatistics_);
  }
  if (from._internal_has_binarystatistics()) {
    _this->_impl_.binarystatistics_ = new ::pixels::proto::BinaryStatistic(*from._impl_.binarystatistics_);
  }
  if (from._internal_has_timestampstatistics()) {
    _this->_impl_.timestampstatistics_ = new ::pixels::proto::TimestampStatistic(*from._impl_.timestampstatistics_);
  }
  if (from._internal_has_datestatistics()) {
    _this->_impl_.datestatistics_ = new ::pixels::proto::DateStatistic(*from._impl_.datestatistics_);
  }
  if (from._internal_has_timestatistics()) {
    _this->_impl_.timestatistics_ = new ::pixels::proto::TimeStatistic(*from._impl_.timestatistics_);
  }
  if (from._internal_has_int128statistics()) {
    _this->_impl_.int128statistics_ = new ::pixels::proto::Integer128Statistic(*from._impl_.int128statistics_);
  }
  ::memcpy(&_impl_.numberofvalues_, &from._impl_.numberofvalues_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.hasnull_) -
    reinterpret_cast<char*>(&_impl_.numberofvalues_)) + sizeof(_impl_.hasnull_));
  // @@protoc_insertion_point(copy_constructor:pixels.proto.ColumnStatistic)
}

inline void ColumnStatistic::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.intstatistics_){nullptr}
    , decltype(_impl_.doublestatistics_){nullptr}
    , decltype(_impl_.stringstatistics_){nullptr}
    , decltype(_impl_.bucketstatistics_){nullptr}
    , decltype(_impl_.binarystatistics_){nullptr}
    , decltype(_impl_.timestampstatistics_){nullptr}
    , decltype(_impl_.datestatistics_){nullptr}
    , decltype(_impl_.timestatistics_){nullptr}
    , decltype(_impl_.int128statistics_){nullptr}
    , decltype(_impl_.numberofvalues_){uint64_t{0u}}
    , decltype(_impl_.hasnull_){false}
  };
}

ColumnStatistic::~ColumnStatistic() {
  // @@protoc_insertion_point(destructor:pixels.proto.ColumnStatistic)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ColumnStatistic::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.intstatistics_;
  if (this != internal_default_instance()) delete _impl_.doublestatistics_;
  if (this != internal_default_instance()) delete _impl_.stringstatistics_;
  if (this != internal_default_instance()) delete _impl_.bucketstatistics_;
  if (this != internal_default_instance()) delete _impl_.binarystatistics_;
  if (this != internal_default_instance()) delete _impl_.timestampstatistics_;
  if (this != internal_default_instance()) delete _impl_.datestatistics_;
  if (this != internal_default_instance()) delete _impl_.timestatistics_;
  if (this != internal_default_instance()) delete _impl_.int128statistics_;
}

void ColumnStatistic::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ColumnStatistic::Clear() {
// @@protoc_insertion_point(message_clear_start:pixels.proto.ColumnStatistic)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.intstatistics_ != nullptr);
      _impl_.intstatistics_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.doublestatistics_ != nullptr);
      _impl_.doublestatistics_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.stringstatistics_ != nullptr);
      _impl_.stringstatistics_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.bucketstatistics_ != nullptr);
      _impl_.bucketstatistics_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.binarystatistics_ != nullptr);
      _impl_.binarystatistics_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.timestampstatistics_ != nullptr);
      _impl_.timestampstatistics_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.datestatistics_ != nullptr);
      _impl_.datestatistics_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.timestatistics_ != nullptr);
      _impl_.timestatistics_->Clear();
    }
  }
  if (cached_has_bits & 0x00000100u) {
    GOOGLE_DCHECK(_impl_.int128statistics_ != nullptr);
    _impl_.int128statistics_->Clear();
  }
  if (cached_has_bits & 0x00000600u) {
    ::memset(&_impl_.numberofvalues_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.hasnull_) -
        reinterpret_cast<char*>(&_impl_.numberofvalues_)) + sizeof(_impl_.hasnull_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ColumnStatistic::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 numberOfValues = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_numberofvalues(&has_bits);
          _impl_.numberofvalues_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .pixels.proto.IntegerStatistic intStatistics = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_intstatistics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .pixels.proto.DoubleStatistic doubleStatistics = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_doublestatistics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .pixels.proto.StringStatistic stringStatistics = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_stringstatistics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .pixels.proto.BucketStatistic bucketStatistics = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_bucketstatistics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .pixels.proto.BinaryStatistic binaryStatistics = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_binarystatistics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .pixels.proto.TimestampStatistic timestampStatistics = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestampstatistics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool hasNull = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_hasnull(&has_bits);
          _impl_.hasnull_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .pixels.proto.DateStatistic dateStatistics = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_datestatistics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .pixels.proto.TimeStatistic timeStatistics = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_timestatistics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .pixels.proto.Integer128Statistic int128Statistics = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_int128statistics(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ColumnStatistic::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pixels.proto.ColumnStatistic)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 numberOfValues = 1;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_numberofvalues(), target);
  }

  // optional .pixels.proto.IntegerStatistic intStatistics = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::intstatistics(this),
        _Internal::intstatistics(this).GetCachedSize(), target, stream);
  }

  // optional .pixels.proto.DoubleStatistic doubleStatistics = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::doublestatistics(this),
        _Internal::doublestatistics(this).GetCachedSize(), target, stream);
  }

  // optional .pixels.proto.StringStatistic stringStatistics = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::stringstatistics(this),
        _Internal::stringstatistics(this).GetCachedSize(), target, stream);
  }

  // optional .pixels.proto.BucketStatistic bucketStatistics = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::bucketstatistics(this),
        _Internal::bucketstatistics(this).GetCachedSize(), target, stream);
  }

  // optional .pixels.proto.BinaryStatistic binaryStatistics = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::binarystatistics(this),
        _Internal::binarystatistics(this).GetCachedSize(), target, stream);
  }

  // optional .pixels.proto.TimestampStatistic timestampStatistics = 7;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::timestampstatistics(this),
        _Internal::timestampstatistics(this).GetCachedSize(), target, stream);
  }

  // optional bool hasNull = 8;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_hasnull(), target);
  }

  // optional .pixels.proto.DateStatistic dateStatistics = 9;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::datestatistics(this),
        _Internal::datestatistics(this).GetCachedSize(), target, stream);
  }

  // optional .pixels.proto.TimeStatistic timeStatistics = 10;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::timestatistics(this),
        _Internal::timestatistics(this).GetCachedSize(), target, stream);
  }

  // optional .pixels.proto.Integer128Statistic int128Statistics = 11;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::int128statistics(this),
        _Internal::int128statistics(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pixels.proto.ColumnStatistic)
  return target;
}

size_t ColumnStatistic::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pixels.proto.ColumnStatistic)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .pixels.proto.IntegerStatistic intStatistics = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.intstatistics_);
    }

    // optional .pixels.proto.DoubleStatistic doubleStatistics = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.doublestatistics_);
    }

    // optional .pixels.proto.StringStatistic stringStatistics = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.stringstatistics_);
    }

    // optional .pixels.proto.BucketStatistic bucketStatistics = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.bucketstatistics_);
    }

    // optional .pixels.proto.BinaryStatistic binaryStatistics = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.binarystatistics_);
    }

    // optional .pixels.proto.TimestampStatistic timestampStatistics = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.timestampstatistics_);
    }

    // optional .pixels.proto.DateStatistic dateStatistics = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.datestatistics_);
    }

    // optional .pixels.proto.TimeStatistic timeStatistics = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.timestatistics_);
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional .pixels.proto.Integer128Statistic int128Statistics = 11;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.int128statistics_);
    }

    // optional uint64 numberOfValues = 1;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_numberofvalues());
    }

    // optional bool hasNull = 8;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ColumnStatistic::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ColumnStatistic::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ColumnStatistic::GetClassData() const { return &_class_data_; }


void ColumnStatistic::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ColumnStatistic*>(&to_msg);
  auto& from = static_cast<const ColumnStatistic&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pixels.proto.ColumnStatistic)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_intstatistics()->::pixels::proto::IntegerStatistic::MergeFrom(
          from._internal_intstatistics());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_doublestatistics()->::pixels::proto::DoubleStatistic::MergeFrom(
          from._internal_doublestatistics());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_stringstatistics()->::pixels::proto::StringStatistic::MergeFrom(
          from._internal_stringstatistics());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_bucketstatistics()->::pixels::proto::BucketStatistic::MergeFrom(
          from._internal_bucketstatistics());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_binarystatistics()->::pixels::proto::BinaryStatistic::MergeFrom(
          from._internal_binarystatistics());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_timestampstatistics()->::pixels::proto::TimestampStatistic::MergeFrom(
          from._internal_timestampstatistics());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_datestatistics()->::pixels::proto::DateStatistic::MergeFrom(
          from._internal_datestatistics());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_timestatistics()->::pixels::proto::TimeStatistic::MergeFrom(
          from._internal_timestatistics());
    }
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_int128statistics()->::pixels::proto::Integer128Statistic::MergeFrom(
          from._internal_int128statistics());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.numberofvalues_ = from._impl_.numberofvalues_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.hasnull_ = from._impl_.hasnull_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ColumnStatistic::CopyFrom(const ColumnStatistic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pixels.proto.ColumnStatistic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColumnStatistic::IsInitialized() const {
  return true;
}

void ColumnStatistic::InternalSwap(ColumnStatistic* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ColumnStatistic, _impl_.hasnull_)
      + sizeof(ColumnStatistic::_impl_.hasnull_)
      - PROTOBUF_FIELD_OFFSET(ColumnStatistic, _impl_.intstatistics_)>(
          reinterpret_cast<char*>(&_impl_.intstatistics_),
          reinterpret_cast<char*>(&other->_impl_.intstatistics_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ColumnStatistic::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pixels_2eproto_getter, &descriptor_table_pixels_2eproto_once,
      file_level_metadata_pixels_2eproto[16]);
}

// ===================================================================

class PixelStatistic::_Internal {
 public:
  using HasBits = decltype(std::declval<PixelStatistic>()._impl_._has_bits_);
  static const ::pixels::proto::ColumnStatistic& statistic(const PixelStatistic* msg);
  static void set_has_statistic(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::pixels::proto::ColumnStatistic&
PixelStatistic::_Internal::statistic(const PixelStatistic* msg) {
  return *msg->_impl_.statistic_;
}
PixelStatistic::PixelStatistic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pixels.proto.PixelStatistic)
}
PixelStatistic::PixelStatistic(const PixelStatistic& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PixelStatistic* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.statistic_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_statistic()) {
    _this->_impl_.statistic_ = new ::pixels::proto::ColumnStatistic(*from._impl_.statistic_);
  }
  // @@protoc_insertion_point(copy_constructor:pixels.proto.PixelStatistic)
}

inline void PixelStatistic::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.statistic_){nullptr}
  };
}

PixelStatistic::~PixelStatistic() {
  // @@protoc_insertion_point(destructor:pixels.proto.PixelStatistic)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PixelStatistic::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.statistic_;
}

void PixelStatistic::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PixelStatistic::Clear() {
// @@protoc_insertion_point(message_clear_start:pixels.proto.PixelStatistic)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.statistic_ != nullptr);
    _impl_.statistic_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PixelStatistic::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .pixels.proto.ColumnStatistic statistic = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_statistic(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PixelStatistic::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pixels.proto.PixelStatistic)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .pixels.proto.ColumnStatistic statistic = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::statistic(this),
        _Internal::statistic(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pixels.proto.PixelStatistic)
  return target;
}

size_t PixelStatistic::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pixels.proto.PixelStatistic)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .pixels.proto.ColumnStatistic statistic = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.statistic_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PixelStatistic::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PixelStatistic::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PixelStatistic::GetClassData() const { return &_class_data_; }


void PixelStatistic::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PixelStatistic*>(&to_msg);
  auto& from = static_cast<const PixelStatistic&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pixels.proto.PixelStatistic)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_statistic()) {
    _this->_internal_mutable_statistic()->::pixels::proto::ColumnStatistic::MergeFrom(
        from._internal_statistic());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PixelStatistic::CopyFrom(const PixelStatistic& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pixels.proto.PixelStatistic)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PixelStatistic::IsInitialized() const {
  return true;
}

void PixelStatistic::InternalSwap(PixelStatistic* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.statistic_, other->_impl_.statistic_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PixelStatistic::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pixels_2eproto_getter, &descriptor_table_pixels_2eproto_once,
      file_level_metadata_pixels_2eproto[17]);
}

// ===================================================================

class ColumnChunkIndex::_Internal {
 public:
  using HasBits = decltype(std::declval<ColumnChunkIndex>()._impl_._has_bits_);
  static void set_has_chunkoffset(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_chunklength(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_isnulloffset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_littleendian(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_nullspadding(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_isnullalignment(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

ColumnChunkIndex::ColumnChunkIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pixels.proto.ColumnChunkIndex)
}
ColumnChunkIndex::ColumnChunkIndex(const ColumnChunkIndex& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ColumnChunkIndex* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pixelpositions_){from._impl_.pixelpositions_}
    , /*decltype(_impl_._pixelpositions_cached_byte_size_)*/{0}
    , decltype(_impl_.pixelstatistics_){from._impl_.pixelstatistics_}
    , decltype(_impl_.chunkoffset_){}
    , decltype(_impl_.chunklength_){}
    , decltype(_impl_.isnulloffset_){}
    , decltype(_impl_.littleendian_){}
    , decltype(_impl_.nullspadding_){}
    , decltype(_impl_.isnullalignment_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.chunkoffset_, &from._impl_.chunkoffset_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.isnullalignment_) -
    reinterpret_cast<char*>(&_impl_.chunkoffset_)) + sizeof(_impl_.isnullalignment_));
  // @@protoc_insertion_point(copy_constructor:pixels.proto.ColumnChunkIndex)
}

inline void ColumnChunkIndex::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pixelpositions_){arena}
    , /*decltype(_impl_._pixelpositions_cached_byte_size_)*/{0}
    , decltype(_impl_.pixelstatistics_){arena}
    , decltype(_impl_.chunkoffset_){uint64_t{0u}}
    , decltype(_impl_.chunklength_){0u}
    , decltype(_impl_.isnulloffset_){0u}
    , decltype(_impl_.littleendian_){false}
    , decltype(_impl_.nullspadding_){false}
    , decltype(_impl_.isnullalignment_){0u}
  };
}

ColumnChunkIndex::~ColumnChunkIndex() {
  // @@protoc_insertion_point(destructor:pixels.proto.ColumnChunkIndex)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ColumnChunkIndex::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pixelpositions_.~RepeatedField();
  _impl_.pixelstatistics_.~RepeatedPtrField();
}

void ColumnChunkIndex::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ColumnChunkIndex::Clear() {
// @@protoc_insertion_point(message_clear_start:pixels.proto.ColumnChunkIndex)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.pixelpositions_.Clear();
  _impl_.pixelstatistics_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.chunkoffset_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.isnullalignment_) -
        reinterpret_cast<char*>(&_impl_.chunkoffset_)) + sizeof(_impl_.isnullalignment_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ColumnChunkIndex::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 chunkOffset = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_chunkoffset(&has_bits);
          _impl_.chunkoffset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 chunkLength = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_chunklength(&has_bits);
          _impl_.chunklength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 isNullOffset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_isnulloffset(&has_bits);
          _impl_.isnulloffset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 pixelPositions = 4 [packed = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_pixelpositions(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_pixelpositions(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .pixels.proto.PixelStatistic pixelStatistics = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_pixelstatistics(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool littleEndian = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_littleendian(&has_bits);
          _impl_.littleendian_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool nullsPadding = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_nullspadding(&has_bits);
          _impl_.nullspadding_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 isNullAlignment = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_isnullalignment(&has_bits);
          _impl_.isnullalignment_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ColumnChunkIndex::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pixels.proto.ColumnChunkIndex)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 chunkOffset = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_chunkoffset(), target);
  }

  // optional uint32 chunkLength = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_chunklength(), target);
  }

  // optional uint32 isNullOffset = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_isnulloffset(), target);
  }

  // repeated uint32 pixelPositions = 4 [packed = true];
  {
    int byte_size = _impl_._pixelpositions_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          4, _internal_pixelpositions(), byte_size, target);
    }
  }

  // repeated .pixels.proto.PixelStatistic pixelStatistics = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_pixelstatistics_size()); i < n; i++) {
    const auto& repfield = this->_internal_pixelstatistics(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool littleEndian = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_littleendian(), target);
  }

  // optional bool nullsPadding = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_nullspadding(), target);
  }

  // optional uint32 isNullAlignment = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_isnullalignment(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pixels.proto.ColumnChunkIndex)
  return target;
}

size_t ColumnChunkIndex::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pixels.proto.ColumnChunkIndex)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 pixelPositions = 4 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.pixelpositions_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._pixelpositions_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated .pixels.proto.PixelStatistic pixelStatistics = 5;
  total_size += 1UL * this->_internal_pixelstatistics_size();
  for (const auto& msg : this->_impl_.pixelstatistics_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional uint64 chunkOffset = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_chunkoffset());
    }

    // optional uint32 chunkLength = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_chunklength());
    }

    // optional uint32 isNullOffset = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_isnulloffset());
    }

    // optional bool littleEndian = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool nullsPadding = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional uint32 isNullAlignment = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_isnullalignment());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ColumnChunkIndex::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ColumnChunkIndex::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ColumnChunkIndex::GetClassData() const { return &_class_data_; }


void ColumnChunkIndex::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ColumnChunkIndex*>(&to_msg);
  auto& from = static_cast<const ColumnChunkIndex&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pixels.proto.ColumnChunkIndex)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.pixelpositions_.MergeFrom(from._impl_.pixelpositions_);
  _this->_impl_.pixelstatistics_.MergeFrom(from._impl_.pixelstatistics_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.chunkoffset_ = from._impl_.chunkoffset_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.chunklength_ = from._impl_.chunklength_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.isnulloffset_ = from._impl_.isnulloffset_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.littleendian_ = from._impl_.littleendian_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.nullspadding_ = from._impl_.nullspadding_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.isnullalignment_ = from._impl_.isnullalignment_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ColumnChunkIndex::CopyFrom(const ColumnChunkIndex& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pixels.proto.ColumnChunkIndex)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColumnChunkIndex::IsInitialized() const {
  return true;
}

void ColumnChunkIndex::InternalSwap(ColumnChunkIndex* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.pixelpositions_.InternalSwap(&other->_impl_.pixelpositions_);
  _impl_.pixelstatistics_.InternalSwap(&other->_impl_.pixelstatistics_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ColumnChunkIndex, _impl_.isnullalignment_)
      + sizeof(ColumnChunkIndex::_impl_.isnullalignment_)
      - PROTOBUF_FIELD_OFFSET(ColumnChunkIndex, _impl_.chunkoffset_)>(
          reinterpret_cast<char*>(&_impl_.chunkoffset_),
          reinterpret_cast<char*>(&other->_impl_.chunkoffset_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ColumnChunkIndex::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pixels_2eproto_getter, &descriptor_table_pixels_2eproto_once,
      file_level_metadata_pixels_2eproto[18]);
}

// ===================================================================

class RowGroupIndex::_Internal {
 public:
};

RowGroupIndex::RowGroupIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pixels.proto.RowGroupIndex)
}
RowGroupIndex::RowGroupIndex(const RowGroupIndex& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RowGroupIndex* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.columnchunkindexentries_){from._impl_.columnchunkindexentries_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pixels.proto.RowGroupIndex)
}

inline void RowGroupIndex::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.columnchunkindexentries_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RowGroupIndex::~RowGroupIndex() {
  // @@protoc_insertion_point(destructor:pixels.proto.RowGroupIndex)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RowGroupIndex::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.columnchunkindexentries_.~RepeatedPtrField();
}

void RowGroupIndex::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RowGroupIndex::Clear() {
// @@protoc_insertion_point(message_clear_start:pixels.proto.RowGroupIndex)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.columnchunkindexentries_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RowGroupIndex::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .pixels.proto.ColumnChunkIndex columnChunkIndexEntries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_columnchunkindexentries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RowGroupIndex::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pixels.proto.RowGroupIndex)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .pixels.proto.ColumnChunkIndex columnChunkIndexEntries = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_columnchunkindexentries_size()); i < n; i++) {
    const auto& repfield = this->_internal_columnchunkindexentries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pixels.proto.RowGroupIndex)
  return target;
}

size_t RowGroupIndex::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pixels.proto.RowGroupIndex)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pixels.proto.ColumnChunkIndex columnChunkIndexEntries = 1;
  total_size += 1UL * this->_internal_columnchunkindexentries_size();
  for (const auto& msg : this->_impl_.columnchunkindexentries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RowGroupIndex::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RowGroupIndex::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RowGroupIndex::GetClassData() const { return &_class_data_; }


void RowGroupIndex::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RowGroupIndex*>(&to_msg);
  auto& from = static_cast<const RowGroupIndex&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pixels.proto.RowGroupIndex)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.columnchunkindexentries_.MergeFrom(from._impl_.columnchunkindexentries_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RowGroupIndex::CopyFrom(const RowGroupIndex& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pixels.proto.RowGroupIndex)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RowGroupIndex::IsInitialized() const {
  return true;
}

void RowGroupIndex::InternalSwap(RowGroupIndex* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.columnchunkindexentries_.InternalSwap(&other->_impl_.columnchunkindexentries_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RowGroupIndex::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pixels_2eproto_getter, &descriptor_table_pixels_2eproto_once,
      file_level_metadata_pixels_2eproto[19]);
}

// ===================================================================

class RowGroupEncoding::_Internal {
 public:
};

RowGroupEncoding::RowGroupEncoding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pixels.proto.RowGroupEncoding)
}
RowGroupEncoding::RowGroupEncoding(const RowGroupEncoding& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RowGroupEncoding* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.columnchunkencodings_){from._impl_.columnchunkencodings_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pixels.proto.RowGroupEncoding)
}

inline void RowGroupEncoding::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.columnchunkencodings_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RowGroupEncoding::~RowGroupEncoding() {
  // @@protoc_insertion_point(destructor:pixels.proto.RowGroupEncoding)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RowGroupEncoding::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.columnchunkencodings_.~RepeatedPtrField();
}

void RowGroupEncoding::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RowGroupEncoding::Clear() {
// @@protoc_insertion_point(message_clear_start:pixels.proto.RowGroupEncoding)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.columnchunkencodings_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RowGroupEncoding::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .pixels.proto.ColumnEncoding columnChunkEncodings = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_columnchunkencodings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RowGroupEncoding::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pixels.proto.RowGroupEncoding)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .pixels.proto.ColumnEncoding columnChunkEncodings = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_columnchunkencodings_size()); i < n; i++) {
    const auto& repfield = this->_internal_columnchunkencodings(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pixels.proto.RowGroupEncoding)
  return target;
}

size_t RowGroupEncoding::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pixels.proto.RowGroupEncoding)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pixels.proto.ColumnEncoding columnChunkEncodings = 1;
  total_size += 1UL * this->_internal_columnchunkencodings_size();
  for (const auto& msg : this->_impl_.columnchunkencodings_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RowGroupEncoding::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RowGroupEncoding::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RowGroupEncoding::GetClassData() const { return &_class_data_; }


void RowGroupEncoding::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RowGroupEncoding*>(&to_msg);
  auto& from = static_cast<const RowGroupEncoding&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pixels.proto.RowGroupEncoding)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.columnchunkencodings_.MergeFrom(from._impl_.columnchunkencodings_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RowGroupEncoding::CopyFrom(const RowGroupEncoding& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pixels.proto.RowGroupEncoding)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RowGroupEncoding::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.columnchunkencodings_))
    return false;
  return true;
}

void RowGroupEncoding::InternalSwap(RowGroupEncoding* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.columnchunkencodings_.InternalSwap(&other->_impl_.columnchunkencodings_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RowGroupEncoding::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pixels_2eproto_getter, &descriptor_table_pixels_2eproto_once,
      file_level_metadata_pixels_2eproto[20]);
}

// ===================================================================

class RowGroupFooter::_Internal {
 public:
  using HasBits = decltype(std::declval<RowGroupFooter>()._impl_._has_bits_);
  static const ::pixels::proto::RowGroupIndex& rowgroupindexentry(const RowGroupFooter* msg);
  static void set_has_rowgroupindexentry(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::pixels::proto::RowGroupEncoding& rowgroupencoding(const RowGroupFooter* msg);
  static void set_has_rowgroupencoding(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::pixels::proto::RowGroupIndex&
RowGroupFooter::_Internal::rowgroupindexentry(const RowGroupFooter* msg) {
  return *msg->_impl_.rowgroupindexentry_;
}
const ::pixels::proto::RowGroupEncoding&
RowGroupFooter::_Internal::rowgroupencoding(const RowGroupFooter* msg) {
  return *msg->_impl_.rowgroupencoding_;
}
RowGroupFooter::RowGroupFooter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pixels.proto.RowGroupFooter)
}
RowGroupFooter::RowGroupFooter(const RowGroupFooter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RowGroupFooter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rowgroupindexentry_){nullptr}
    , decltype(_impl_.rowgroupencoding_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_rowgroupindexentry()) {
    _this->_impl_.rowgroupindexentry_ = new ::pixels::proto::RowGroupIndex(*from._impl_.rowgroupindexentry_);
  }
  if (from._internal_has_rowgroupencoding()) {
    _this->_impl_.rowgroupencoding_ = new ::pixels::proto::RowGroupEncoding(*from._impl_.rowgroupencoding_);
  }
  // @@protoc_insertion_point(copy_constructor:pixels.proto.RowGroupFooter)
}

inline void RowGroupFooter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.rowgroupindexentry_){nullptr}
    , decltype(_impl_.rowgroupencoding_){nullptr}
  };
}

RowGroupFooter::~RowGroupFooter() {
  // @@protoc_insertion_point(destructor:pixels.proto.RowGroupFooter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RowGroupFooter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.rowgroupindexentry_;
  if (this != internal_default_instance()) delete _impl_.rowgroupencoding_;
}

void RowGroupFooter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RowGroupFooter::Clear() {
// @@protoc_insertion_point(message_clear_start:pixels.proto.RowGroupFooter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.rowgroupindexentry_ != nullptr);
      _impl_.rowgroupindexentry_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.rowgroupencoding_ != nullptr);
      _impl_.rowgroupencoding_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RowGroupFooter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .pixels.proto.RowGroupIndex rowGroupIndexEntry = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_rowgroupindexentry(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .pixels.proto.RowGroupEncoding rowGroupEncoding = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_rowgroupencoding(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RowGroupFooter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pixels.proto.RowGroupFooter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .pixels.proto.RowGroupIndex rowGroupIndexEntry = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::rowgroupindexentry(this),
        _Internal::rowgroupindexentry(this).GetCachedSize(), target, stream);
  }

  // optional .pixels.proto.RowGroupEncoding rowGroupEncoding = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::rowgroupencoding(this),
        _Internal::rowgroupencoding(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pixels.proto.RowGroupFooter)
  return target;
}

size_t RowGroupFooter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pixels.proto.RowGroupFooter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .pixels.proto.RowGroupIndex rowGroupIndexEntry = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rowgroupindexentry_);
    }

    // optional .pixels.proto.RowGroupEncoding rowGroupEncoding = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.rowgroupencoding_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RowGroupFooter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RowGroupFooter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RowGroupFooter::GetClassData() const { return &_class_data_; }


void RowGroupFooter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RowGroupFooter*>(&to_msg);
  auto& from = static_cast<const RowGroupFooter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pixels.proto.RowGroupFooter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_rowgroupindexentry()->::pixels::proto::RowGroupIndex::MergeFrom(
          from._internal_rowgroupindexentry());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_rowgroupencoding()->::pixels::proto::RowGroupEncoding::MergeFrom(
          from._internal_rowgroupencoding());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RowGroupFooter::CopyFrom(const RowGroupFooter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pixels.proto.RowGroupFooter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RowGroupFooter::IsInitialized() const {
  if (_internal_has_rowgroupencoding()) {
    if (!_impl_.rowgroupencoding_->IsInitialized()) return false;
  }
  return true;
}

void RowGroupFooter::InternalSwap(RowGroupFooter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RowGroupFooter, _impl_.rowgroupencoding_)
      + sizeof(RowGroupFooter::_impl_.rowgroupencoding_)
      - PROTOBUF_FIELD_OFFSET(RowGroupFooter, _impl_.rowgroupindexentry_)>(
          reinterpret_cast<char*>(&_impl_.rowgroupindexentry_),
          reinterpret_cast<char*>(&other->_impl_.rowgroupindexentry_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RowGroupFooter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pixels_2eproto_getter, &descriptor_table_pixels_2eproto_once,
      file_level_metadata_pixels_2eproto[21]);
}

// ===================================================================

class ColumnEncoding::_Internal {
 public:
  using HasBits = decltype(std::declval<ColumnEncoding>()._impl_._has_bits_);
  static void set_has_kind(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_dictionarysize(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::pixels::proto::ColumnEncoding& cascadeencoding(const ColumnEncoding* msg);
  static void set_has_cascadeencoding(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

const ::pixels::proto::ColumnEncoding&
ColumnEncoding::_Internal::cascadeencoding(const ColumnEncoding* msg) {
  return *msg->_impl_.cascadeencoding_;
}
ColumnEncoding::ColumnEncoding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pixels.proto.ColumnEncoding)
}
ColumnEncoding::ColumnEncoding(const ColumnEncoding& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ColumnEncoding* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cascadeencoding_){nullptr}
    , decltype(_impl_.kind_){}
    , decltype(_impl_.dictionarysize_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_cascadeencoding()) {
    _this->_impl_.cascadeencoding_ = new ::pixels::proto::ColumnEncoding(*from._impl_.cascadeencoding_);
  }
  ::memcpy(&_impl_.kind_, &from._impl_.kind_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.dictionarysize_) -
    reinterpret_cast<char*>(&_impl_.kind_)) + sizeof(_impl_.dictionarysize_));
  // @@protoc_insertion_point(copy_constructor:pixels.proto.ColumnEncoding)
}

inline void ColumnEncoding::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cascadeencoding_){nullptr}
    , decltype(_impl_.kind_){0}
    , decltype(_impl_.dictionarysize_){0u}
  };
}

ColumnEncoding::~ColumnEncoding() {
  // @@protoc_insertion_point(destructor:pixels.proto.ColumnEncoding)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ColumnEncoding::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.cascadeencoding_;
}

void ColumnEncoding::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ColumnEncoding::Clear() {
// @@protoc_insertion_point(message_clear_start:pixels.proto.ColumnEncoding)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.cascadeencoding_ != nullptr);
    _impl_.cascadeencoding_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.kind_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.dictionarysize_) -
        reinterpret_cast<char*>(&_impl_.kind_)) + sizeof(_impl_.dictionarysize_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ColumnEncoding::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .pixels.proto.ColumnEncoding.Kind kind = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pixels::proto::ColumnEncoding_Kind_IsValid(val))) {
            _internal_set_kind(static_cast<::pixels::proto::ColumnEncoding_Kind>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 dictionarySize = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_dictionarysize(&has_bits);
          _impl_.dictionarysize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .pixels.proto.ColumnEncoding cascadeEncoding = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_cascadeencoding(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ColumnEncoding::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pixels.proto.ColumnEncoding)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .pixels.proto.ColumnEncoding.Kind kind = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_kind(), target);
  }

  // optional uint32 dictionarySize = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_dictionarysize(), target);
  }

  // optional .pixels.proto.ColumnEncoding cascadeEncoding = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::cascadeencoding(this),
        _Internal::cascadeencoding(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pixels.proto.ColumnEncoding)
  return target;
}

size_t ColumnEncoding::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pixels.proto.ColumnEncoding)
  size_t total_size = 0;

  // required .pixels.proto.ColumnEncoding.Kind kind = 1;
  if (_internal_has_kind()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_kind());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .pixels.proto.ColumnEncoding cascadeEncoding = 3;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.cascadeencoding_);
  }

  // optional uint32 dictionarySize = 2;
  if (cached_has_bits & 0x00000004u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_dictionarysize());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ColumnEncoding::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ColumnEncoding::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ColumnEncoding::GetClassData() const { return &_class_data_; }


void ColumnEncoding::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ColumnEncoding*>(&to_msg);
  auto& from = static_cast<const ColumnEncoding&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pixels.proto.ColumnEncoding)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_cascadeencoding()->::pixels::proto::ColumnEncoding::MergeFrom(
          from._internal_cascadeencoding());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.kind_ = from._impl_.kind_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.dictionarysize_ = from._impl_.dictionarysize_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ColumnEncoding::CopyFrom(const ColumnEncoding& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pixels.proto.ColumnEncoding)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ColumnEncoding::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (_internal_has_cascadeencoding()) {
    if (!_impl_.cascadeencoding_->IsInitialized()) return false;
  }
  return true;
}

void ColumnEncoding::InternalSwap(ColumnEncoding* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ColumnEncoding, _impl_.dictionarysize_)
      + sizeof(ColumnEncoding::_impl_.dictionarysize_)
      - PROTOBUF_FIELD_OFFSET(ColumnEncoding, _impl_.cascadeencoding_)>(
          reinterpret_cast<char*>(&_impl_.cascadeencoding_),
          reinterpret_cast<char*>(&other->_impl_.cascadeencoding_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ColumnEncoding::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_pixels_2eproto_getter, &descriptor_table_pixels_2eproto_once,
      file_level_metadata_pixels_2eproto[22]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace pixels
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::pixels::proto::FileTail*
Arena::CreateMaybeMessage< ::pixels::proto::FileTail >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pixels::proto::FileTail >(arena);
}
template<> PROTOBUF_NOINLINE ::pixels::proto::PostScript*
Arena::CreateMaybeMessage< ::pixels::proto::PostScript >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pixels::proto::PostScript >(arena);
}
template<> PROTOBUF_NOINLINE ::pixels::proto::Footer*
Arena::CreateMaybeMessage< ::pixels::proto::Footer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pixels::proto::Footer >(arena);
}
template<> PROTOBUF_NOINLINE ::pixels::proto::Type*
Arena::CreateMaybeMessage< ::pixels::proto::Type >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pixels::proto::Type >(arena);
}
template<> PROTOBUF_NOINLINE ::pixels::proto::PartitionInformation*
Arena::CreateMaybeMessage< ::pixels::proto::PartitionInformation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pixels::proto::PartitionInformation >(arena);
}
template<> PROTOBUF_NOINLINE ::pixels::proto::RowGroupInformation*
Arena::CreateMaybeMessage< ::pixels::proto::RowGroupInformation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pixels::proto::RowGroupInformation >(arena);
}
template<> PROTOBUF_NOINLINE ::pixels::proto::RowGroupStatistic*
Arena::CreateMaybeMessage< ::pixels::proto::RowGroupStatistic >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pixels::proto::RowGroupStatistic >(arena);
}
template<> PROTOBUF_NOINLINE ::pixels::proto::IntegerStatistic*
Arena::CreateMaybeMessage< ::pixels::proto::IntegerStatistic >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pixels::proto::IntegerStatistic >(arena);
}
template<> PROTOBUF_NOINLINE ::pixels::proto::Integer128Statistic*
Arena::CreateMaybeMessage< ::pixels::proto::Integer128Statistic >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pixels::proto::Integer128Statistic >(arena);
}
template<> PROTOBUF_NOINLINE ::pixels::proto::DoubleStatistic*
Arena::CreateMaybeMessage< ::pixels::proto::DoubleStatistic >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pixels::proto::DoubleStatistic >(arena);
}
template<> PROTOBUF_NOINLINE ::pixels::proto::StringStatistic*
Arena::CreateMaybeMessage< ::pixels::proto::StringStatistic >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pixels::proto::StringStatistic >(arena);
}
template<> PROTOBUF_NOINLINE ::pixels::proto::BucketStatistic*
Arena::CreateMaybeMessage< ::pixels::proto::BucketStatistic >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pixels::proto::BucketStatistic >(arena);
}
template<> PROTOBUF_NOINLINE ::pixels::proto::TimestampStatistic*
Arena::CreateMaybeMessage< ::pixels::proto::TimestampStatistic >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pixels::proto::TimestampStatistic >(arena);
}
template<> PROTOBUF_NOINLINE ::pixels::proto::DateStatistic*
Arena::CreateMaybeMessage< ::pixels::proto::DateStatistic >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pixels::proto::DateStatistic >(arena);
}
template<> PROTOBUF_NOINLINE ::pixels::proto::TimeStatistic*
Arena::CreateMaybeMessage< ::pixels::proto::TimeStatistic >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pixels::proto::TimeStatistic >(arena);
}
template<> PROTOBUF_NOINLINE ::pixels::proto::BinaryStatistic*
Arena::CreateMaybeMessage< ::pixels::proto::BinaryStatistic >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pixels::proto::BinaryStatistic >(arena);
}
template<> PROTOBUF_NOINLINE ::pixels::proto::ColumnStatistic*
Arena::CreateMaybeMessage< ::pixels::proto::ColumnStatistic >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pixels::proto::ColumnStatistic >(arena);
}
template<> PROTOBUF_NOINLINE ::pixels::proto::PixelStatistic*
Arena::CreateMaybeMessage< ::pixels::proto::PixelStatistic >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pixels::proto::PixelStatistic >(arena);
}
template<> PROTOBUF_NOINLINE ::pixels::proto::ColumnChunkIndex*
Arena::CreateMaybeMessage< ::pixels::proto::ColumnChunkIndex >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pixels::proto::ColumnChunkIndex >(arena);
}
template<> PROTOBUF_NOINLINE ::pixels::proto::RowGroupIndex*
Arena::CreateMaybeMessage< ::pixels::proto::RowGroupIndex >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pixels::proto::RowGroupIndex >(arena);
}
template<> PROTOBUF_NOINLINE ::pixels::proto::RowGroupEncoding*
Arena::CreateMaybeMessage< ::pixels::proto::RowGroupEncoding >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pixels::proto::RowGroupEncoding >(arena);
}
template<> PROTOBUF_NOINLINE ::pixels::proto::RowGroupFooter*
Arena::CreateMaybeMessage< ::pixels::proto::RowGroupFooter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pixels::proto::RowGroupFooter >(arena);
}
template<> PROTOBUF_NOINLINE ::pixels::proto::ColumnEncoding*
Arena::CreateMaybeMessage< ::pixels::proto::ColumnEncoding >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pixels::proto::ColumnEncoding >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
