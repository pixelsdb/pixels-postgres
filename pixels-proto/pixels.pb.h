// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pixels.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_pixels_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_pixels_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_pixels_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_pixels_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_pixels_2eproto;
namespace pixels {
namespace proto {
class BinaryStatistic;
struct BinaryStatisticDefaultTypeInternal;
extern BinaryStatisticDefaultTypeInternal _BinaryStatistic_default_instance_;
class BucketStatistic;
struct BucketStatisticDefaultTypeInternal;
extern BucketStatisticDefaultTypeInternal _BucketStatistic_default_instance_;
class ColumnChunkIndex;
struct ColumnChunkIndexDefaultTypeInternal;
extern ColumnChunkIndexDefaultTypeInternal _ColumnChunkIndex_default_instance_;
class ColumnEncoding;
struct ColumnEncodingDefaultTypeInternal;
extern ColumnEncodingDefaultTypeInternal _ColumnEncoding_default_instance_;
class ColumnStatistic;
struct ColumnStatisticDefaultTypeInternal;
extern ColumnStatisticDefaultTypeInternal _ColumnStatistic_default_instance_;
class DateStatistic;
struct DateStatisticDefaultTypeInternal;
extern DateStatisticDefaultTypeInternal _DateStatistic_default_instance_;
class DoubleStatistic;
struct DoubleStatisticDefaultTypeInternal;
extern DoubleStatisticDefaultTypeInternal _DoubleStatistic_default_instance_;
class FileTail;
struct FileTailDefaultTypeInternal;
extern FileTailDefaultTypeInternal _FileTail_default_instance_;
class Footer;
struct FooterDefaultTypeInternal;
extern FooterDefaultTypeInternal _Footer_default_instance_;
class Integer128Statistic;
struct Integer128StatisticDefaultTypeInternal;
extern Integer128StatisticDefaultTypeInternal _Integer128Statistic_default_instance_;
class IntegerStatistic;
struct IntegerStatisticDefaultTypeInternal;
extern IntegerStatisticDefaultTypeInternal _IntegerStatistic_default_instance_;
class PartitionInformation;
struct PartitionInformationDefaultTypeInternal;
extern PartitionInformationDefaultTypeInternal _PartitionInformation_default_instance_;
class PixelStatistic;
struct PixelStatisticDefaultTypeInternal;
extern PixelStatisticDefaultTypeInternal _PixelStatistic_default_instance_;
class PostScript;
struct PostScriptDefaultTypeInternal;
extern PostScriptDefaultTypeInternal _PostScript_default_instance_;
class RowGroupEncoding;
struct RowGroupEncodingDefaultTypeInternal;
extern RowGroupEncodingDefaultTypeInternal _RowGroupEncoding_default_instance_;
class RowGroupFooter;
struct RowGroupFooterDefaultTypeInternal;
extern RowGroupFooterDefaultTypeInternal _RowGroupFooter_default_instance_;
class RowGroupIndex;
struct RowGroupIndexDefaultTypeInternal;
extern RowGroupIndexDefaultTypeInternal _RowGroupIndex_default_instance_;
class RowGroupInformation;
struct RowGroupInformationDefaultTypeInternal;
extern RowGroupInformationDefaultTypeInternal _RowGroupInformation_default_instance_;
class RowGroupStatistic;
struct RowGroupStatisticDefaultTypeInternal;
extern RowGroupStatisticDefaultTypeInternal _RowGroupStatistic_default_instance_;
class StringStatistic;
struct StringStatisticDefaultTypeInternal;
extern StringStatisticDefaultTypeInternal _StringStatistic_default_instance_;
class TimeStatistic;
struct TimeStatisticDefaultTypeInternal;
extern TimeStatisticDefaultTypeInternal _TimeStatistic_default_instance_;
class TimestampStatistic;
struct TimestampStatisticDefaultTypeInternal;
extern TimestampStatisticDefaultTypeInternal _TimestampStatistic_default_instance_;
class Type;
struct TypeDefaultTypeInternal;
extern TypeDefaultTypeInternal _Type_default_instance_;
}  // namespace proto
}  // namespace pixels
PROTOBUF_NAMESPACE_OPEN
template<> ::pixels::proto::BinaryStatistic* Arena::CreateMaybeMessage<::pixels::proto::BinaryStatistic>(Arena*);
template<> ::pixels::proto::BucketStatistic* Arena::CreateMaybeMessage<::pixels::proto::BucketStatistic>(Arena*);
template<> ::pixels::proto::ColumnChunkIndex* Arena::CreateMaybeMessage<::pixels::proto::ColumnChunkIndex>(Arena*);
template<> ::pixels::proto::ColumnEncoding* Arena::CreateMaybeMessage<::pixels::proto::ColumnEncoding>(Arena*);
template<> ::pixels::proto::ColumnStatistic* Arena::CreateMaybeMessage<::pixels::proto::ColumnStatistic>(Arena*);
template<> ::pixels::proto::DateStatistic* Arena::CreateMaybeMessage<::pixels::proto::DateStatistic>(Arena*);
template<> ::pixels::proto::DoubleStatistic* Arena::CreateMaybeMessage<::pixels::proto::DoubleStatistic>(Arena*);
template<> ::pixels::proto::FileTail* Arena::CreateMaybeMessage<::pixels::proto::FileTail>(Arena*);
template<> ::pixels::proto::Footer* Arena::CreateMaybeMessage<::pixels::proto::Footer>(Arena*);
template<> ::pixels::proto::Integer128Statistic* Arena::CreateMaybeMessage<::pixels::proto::Integer128Statistic>(Arena*);
template<> ::pixels::proto::IntegerStatistic* Arena::CreateMaybeMessage<::pixels::proto::IntegerStatistic>(Arena*);
template<> ::pixels::proto::PartitionInformation* Arena::CreateMaybeMessage<::pixels::proto::PartitionInformation>(Arena*);
template<> ::pixels::proto::PixelStatistic* Arena::CreateMaybeMessage<::pixels::proto::PixelStatistic>(Arena*);
template<> ::pixels::proto::PostScript* Arena::CreateMaybeMessage<::pixels::proto::PostScript>(Arena*);
template<> ::pixels::proto::RowGroupEncoding* Arena::CreateMaybeMessage<::pixels::proto::RowGroupEncoding>(Arena*);
template<> ::pixels::proto::RowGroupFooter* Arena::CreateMaybeMessage<::pixels::proto::RowGroupFooter>(Arena*);
template<> ::pixels::proto::RowGroupIndex* Arena::CreateMaybeMessage<::pixels::proto::RowGroupIndex>(Arena*);
template<> ::pixels::proto::RowGroupInformation* Arena::CreateMaybeMessage<::pixels::proto::RowGroupInformation>(Arena*);
template<> ::pixels::proto::RowGroupStatistic* Arena::CreateMaybeMessage<::pixels::proto::RowGroupStatistic>(Arena*);
template<> ::pixels::proto::StringStatistic* Arena::CreateMaybeMessage<::pixels::proto::StringStatistic>(Arena*);
template<> ::pixels::proto::TimeStatistic* Arena::CreateMaybeMessage<::pixels::proto::TimeStatistic>(Arena*);
template<> ::pixels::proto::TimestampStatistic* Arena::CreateMaybeMessage<::pixels::proto::TimestampStatistic>(Arena*);
template<> ::pixels::proto::Type* Arena::CreateMaybeMessage<::pixels::proto::Type>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pixels {
namespace proto {

enum Type_Kind : int {
  Type_Kind_BOOLEAN = 0,
  Type_Kind_BYTE = 1,
  Type_Kind_SHORT = 2,
  Type_Kind_INT = 3,
  Type_Kind_LONG = 4,
  Type_Kind_FLOAT = 5,
  Type_Kind_DOUBLE = 6,
  Type_Kind_STRING = 7,
  Type_Kind_BINARY = 8,
  Type_Kind_TIMESTAMP = 9,
  Type_Kind_ARRAY = 10,
  Type_Kind_MAP = 11,
  Type_Kind_STRUCT = 12,
  Type_Kind_VARBINARY = 13,
  Type_Kind_DECIMAL = 14,
  Type_Kind_DATE = 15,
  Type_Kind_VARCHAR = 16,
  Type_Kind_CHAR = 17,
  Type_Kind_TIME = 18,
  Type_Kind_VECTOR = 19
};
bool Type_Kind_IsValid(int value);
constexpr Type_Kind Type_Kind_Kind_MIN = Type_Kind_BOOLEAN;
constexpr Type_Kind Type_Kind_Kind_MAX = Type_Kind_VECTOR;
constexpr int Type_Kind_Kind_ARRAYSIZE = Type_Kind_Kind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Type_Kind_descriptor();
template<typename T>
inline const std::string& Type_Kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Type_Kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Type_Kind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Type_Kind_descriptor(), enum_t_value);
}
inline bool Type_Kind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Type_Kind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Type_Kind>(
    Type_Kind_descriptor(), name, value);
}
enum ColumnEncoding_Kind : int {
  ColumnEncoding_Kind_NONE = 0,
  ColumnEncoding_Kind_RUNLENGTH = 1,
  ColumnEncoding_Kind_DICTIONARY = 2
};
bool ColumnEncoding_Kind_IsValid(int value);
constexpr ColumnEncoding_Kind ColumnEncoding_Kind_Kind_MIN = ColumnEncoding_Kind_NONE;
constexpr ColumnEncoding_Kind ColumnEncoding_Kind_Kind_MAX = ColumnEncoding_Kind_DICTIONARY;
constexpr int ColumnEncoding_Kind_Kind_ARRAYSIZE = ColumnEncoding_Kind_Kind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ColumnEncoding_Kind_descriptor();
template<typename T>
inline const std::string& ColumnEncoding_Kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ColumnEncoding_Kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ColumnEncoding_Kind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ColumnEncoding_Kind_descriptor(), enum_t_value);
}
inline bool ColumnEncoding_Kind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ColumnEncoding_Kind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ColumnEncoding_Kind>(
    ColumnEncoding_Kind_descriptor(), name, value);
}
enum CompressionKind : int {
  NONE = 0,
  ZLIB = 1,
  SNAPPY = 2,
  LZO = 3,
  LZ4 = 4,
  ZSTD = 5
};
bool CompressionKind_IsValid(int value);
constexpr CompressionKind CompressionKind_MIN = NONE;
constexpr CompressionKind CompressionKind_MAX = ZSTD;
constexpr int CompressionKind_ARRAYSIZE = CompressionKind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CompressionKind_descriptor();
template<typename T>
inline const std::string& CompressionKind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CompressionKind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CompressionKind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CompressionKind_descriptor(), enum_t_value);
}
inline bool CompressionKind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CompressionKind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CompressionKind>(
    CompressionKind_descriptor(), name, value);
}
// ===================================================================

class FileTail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pixels.proto.FileTail) */ {
 public:
  inline FileTail() : FileTail(nullptr) {}
  ~FileTail() override;
  explicit PROTOBUF_CONSTEXPR FileTail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileTail(const FileTail& from);
  FileTail(FileTail&& from) noexcept
    : FileTail() {
    *this = ::std::move(from);
  }

  inline FileTail& operator=(const FileTail& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileTail& operator=(FileTail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileTail& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileTail* internal_default_instance() {
    return reinterpret_cast<const FileTail*>(
               &_FileTail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FileTail& a, FileTail& b) {
    a.Swap(&b);
  }
  inline void Swap(FileTail* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileTail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileTail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileTail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileTail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileTail& from) {
    FileTail::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTail* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pixels.proto.FileTail";
  }
  protected:
  explicit FileTail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFooterFieldNumber = 1,
    kPostscriptFieldNumber = 2,
    kFooterLengthFieldNumber = 3,
    kPostscriptLengthFieldNumber = 4,
  };
  // optional .pixels.proto.Footer footer = 1;
  bool has_footer() const;
  private:
  bool _internal_has_footer() const;
  public:
  void clear_footer();
  const ::pixels::proto::Footer& footer() const;
  PROTOBUF_NODISCARD ::pixels::proto::Footer* release_footer();
  ::pixels::proto::Footer* mutable_footer();
  void set_allocated_footer(::pixels::proto::Footer* footer);
  private:
  const ::pixels::proto::Footer& _internal_footer() const;
  ::pixels::proto::Footer* _internal_mutable_footer();
  public:
  void unsafe_arena_set_allocated_footer(
      ::pixels::proto::Footer* footer);
  ::pixels::proto::Footer* unsafe_arena_release_footer();

  // optional .pixels.proto.PostScript postscript = 2;
  bool has_postscript() const;
  private:
  bool _internal_has_postscript() const;
  public:
  void clear_postscript();
  const ::pixels::proto::PostScript& postscript() const;
  PROTOBUF_NODISCARD ::pixels::proto::PostScript* release_postscript();
  ::pixels::proto::PostScript* mutable_postscript();
  void set_allocated_postscript(::pixels::proto::PostScript* postscript);
  private:
  const ::pixels::proto::PostScript& _internal_postscript() const;
  ::pixels::proto::PostScript* _internal_mutable_postscript();
  public:
  void unsafe_arena_set_allocated_postscript(
      ::pixels::proto::PostScript* postscript);
  ::pixels::proto::PostScript* unsafe_arena_release_postscript();

  // optional uint32 footerLength = 3;
  bool has_footerlength() const;
  private:
  bool _internal_has_footerlength() const;
  public:
  void clear_footerlength();
  uint32_t footerlength() const;
  void set_footerlength(uint32_t value);
  private:
  uint32_t _internal_footerlength() const;
  void _internal_set_footerlength(uint32_t value);
  public:

  // optional uint32 postscriptLength = 4;
  bool has_postscriptlength() const;
  private:
  bool _internal_has_postscriptlength() const;
  public:
  void clear_postscriptlength();
  uint32_t postscriptlength() const;
  void set_postscriptlength(uint32_t value);
  private:
  uint32_t _internal_postscriptlength() const;
  void _internal_set_postscriptlength(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pixels.proto.FileTail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::pixels::proto::Footer* footer_;
    ::pixels::proto::PostScript* postscript_;
    uint32_t footerlength_;
    uint32_t postscriptlength_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pixels_2eproto;
};
// -------------------------------------------------------------------

class PostScript final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pixels.proto.PostScript) */ {
 public:
  inline PostScript() : PostScript(nullptr) {}
  ~PostScript() override;
  explicit PROTOBUF_CONSTEXPR PostScript(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PostScript(const PostScript& from);
  PostScript(PostScript&& from) noexcept
    : PostScript() {
    *this = ::std::move(from);
  }

  inline PostScript& operator=(const PostScript& from) {
    CopyFrom(from);
    return *this;
  }
  inline PostScript& operator=(PostScript&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PostScript& default_instance() {
    return *internal_default_instance();
  }
  static inline const PostScript* internal_default_instance() {
    return reinterpret_cast<const PostScript*>(
               &_PostScript_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PostScript& a, PostScript& b) {
    a.Swap(&b);
  }
  inline void Swap(PostScript* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PostScript* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PostScript* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PostScript>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PostScript& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PostScript& from) {
    PostScript::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PostScript* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pixels.proto.PostScript";
  }
  protected:
  explicit PostScript(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWriterTimezoneFieldNumber = 7,
    kMagicFieldNumber = 8000,
    kContentLengthFieldNumber = 2,
    kVersionFieldNumber = 1,
    kNumberOfRowsFieldNumber = 3,
    kCompressionFieldNumber = 4,
    kCompressionBlockSizeFieldNumber = 5,
    kPixelStrideFieldNumber = 6,
    kPartitionedFieldNumber = 8,
    kColumnChunkAlignmentFieldNumber = 9,
  };
  // optional string writerTimezone = 7;
  bool has_writertimezone() const;
  private:
  bool _internal_has_writertimezone() const;
  public:
  void clear_writertimezone();
  const std::string& writertimezone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_writertimezone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_writertimezone();
  PROTOBUF_NODISCARD std::string* release_writertimezone();
  void set_allocated_writertimezone(std::string* writertimezone);
  private:
  const std::string& _internal_writertimezone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_writertimezone(const std::string& value);
  std::string* _internal_mutable_writertimezone();
  public:

  // optional string magic = 8000;
  bool has_magic() const;
  private:
  bool _internal_has_magic() const;
  public:
  void clear_magic();
  const std::string& magic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_magic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_magic();
  PROTOBUF_NODISCARD std::string* release_magic();
  void set_allocated_magic(std::string* magic);
  private:
  const std::string& _internal_magic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_magic(const std::string& value);
  std::string* _internal_mutable_magic();
  public:

  // optional uint64 contentLength = 2;
  bool has_contentlength() const;
  private:
  bool _internal_has_contentlength() const;
  public:
  void clear_contentlength();
  uint64_t contentlength() const;
  void set_contentlength(uint64_t value);
  private:
  uint64_t _internal_contentlength() const;
  void _internal_set_contentlength(uint64_t value);
  public:

  // optional uint32 version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  uint32_t version() const;
  void set_version(uint32_t value);
  private:
  uint32_t _internal_version() const;
  void _internal_set_version(uint32_t value);
  public:

  // optional uint32 numberOfRows = 3;
  bool has_numberofrows() const;
  private:
  bool _internal_has_numberofrows() const;
  public:
  void clear_numberofrows();
  uint32_t numberofrows() const;
  void set_numberofrows(uint32_t value);
  private:
  uint32_t _internal_numberofrows() const;
  void _internal_set_numberofrows(uint32_t value);
  public:

  // optional .pixels.proto.CompressionKind compression = 4;
  bool has_compression() const;
  private:
  bool _internal_has_compression() const;
  public:
  void clear_compression();
  ::pixels::proto::CompressionKind compression() const;
  void set_compression(::pixels::proto::CompressionKind value);
  private:
  ::pixels::proto::CompressionKind _internal_compression() const;
  void _internal_set_compression(::pixels::proto::CompressionKind value);
  public:

  // optional uint32 compressionBlockSize = 5;
  bool has_compressionblocksize() const;
  private:
  bool _internal_has_compressionblocksize() const;
  public:
  void clear_compressionblocksize();
  uint32_t compressionblocksize() const;
  void set_compressionblocksize(uint32_t value);
  private:
  uint32_t _internal_compressionblocksize() const;
  void _internal_set_compressionblocksize(uint32_t value);
  public:

  // optional uint32 pixelStride = 6;
  bool has_pixelstride() const;
  private:
  bool _internal_has_pixelstride() const;
  public:
  void clear_pixelstride();
  uint32_t pixelstride() const;
  void set_pixelstride(uint32_t value);
  private:
  uint32_t _internal_pixelstride() const;
  void _internal_set_pixelstride(uint32_t value);
  public:

  // optional bool partitioned = 8;
  bool has_partitioned() const;
  private:
  bool _internal_has_partitioned() const;
  public:
  void clear_partitioned();
  bool partitioned() const;
  void set_partitioned(bool value);
  private:
  bool _internal_partitioned() const;
  void _internal_set_partitioned(bool value);
  public:

  // optional uint32 columnChunkAlignment = 9;
  bool has_columnchunkalignment() const;
  private:
  bool _internal_has_columnchunkalignment() const;
  public:
  void clear_columnchunkalignment();
  uint32_t columnchunkalignment() const;
  void set_columnchunkalignment(uint32_t value);
  private:
  uint32_t _internal_columnchunkalignment() const;
  void _internal_set_columnchunkalignment(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pixels.proto.PostScript)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr writertimezone_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr magic_;
    uint64_t contentlength_;
    uint32_t version_;
    uint32_t numberofrows_;
    int compression_;
    uint32_t compressionblocksize_;
    uint32_t pixelstride_;
    bool partitioned_;
    uint32_t columnchunkalignment_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pixels_2eproto;
};
// -------------------------------------------------------------------

class Footer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pixels.proto.Footer) */ {
 public:
  inline Footer() : Footer(nullptr) {}
  ~Footer() override;
  explicit PROTOBUF_CONSTEXPR Footer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Footer(const Footer& from);
  Footer(Footer&& from) noexcept
    : Footer() {
    *this = ::std::move(from);
  }

  inline Footer& operator=(const Footer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Footer& operator=(Footer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Footer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Footer* internal_default_instance() {
    return reinterpret_cast<const Footer*>(
               &_Footer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Footer& a, Footer& b) {
    a.Swap(&b);
  }
  inline void Swap(Footer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Footer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Footer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Footer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Footer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Footer& from) {
    Footer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Footer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pixels.proto.Footer";
  }
  protected:
  explicit Footer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypesFieldNumber = 1,
    kColumnStatsFieldNumber = 2,
    kRowGroupInfosFieldNumber = 3,
    kRowGroupStatsFieldNumber = 4,
  };
  // repeated .pixels.proto.Type types = 1;
  int types_size() const;
  private:
  int _internal_types_size() const;
  public:
  void clear_types();
  ::pixels::proto::Type* mutable_types(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::Type >*
      mutable_types();
  private:
  const ::pixels::proto::Type& _internal_types(int index) const;
  ::pixels::proto::Type* _internal_add_types();
  public:
  const ::pixels::proto::Type& types(int index) const;
  ::pixels::proto::Type* add_types();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::Type >&
      types() const;

  // repeated .pixels.proto.ColumnStatistic columnStats = 2;
  int columnstats_size() const;
  private:
  int _internal_columnstats_size() const;
  public:
  void clear_columnstats();
  ::pixels::proto::ColumnStatistic* mutable_columnstats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::ColumnStatistic >*
      mutable_columnstats();
  private:
  const ::pixels::proto::ColumnStatistic& _internal_columnstats(int index) const;
  ::pixels::proto::ColumnStatistic* _internal_add_columnstats();
  public:
  const ::pixels::proto::ColumnStatistic& columnstats(int index) const;
  ::pixels::proto::ColumnStatistic* add_columnstats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::ColumnStatistic >&
      columnstats() const;

  // repeated .pixels.proto.RowGroupInformation rowGroupInfos = 3;
  int rowgroupinfos_size() const;
  private:
  int _internal_rowgroupinfos_size() const;
  public:
  void clear_rowgroupinfos();
  ::pixels::proto::RowGroupInformation* mutable_rowgroupinfos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::RowGroupInformation >*
      mutable_rowgroupinfos();
  private:
  const ::pixels::proto::RowGroupInformation& _internal_rowgroupinfos(int index) const;
  ::pixels::proto::RowGroupInformation* _internal_add_rowgroupinfos();
  public:
  const ::pixels::proto::RowGroupInformation& rowgroupinfos(int index) const;
  ::pixels::proto::RowGroupInformation* add_rowgroupinfos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::RowGroupInformation >&
      rowgroupinfos() const;

  // repeated .pixels.proto.RowGroupStatistic rowGroupStats = 4;
  int rowgroupstats_size() const;
  private:
  int _internal_rowgroupstats_size() const;
  public:
  void clear_rowgroupstats();
  ::pixels::proto::RowGroupStatistic* mutable_rowgroupstats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::RowGroupStatistic >*
      mutable_rowgroupstats();
  private:
  const ::pixels::proto::RowGroupStatistic& _internal_rowgroupstats(int index) const;
  ::pixels::proto::RowGroupStatistic* _internal_add_rowgroupstats();
  public:
  const ::pixels::proto::RowGroupStatistic& rowgroupstats(int index) const;
  ::pixels::proto::RowGroupStatistic* add_rowgroupstats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::RowGroupStatistic >&
      rowgroupstats() const;

  // @@protoc_insertion_point(class_scope:pixels.proto.Footer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::Type > types_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::ColumnStatistic > columnstats_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::RowGroupInformation > rowgroupinfos_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::RowGroupStatistic > rowgroupstats_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pixels_2eproto;
};
// -------------------------------------------------------------------

class Type final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pixels.proto.Type) */ {
 public:
  inline Type() : Type(nullptr) {}
  ~Type() override;
  explicit PROTOBUF_CONSTEXPR Type(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Type(const Type& from);
  Type(Type&& from) noexcept
    : Type() {
    *this = ::std::move(from);
  }

  inline Type& operator=(const Type& from) {
    CopyFrom(from);
    return *this;
  }
  inline Type& operator=(Type&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Type& default_instance() {
    return *internal_default_instance();
  }
  static inline const Type* internal_default_instance() {
    return reinterpret_cast<const Type*>(
               &_Type_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Type& a, Type& b) {
    a.Swap(&b);
  }
  inline void Swap(Type* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Type* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Type* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Type>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Type& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Type& from) {
    Type::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Type* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pixels.proto.Type";
  }
  protected:
  explicit Type(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Type_Kind Kind;
  static constexpr Kind BOOLEAN =
    Type_Kind_BOOLEAN;
  static constexpr Kind BYTE =
    Type_Kind_BYTE;
  static constexpr Kind SHORT =
    Type_Kind_SHORT;
  static constexpr Kind INT =
    Type_Kind_INT;
  static constexpr Kind LONG =
    Type_Kind_LONG;
  static constexpr Kind FLOAT =
    Type_Kind_FLOAT;
  static constexpr Kind DOUBLE =
    Type_Kind_DOUBLE;
  static constexpr Kind STRING =
    Type_Kind_STRING;
  static constexpr Kind BINARY =
    Type_Kind_BINARY;
  static constexpr Kind TIMESTAMP =
    Type_Kind_TIMESTAMP;
  static constexpr Kind ARRAY =
    Type_Kind_ARRAY;
  static constexpr Kind MAP =
    Type_Kind_MAP;
  static constexpr Kind STRUCT =
    Type_Kind_STRUCT;
  static constexpr Kind VARBINARY =
    Type_Kind_VARBINARY;
  static constexpr Kind DECIMAL =
    Type_Kind_DECIMAL;
  static constexpr Kind DATE =
    Type_Kind_DATE;
  static constexpr Kind VARCHAR =
    Type_Kind_VARCHAR;
  static constexpr Kind CHAR =
    Type_Kind_CHAR;
  static constexpr Kind TIME =
    Type_Kind_TIME;
  static constexpr Kind VECTOR =
    Type_Kind_VECTOR;
  static inline bool Kind_IsValid(int value) {
    return Type_Kind_IsValid(value);
  }
  static constexpr Kind Kind_MIN =
    Type_Kind_Kind_MIN;
  static constexpr Kind Kind_MAX =
    Type_Kind_Kind_MAX;
  static constexpr int Kind_ARRAYSIZE =
    Type_Kind_Kind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Kind_descriptor() {
    return Type_Kind_descriptor();
  }
  template<typename T>
  static inline const std::string& Kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Kind_Name.");
    return Type_Kind_Name(enum_t_value);
  }
  static inline bool Kind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Kind* value) {
    return Type_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSubtypesFieldNumber = 3,
    kNameFieldNumber = 2,
    kKindFieldNumber = 1,
    kMaximumLengthFieldNumber = 4,
    kPrecisionFieldNumber = 5,
    kScaleFieldNumber = 6,
    kDimensionFieldNumber = 7,
  };
  // repeated uint32 subtypes = 3 [packed = true];
  int subtypes_size() const;
  private:
  int _internal_subtypes_size() const;
  public:
  void clear_subtypes();
  private:
  uint32_t _internal_subtypes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_subtypes() const;
  void _internal_add_subtypes(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_subtypes();
  public:
  uint32_t subtypes(int index) const;
  void set_subtypes(int index, uint32_t value);
  void add_subtypes(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      subtypes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_subtypes();

  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .pixels.proto.Type.Kind kind = 1;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  ::pixels::proto::Type_Kind kind() const;
  void set_kind(::pixels::proto::Type_Kind value);
  private:
  ::pixels::proto::Type_Kind _internal_kind() const;
  void _internal_set_kind(::pixels::proto::Type_Kind value);
  public:

  // optional uint32 maximumLength = 4;
  bool has_maximumlength() const;
  private:
  bool _internal_has_maximumlength() const;
  public:
  void clear_maximumlength();
  uint32_t maximumlength() const;
  void set_maximumlength(uint32_t value);
  private:
  uint32_t _internal_maximumlength() const;
  void _internal_set_maximumlength(uint32_t value);
  public:

  // optional uint32 precision = 5;
  bool has_precision() const;
  private:
  bool _internal_has_precision() const;
  public:
  void clear_precision();
  uint32_t precision() const;
  void set_precision(uint32_t value);
  private:
  uint32_t _internal_precision() const;
  void _internal_set_precision(uint32_t value);
  public:

  // optional uint32 scale = 6;
  bool has_scale() const;
  private:
  bool _internal_has_scale() const;
  public:
  void clear_scale();
  uint32_t scale() const;
  void set_scale(uint32_t value);
  private:
  uint32_t _internal_scale() const;
  void _internal_set_scale(uint32_t value);
  public:

  // optional uint32 dimension = 7;
  bool has_dimension() const;
  private:
  bool _internal_has_dimension() const;
  public:
  void clear_dimension();
  uint32_t dimension() const;
  void set_dimension(uint32_t value);
  private:
  uint32_t _internal_dimension() const;
  void _internal_set_dimension(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pixels.proto.Type)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > subtypes_;
    mutable std::atomic<int> _subtypes_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int kind_;
    uint32_t maximumlength_;
    uint32_t precision_;
    uint32_t scale_;
    uint32_t dimension_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pixels_2eproto;
};
// -------------------------------------------------------------------

class PartitionInformation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pixels.proto.PartitionInformation) */ {
 public:
  inline PartitionInformation() : PartitionInformation(nullptr) {}
  ~PartitionInformation() override;
  explicit PROTOBUF_CONSTEXPR PartitionInformation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PartitionInformation(const PartitionInformation& from);
  PartitionInformation(PartitionInformation&& from) noexcept
    : PartitionInformation() {
    *this = ::std::move(from);
  }

  inline PartitionInformation& operator=(const PartitionInformation& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartitionInformation& operator=(PartitionInformation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PartitionInformation& default_instance() {
    return *internal_default_instance();
  }
  static inline const PartitionInformation* internal_default_instance() {
    return reinterpret_cast<const PartitionInformation*>(
               &_PartitionInformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PartitionInformation& a, PartitionInformation& b) {
    a.Swap(&b);
  }
  inline void Swap(PartitionInformation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PartitionInformation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PartitionInformation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PartitionInformation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PartitionInformation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PartitionInformation& from) {
    PartitionInformation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionInformation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pixels.proto.PartitionInformation";
  }
  protected:
  explicit PartitionInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnIdsFieldNumber = 1,
    kHashValueFieldNumber = 2,
  };
  // repeated uint32 columnIds = 1;
  int columnids_size() const;
  private:
  int _internal_columnids_size() const;
  public:
  void clear_columnids();
  private:
  uint32_t _internal_columnids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_columnids() const;
  void _internal_add_columnids(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_columnids();
  public:
  uint32_t columnids(int index) const;
  void set_columnids(int index, uint32_t value);
  void add_columnids(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      columnids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_columnids();

  // optional int32 hashValue = 2;
  bool has_hashvalue() const;
  private:
  bool _internal_has_hashvalue() const;
  public:
  void clear_hashvalue();
  int32_t hashvalue() const;
  void set_hashvalue(int32_t value);
  private:
  int32_t _internal_hashvalue() const;
  void _internal_set_hashvalue(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pixels.proto.PartitionInformation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > columnids_;
    int32_t hashvalue_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pixels_2eproto;
};
// -------------------------------------------------------------------

class RowGroupInformation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pixels.proto.RowGroupInformation) */ {
 public:
  inline RowGroupInformation() : RowGroupInformation(nullptr) {}
  ~RowGroupInformation() override;
  explicit PROTOBUF_CONSTEXPR RowGroupInformation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RowGroupInformation(const RowGroupInformation& from);
  RowGroupInformation(RowGroupInformation&& from) noexcept
    : RowGroupInformation() {
    *this = ::std::move(from);
  }

  inline RowGroupInformation& operator=(const RowGroupInformation& from) {
    CopyFrom(from);
    return *this;
  }
  inline RowGroupInformation& operator=(RowGroupInformation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RowGroupInformation& default_instance() {
    return *internal_default_instance();
  }
  static inline const RowGroupInformation* internal_default_instance() {
    return reinterpret_cast<const RowGroupInformation*>(
               &_RowGroupInformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RowGroupInformation& a, RowGroupInformation& b) {
    a.Swap(&b);
  }
  inline void Swap(RowGroupInformation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RowGroupInformation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RowGroupInformation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RowGroupInformation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RowGroupInformation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RowGroupInformation& from) {
    RowGroupInformation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RowGroupInformation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pixels.proto.RowGroupInformation";
  }
  protected:
  explicit RowGroupInformation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartitionInfoFieldNumber = 5,
    kFooterOffsetFieldNumber = 1,
    kDataLengthFieldNumber = 2,
    kFooterLengthFieldNumber = 3,
    kNumberOfRowsFieldNumber = 4,
  };
  // optional .pixels.proto.PartitionInformation partitionInfo = 5;
  bool has_partitioninfo() const;
  private:
  bool _internal_has_partitioninfo() const;
  public:
  void clear_partitioninfo();
  const ::pixels::proto::PartitionInformation& partitioninfo() const;
  PROTOBUF_NODISCARD ::pixels::proto::PartitionInformation* release_partitioninfo();
  ::pixels::proto::PartitionInformation* mutable_partitioninfo();
  void set_allocated_partitioninfo(::pixels::proto::PartitionInformation* partitioninfo);
  private:
  const ::pixels::proto::PartitionInformation& _internal_partitioninfo() const;
  ::pixels::proto::PartitionInformation* _internal_mutable_partitioninfo();
  public:
  void unsafe_arena_set_allocated_partitioninfo(
      ::pixels::proto::PartitionInformation* partitioninfo);
  ::pixels::proto::PartitionInformation* unsafe_arena_release_partitioninfo();

  // optional uint64 footerOffset = 1;
  bool has_footeroffset() const;
  private:
  bool _internal_has_footeroffset() const;
  public:
  void clear_footeroffset();
  uint64_t footeroffset() const;
  void set_footeroffset(uint64_t value);
  private:
  uint64_t _internal_footeroffset() const;
  void _internal_set_footeroffset(uint64_t value);
  public:

  // optional uint32 dataLength = 2;
  bool has_datalength() const;
  private:
  bool _internal_has_datalength() const;
  public:
  void clear_datalength();
  uint32_t datalength() const;
  void set_datalength(uint32_t value);
  private:
  uint32_t _internal_datalength() const;
  void _internal_set_datalength(uint32_t value);
  public:

  // optional uint32 footerLength = 3;
  bool has_footerlength() const;
  private:
  bool _internal_has_footerlength() const;
  public:
  void clear_footerlength();
  uint32_t footerlength() const;
  void set_footerlength(uint32_t value);
  private:
  uint32_t _internal_footerlength() const;
  void _internal_set_footerlength(uint32_t value);
  public:

  // optional uint64 numberOfRows = 4;
  bool has_numberofrows() const;
  private:
  bool _internal_has_numberofrows() const;
  public:
  void clear_numberofrows();
  uint64_t numberofrows() const;
  void set_numberofrows(uint64_t value);
  private:
  uint64_t _internal_numberofrows() const;
  void _internal_set_numberofrows(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pixels.proto.RowGroupInformation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::pixels::proto::PartitionInformation* partitioninfo_;
    uint64_t footeroffset_;
    uint32_t datalength_;
    uint32_t footerlength_;
    uint64_t numberofrows_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pixels_2eproto;
};
// -------------------------------------------------------------------

class RowGroupStatistic final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pixels.proto.RowGroupStatistic) */ {
 public:
  inline RowGroupStatistic() : RowGroupStatistic(nullptr) {}
  ~RowGroupStatistic() override;
  explicit PROTOBUF_CONSTEXPR RowGroupStatistic(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RowGroupStatistic(const RowGroupStatistic& from);
  RowGroupStatistic(RowGroupStatistic&& from) noexcept
    : RowGroupStatistic() {
    *this = ::std::move(from);
  }

  inline RowGroupStatistic& operator=(const RowGroupStatistic& from) {
    CopyFrom(from);
    return *this;
  }
  inline RowGroupStatistic& operator=(RowGroupStatistic&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RowGroupStatistic& default_instance() {
    return *internal_default_instance();
  }
  static inline const RowGroupStatistic* internal_default_instance() {
    return reinterpret_cast<const RowGroupStatistic*>(
               &_RowGroupStatistic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RowGroupStatistic& a, RowGroupStatistic& b) {
    a.Swap(&b);
  }
  inline void Swap(RowGroupStatistic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RowGroupStatistic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RowGroupStatistic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RowGroupStatistic>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RowGroupStatistic& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RowGroupStatistic& from) {
    RowGroupStatistic::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RowGroupStatistic* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pixels.proto.RowGroupStatistic";
  }
  protected:
  explicit RowGroupStatistic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnChunkStatsFieldNumber = 1,
  };
  // repeated .pixels.proto.ColumnStatistic columnChunkStats = 1;
  int columnchunkstats_size() const;
  private:
  int _internal_columnchunkstats_size() const;
  public:
  void clear_columnchunkstats();
  ::pixels::proto::ColumnStatistic* mutable_columnchunkstats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::ColumnStatistic >*
      mutable_columnchunkstats();
  private:
  const ::pixels::proto::ColumnStatistic& _internal_columnchunkstats(int index) const;
  ::pixels::proto::ColumnStatistic* _internal_add_columnchunkstats();
  public:
  const ::pixels::proto::ColumnStatistic& columnchunkstats(int index) const;
  ::pixels::proto::ColumnStatistic* add_columnchunkstats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::ColumnStatistic >&
      columnchunkstats() const;

  // @@protoc_insertion_point(class_scope:pixels.proto.RowGroupStatistic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::ColumnStatistic > columnchunkstats_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pixels_2eproto;
};
// -------------------------------------------------------------------

class IntegerStatistic final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pixels.proto.IntegerStatistic) */ {
 public:
  inline IntegerStatistic() : IntegerStatistic(nullptr) {}
  ~IntegerStatistic() override;
  explicit PROTOBUF_CONSTEXPR IntegerStatistic(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IntegerStatistic(const IntegerStatistic& from);
  IntegerStatistic(IntegerStatistic&& from) noexcept
    : IntegerStatistic() {
    *this = ::std::move(from);
  }

  inline IntegerStatistic& operator=(const IntegerStatistic& from) {
    CopyFrom(from);
    return *this;
  }
  inline IntegerStatistic& operator=(IntegerStatistic&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IntegerStatistic& default_instance() {
    return *internal_default_instance();
  }
  static inline const IntegerStatistic* internal_default_instance() {
    return reinterpret_cast<const IntegerStatistic*>(
               &_IntegerStatistic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(IntegerStatistic& a, IntegerStatistic& b) {
    a.Swap(&b);
  }
  inline void Swap(IntegerStatistic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IntegerStatistic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IntegerStatistic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IntegerStatistic>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IntegerStatistic& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IntegerStatistic& from) {
    IntegerStatistic::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntegerStatistic* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pixels.proto.IntegerStatistic";
  }
  protected:
  explicit IntegerStatistic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinimumFieldNumber = 1,
    kMaximumFieldNumber = 2,
    kSumFieldNumber = 3,
  };
  // optional sint64 minimum = 1;
  bool has_minimum() const;
  private:
  bool _internal_has_minimum() const;
  public:
  void clear_minimum();
  int64_t minimum() const;
  void set_minimum(int64_t value);
  private:
  int64_t _internal_minimum() const;
  void _internal_set_minimum(int64_t value);
  public:

  // optional sint64 maximum = 2;
  bool has_maximum() const;
  private:
  bool _internal_has_maximum() const;
  public:
  void clear_maximum();
  int64_t maximum() const;
  void set_maximum(int64_t value);
  private:
  int64_t _internal_maximum() const;
  void _internal_set_maximum(int64_t value);
  public:

  // optional sint64 sum = 3;
  bool has_sum() const;
  private:
  bool _internal_has_sum() const;
  public:
  void clear_sum();
  int64_t sum() const;
  void set_sum(int64_t value);
  private:
  int64_t _internal_sum() const;
  void _internal_set_sum(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pixels.proto.IntegerStatistic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t minimum_;
    int64_t maximum_;
    int64_t sum_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pixels_2eproto;
};
// -------------------------------------------------------------------

class Integer128Statistic final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pixels.proto.Integer128Statistic) */ {
 public:
  inline Integer128Statistic() : Integer128Statistic(nullptr) {}
  ~Integer128Statistic() override;
  explicit PROTOBUF_CONSTEXPR Integer128Statistic(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Integer128Statistic(const Integer128Statistic& from);
  Integer128Statistic(Integer128Statistic&& from) noexcept
    : Integer128Statistic() {
    *this = ::std::move(from);
  }

  inline Integer128Statistic& operator=(const Integer128Statistic& from) {
    CopyFrom(from);
    return *this;
  }
  inline Integer128Statistic& operator=(Integer128Statistic&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Integer128Statistic& default_instance() {
    return *internal_default_instance();
  }
  static inline const Integer128Statistic* internal_default_instance() {
    return reinterpret_cast<const Integer128Statistic*>(
               &_Integer128Statistic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Integer128Statistic& a, Integer128Statistic& b) {
    a.Swap(&b);
  }
  inline void Swap(Integer128Statistic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Integer128Statistic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Integer128Statistic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Integer128Statistic>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Integer128Statistic& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Integer128Statistic& from) {
    Integer128Statistic::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Integer128Statistic* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pixels.proto.Integer128Statistic";
  }
  protected:
  explicit Integer128Statistic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinimumHighFieldNumber = 1,
    kMinimumLowFieldNumber = 2,
    kMaximumHighFieldNumber = 3,
    kMaximumLowFieldNumber = 4,
  };
  // optional uint64 minimum_high = 1;
  bool has_minimum_high() const;
  private:
  bool _internal_has_minimum_high() const;
  public:
  void clear_minimum_high();
  uint64_t minimum_high() const;
  void set_minimum_high(uint64_t value);
  private:
  uint64_t _internal_minimum_high() const;
  void _internal_set_minimum_high(uint64_t value);
  public:

  // optional uint64 minimum_low = 2;
  bool has_minimum_low() const;
  private:
  bool _internal_has_minimum_low() const;
  public:
  void clear_minimum_low();
  uint64_t minimum_low() const;
  void set_minimum_low(uint64_t value);
  private:
  uint64_t _internal_minimum_low() const;
  void _internal_set_minimum_low(uint64_t value);
  public:

  // optional sint64 maximum_high = 3;
  bool has_maximum_high() const;
  private:
  bool _internal_has_maximum_high() const;
  public:
  void clear_maximum_high();
  int64_t maximum_high() const;
  void set_maximum_high(int64_t value);
  private:
  int64_t _internal_maximum_high() const;
  void _internal_set_maximum_high(int64_t value);
  public:

  // optional sint64 maximum_low = 4;
  bool has_maximum_low() const;
  private:
  bool _internal_has_maximum_low() const;
  public:
  void clear_maximum_low();
  int64_t maximum_low() const;
  void set_maximum_low(int64_t value);
  private:
  int64_t _internal_maximum_low() const;
  void _internal_set_maximum_low(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pixels.proto.Integer128Statistic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint64_t minimum_high_;
    uint64_t minimum_low_;
    int64_t maximum_high_;
    int64_t maximum_low_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pixels_2eproto;
};
// -------------------------------------------------------------------

class DoubleStatistic final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pixels.proto.DoubleStatistic) */ {
 public:
  inline DoubleStatistic() : DoubleStatistic(nullptr) {}
  ~DoubleStatistic() override;
  explicit PROTOBUF_CONSTEXPR DoubleStatistic(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoubleStatistic(const DoubleStatistic& from);
  DoubleStatistic(DoubleStatistic&& from) noexcept
    : DoubleStatistic() {
    *this = ::std::move(from);
  }

  inline DoubleStatistic& operator=(const DoubleStatistic& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoubleStatistic& operator=(DoubleStatistic&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoubleStatistic& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoubleStatistic* internal_default_instance() {
    return reinterpret_cast<const DoubleStatistic*>(
               &_DoubleStatistic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DoubleStatistic& a, DoubleStatistic& b) {
    a.Swap(&b);
  }
  inline void Swap(DoubleStatistic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoubleStatistic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoubleStatistic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoubleStatistic>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoubleStatistic& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoubleStatistic& from) {
    DoubleStatistic::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoubleStatistic* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pixels.proto.DoubleStatistic";
  }
  protected:
  explicit DoubleStatistic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinimumFieldNumber = 1,
    kMaximumFieldNumber = 2,
    kSumFieldNumber = 3,
  };
  // optional double minimum = 1;
  bool has_minimum() const;
  private:
  bool _internal_has_minimum() const;
  public:
  void clear_minimum();
  double minimum() const;
  void set_minimum(double value);
  private:
  double _internal_minimum() const;
  void _internal_set_minimum(double value);
  public:

  // optional double maximum = 2;
  bool has_maximum() const;
  private:
  bool _internal_has_maximum() const;
  public:
  void clear_maximum();
  double maximum() const;
  void set_maximum(double value);
  private:
  double _internal_maximum() const;
  void _internal_set_maximum(double value);
  public:

  // optional double sum = 3;
  bool has_sum() const;
  private:
  bool _internal_has_sum() const;
  public:
  void clear_sum();
  double sum() const;
  void set_sum(double value);
  private:
  double _internal_sum() const;
  void _internal_set_sum(double value);
  public:

  // @@protoc_insertion_point(class_scope:pixels.proto.DoubleStatistic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    double minimum_;
    double maximum_;
    double sum_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pixels_2eproto;
};
// -------------------------------------------------------------------

class StringStatistic final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pixels.proto.StringStatistic) */ {
 public:
  inline StringStatistic() : StringStatistic(nullptr) {}
  ~StringStatistic() override;
  explicit PROTOBUF_CONSTEXPR StringStatistic(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringStatistic(const StringStatistic& from);
  StringStatistic(StringStatistic&& from) noexcept
    : StringStatistic() {
    *this = ::std::move(from);
  }

  inline StringStatistic& operator=(const StringStatistic& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringStatistic& operator=(StringStatistic&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringStatistic& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringStatistic* internal_default_instance() {
    return reinterpret_cast<const StringStatistic*>(
               &_StringStatistic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(StringStatistic& a, StringStatistic& b) {
    a.Swap(&b);
  }
  inline void Swap(StringStatistic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringStatistic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringStatistic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringStatistic>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StringStatistic& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StringStatistic& from) {
    StringStatistic::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringStatistic* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pixels.proto.StringStatistic";
  }
  protected:
  explicit StringStatistic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinimumFieldNumber = 1,
    kMaximumFieldNumber = 2,
    kSumFieldNumber = 3,
  };
  // optional string minimum = 1;
  bool has_minimum() const;
  private:
  bool _internal_has_minimum() const;
  public:
  void clear_minimum();
  const std::string& minimum() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_minimum(ArgT0&& arg0, ArgT... args);
  std::string* mutable_minimum();
  PROTOBUF_NODISCARD std::string* release_minimum();
  void set_allocated_minimum(std::string* minimum);
  private:
  const std::string& _internal_minimum() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_minimum(const std::string& value);
  std::string* _internal_mutable_minimum();
  public:

  // optional string maximum = 2;
  bool has_maximum() const;
  private:
  bool _internal_has_maximum() const;
  public:
  void clear_maximum();
  const std::string& maximum() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_maximum(ArgT0&& arg0, ArgT... args);
  std::string* mutable_maximum();
  PROTOBUF_NODISCARD std::string* release_maximum();
  void set_allocated_maximum(std::string* maximum);
  private:
  const std::string& _internal_maximum() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maximum(const std::string& value);
  std::string* _internal_mutable_maximum();
  public:

  // optional sint64 sum = 3;
  bool has_sum() const;
  private:
  bool _internal_has_sum() const;
  public:
  void clear_sum();
  int64_t sum() const;
  void set_sum(int64_t value);
  private:
  int64_t _internal_sum() const;
  void _internal_set_sum(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pixels.proto.StringStatistic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr minimum_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maximum_;
    int64_t sum_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pixels_2eproto;
};
// -------------------------------------------------------------------

class BucketStatistic final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pixels.proto.BucketStatistic) */ {
 public:
  inline BucketStatistic() : BucketStatistic(nullptr) {}
  ~BucketStatistic() override;
  explicit PROTOBUF_CONSTEXPR BucketStatistic(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BucketStatistic(const BucketStatistic& from);
  BucketStatistic(BucketStatistic&& from) noexcept
    : BucketStatistic() {
    *this = ::std::move(from);
  }

  inline BucketStatistic& operator=(const BucketStatistic& from) {
    CopyFrom(from);
    return *this;
  }
  inline BucketStatistic& operator=(BucketStatistic&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BucketStatistic& default_instance() {
    return *internal_default_instance();
  }
  static inline const BucketStatistic* internal_default_instance() {
    return reinterpret_cast<const BucketStatistic*>(
               &_BucketStatistic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BucketStatistic& a, BucketStatistic& b) {
    a.Swap(&b);
  }
  inline void Swap(BucketStatistic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BucketStatistic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BucketStatistic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BucketStatistic>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BucketStatistic& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BucketStatistic& from) {
    BucketStatistic::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BucketStatistic* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pixels.proto.BucketStatistic";
  }
  protected:
  explicit BucketStatistic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountFieldNumber = 1,
  };
  // repeated uint64 count = 1 [packed = true];
  int count_size() const;
  private:
  int _internal_count_size() const;
  public:
  void clear_count();
  private:
  uint64_t _internal_count(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_count() const;
  void _internal_add_count(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_count();
  public:
  uint64_t count(int index) const;
  void set_count(int index, uint64_t value);
  void add_count(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      count() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_count();

  // @@protoc_insertion_point(class_scope:pixels.proto.BucketStatistic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > count_;
    mutable std::atomic<int> _count_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pixels_2eproto;
};
// -------------------------------------------------------------------

class TimestampStatistic final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pixels.proto.TimestampStatistic) */ {
 public:
  inline TimestampStatistic() : TimestampStatistic(nullptr) {}
  ~TimestampStatistic() override;
  explicit PROTOBUF_CONSTEXPR TimestampStatistic(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimestampStatistic(const TimestampStatistic& from);
  TimestampStatistic(TimestampStatistic&& from) noexcept
    : TimestampStatistic() {
    *this = ::std::move(from);
  }

  inline TimestampStatistic& operator=(const TimestampStatistic& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimestampStatistic& operator=(TimestampStatistic&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimestampStatistic& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimestampStatistic* internal_default_instance() {
    return reinterpret_cast<const TimestampStatistic*>(
               &_TimestampStatistic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TimestampStatistic& a, TimestampStatistic& b) {
    a.Swap(&b);
  }
  inline void Swap(TimestampStatistic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimestampStatistic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimestampStatistic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimestampStatistic>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimestampStatistic& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TimestampStatistic& from) {
    TimestampStatistic::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimestampStatistic* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pixels.proto.TimestampStatistic";
  }
  protected:
  explicit TimestampStatistic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinimumFieldNumber = 1,
    kMaximumFieldNumber = 2,
  };
  // optional sint64 minimum = 1;
  bool has_minimum() const;
  private:
  bool _internal_has_minimum() const;
  public:
  void clear_minimum();
  int64_t minimum() const;
  void set_minimum(int64_t value);
  private:
  int64_t _internal_minimum() const;
  void _internal_set_minimum(int64_t value);
  public:

  // optional sint64 maximum = 2;
  bool has_maximum() const;
  private:
  bool _internal_has_maximum() const;
  public:
  void clear_maximum();
  int64_t maximum() const;
  void set_maximum(int64_t value);
  private:
  int64_t _internal_maximum() const;
  void _internal_set_maximum(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pixels.proto.TimestampStatistic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t minimum_;
    int64_t maximum_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pixels_2eproto;
};
// -------------------------------------------------------------------

class DateStatistic final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pixels.proto.DateStatistic) */ {
 public:
  inline DateStatistic() : DateStatistic(nullptr) {}
  ~DateStatistic() override;
  explicit PROTOBUF_CONSTEXPR DateStatistic(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DateStatistic(const DateStatistic& from);
  DateStatistic(DateStatistic&& from) noexcept
    : DateStatistic() {
    *this = ::std::move(from);
  }

  inline DateStatistic& operator=(const DateStatistic& from) {
    CopyFrom(from);
    return *this;
  }
  inline DateStatistic& operator=(DateStatistic&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DateStatistic& default_instance() {
    return *internal_default_instance();
  }
  static inline const DateStatistic* internal_default_instance() {
    return reinterpret_cast<const DateStatistic*>(
               &_DateStatistic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DateStatistic& a, DateStatistic& b) {
    a.Swap(&b);
  }
  inline void Swap(DateStatistic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DateStatistic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DateStatistic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DateStatistic>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DateStatistic& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DateStatistic& from) {
    DateStatistic::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DateStatistic* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pixels.proto.DateStatistic";
  }
  protected:
  explicit DateStatistic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinimumFieldNumber = 1,
    kMaximumFieldNumber = 2,
  };
  // optional sint32 minimum = 1;
  bool has_minimum() const;
  private:
  bool _internal_has_minimum() const;
  public:
  void clear_minimum();
  int32_t minimum() const;
  void set_minimum(int32_t value);
  private:
  int32_t _internal_minimum() const;
  void _internal_set_minimum(int32_t value);
  public:

  // optional sint32 maximum = 2;
  bool has_maximum() const;
  private:
  bool _internal_has_maximum() const;
  public:
  void clear_maximum();
  int32_t maximum() const;
  void set_maximum(int32_t value);
  private:
  int32_t _internal_maximum() const;
  void _internal_set_maximum(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pixels.proto.DateStatistic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t minimum_;
    int32_t maximum_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pixels_2eproto;
};
// -------------------------------------------------------------------

class TimeStatistic final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pixels.proto.TimeStatistic) */ {
 public:
  inline TimeStatistic() : TimeStatistic(nullptr) {}
  ~TimeStatistic() override;
  explicit PROTOBUF_CONSTEXPR TimeStatistic(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimeStatistic(const TimeStatistic& from);
  TimeStatistic(TimeStatistic&& from) noexcept
    : TimeStatistic() {
    *this = ::std::move(from);
  }

  inline TimeStatistic& operator=(const TimeStatistic& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeStatistic& operator=(TimeStatistic&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeStatistic& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeStatistic* internal_default_instance() {
    return reinterpret_cast<const TimeStatistic*>(
               &_TimeStatistic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TimeStatistic& a, TimeStatistic& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeStatistic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeStatistic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeStatistic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeStatistic>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimeStatistic& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TimeStatistic& from) {
    TimeStatistic::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeStatistic* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pixels.proto.TimeStatistic";
  }
  protected:
  explicit TimeStatistic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinimumFieldNumber = 1,
    kMaximumFieldNumber = 2,
  };
  // optional sint32 minimum = 1;
  bool has_minimum() const;
  private:
  bool _internal_has_minimum() const;
  public:
  void clear_minimum();
  int32_t minimum() const;
  void set_minimum(int32_t value);
  private:
  int32_t _internal_minimum() const;
  void _internal_set_minimum(int32_t value);
  public:

  // optional sint32 maximum = 2;
  bool has_maximum() const;
  private:
  bool _internal_has_maximum() const;
  public:
  void clear_maximum();
  int32_t maximum() const;
  void set_maximum(int32_t value);
  private:
  int32_t _internal_maximum() const;
  void _internal_set_maximum(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pixels.proto.TimeStatistic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t minimum_;
    int32_t maximum_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pixels_2eproto;
};
// -------------------------------------------------------------------

class BinaryStatistic final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pixels.proto.BinaryStatistic) */ {
 public:
  inline BinaryStatistic() : BinaryStatistic(nullptr) {}
  ~BinaryStatistic() override;
  explicit PROTOBUF_CONSTEXPR BinaryStatistic(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BinaryStatistic(const BinaryStatistic& from);
  BinaryStatistic(BinaryStatistic&& from) noexcept
    : BinaryStatistic() {
    *this = ::std::move(from);
  }

  inline BinaryStatistic& operator=(const BinaryStatistic& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryStatistic& operator=(BinaryStatistic&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BinaryStatistic& default_instance() {
    return *internal_default_instance();
  }
  static inline const BinaryStatistic* internal_default_instance() {
    return reinterpret_cast<const BinaryStatistic*>(
               &_BinaryStatistic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(BinaryStatistic& a, BinaryStatistic& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryStatistic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryStatistic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BinaryStatistic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BinaryStatistic>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BinaryStatistic& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BinaryStatistic& from) {
    BinaryStatistic::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryStatistic* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pixels.proto.BinaryStatistic";
  }
  protected:
  explicit BinaryStatistic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSumFieldNumber = 1,
  };
  // optional sint64 sum = 1;
  bool has_sum() const;
  private:
  bool _internal_has_sum() const;
  public:
  void clear_sum();
  int64_t sum() const;
  void set_sum(int64_t value);
  private:
  int64_t _internal_sum() const;
  void _internal_set_sum(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pixels.proto.BinaryStatistic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t sum_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pixels_2eproto;
};
// -------------------------------------------------------------------

class ColumnStatistic final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pixels.proto.ColumnStatistic) */ {
 public:
  inline ColumnStatistic() : ColumnStatistic(nullptr) {}
  ~ColumnStatistic() override;
  explicit PROTOBUF_CONSTEXPR ColumnStatistic(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColumnStatistic(const ColumnStatistic& from);
  ColumnStatistic(ColumnStatistic&& from) noexcept
    : ColumnStatistic() {
    *this = ::std::move(from);
  }

  inline ColumnStatistic& operator=(const ColumnStatistic& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnStatistic& operator=(ColumnStatistic&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnStatistic& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnStatistic* internal_default_instance() {
    return reinterpret_cast<const ColumnStatistic*>(
               &_ColumnStatistic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ColumnStatistic& a, ColumnStatistic& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnStatistic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnStatistic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnStatistic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColumnStatistic>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ColumnStatistic& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ColumnStatistic& from) {
    ColumnStatistic::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnStatistic* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pixels.proto.ColumnStatistic";
  }
  protected:
  explicit ColumnStatistic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntStatisticsFieldNumber = 2,
    kDoubleStatisticsFieldNumber = 3,
    kStringStatisticsFieldNumber = 4,
    kBucketStatisticsFieldNumber = 5,
    kBinaryStatisticsFieldNumber = 6,
    kTimestampStatisticsFieldNumber = 7,
    kDateStatisticsFieldNumber = 9,
    kTimeStatisticsFieldNumber = 10,
    kInt128StatisticsFieldNumber = 11,
    kNumberOfValuesFieldNumber = 1,
    kHasNullFieldNumber = 8,
  };
  // optional .pixels.proto.IntegerStatistic intStatistics = 2;
  bool has_intstatistics() const;
  private:
  bool _internal_has_intstatistics() const;
  public:
  void clear_intstatistics();
  const ::pixels::proto::IntegerStatistic& intstatistics() const;
  PROTOBUF_NODISCARD ::pixels::proto::IntegerStatistic* release_intstatistics();
  ::pixels::proto::IntegerStatistic* mutable_intstatistics();
  void set_allocated_intstatistics(::pixels::proto::IntegerStatistic* intstatistics);
  private:
  const ::pixels::proto::IntegerStatistic& _internal_intstatistics() const;
  ::pixels::proto::IntegerStatistic* _internal_mutable_intstatistics();
  public:
  void unsafe_arena_set_allocated_intstatistics(
      ::pixels::proto::IntegerStatistic* intstatistics);
  ::pixels::proto::IntegerStatistic* unsafe_arena_release_intstatistics();

  // optional .pixels.proto.DoubleStatistic doubleStatistics = 3;
  bool has_doublestatistics() const;
  private:
  bool _internal_has_doublestatistics() const;
  public:
  void clear_doublestatistics();
  const ::pixels::proto::DoubleStatistic& doublestatistics() const;
  PROTOBUF_NODISCARD ::pixels::proto::DoubleStatistic* release_doublestatistics();
  ::pixels::proto::DoubleStatistic* mutable_doublestatistics();
  void set_allocated_doublestatistics(::pixels::proto::DoubleStatistic* doublestatistics);
  private:
  const ::pixels::proto::DoubleStatistic& _internal_doublestatistics() const;
  ::pixels::proto::DoubleStatistic* _internal_mutable_doublestatistics();
  public:
  void unsafe_arena_set_allocated_doublestatistics(
      ::pixels::proto::DoubleStatistic* doublestatistics);
  ::pixels::proto::DoubleStatistic* unsafe_arena_release_doublestatistics();

  // optional .pixels.proto.StringStatistic stringStatistics = 4;
  bool has_stringstatistics() const;
  private:
  bool _internal_has_stringstatistics() const;
  public:
  void clear_stringstatistics();
  const ::pixels::proto::StringStatistic& stringstatistics() const;
  PROTOBUF_NODISCARD ::pixels::proto::StringStatistic* release_stringstatistics();
  ::pixels::proto::StringStatistic* mutable_stringstatistics();
  void set_allocated_stringstatistics(::pixels::proto::StringStatistic* stringstatistics);
  private:
  const ::pixels::proto::StringStatistic& _internal_stringstatistics() const;
  ::pixels::proto::StringStatistic* _internal_mutable_stringstatistics();
  public:
  void unsafe_arena_set_allocated_stringstatistics(
      ::pixels::proto::StringStatistic* stringstatistics);
  ::pixels::proto::StringStatistic* unsafe_arena_release_stringstatistics();

  // optional .pixels.proto.BucketStatistic bucketStatistics = 5;
  bool has_bucketstatistics() const;
  private:
  bool _internal_has_bucketstatistics() const;
  public:
  void clear_bucketstatistics();
  const ::pixels::proto::BucketStatistic& bucketstatistics() const;
  PROTOBUF_NODISCARD ::pixels::proto::BucketStatistic* release_bucketstatistics();
  ::pixels::proto::BucketStatistic* mutable_bucketstatistics();
  void set_allocated_bucketstatistics(::pixels::proto::BucketStatistic* bucketstatistics);
  private:
  const ::pixels::proto::BucketStatistic& _internal_bucketstatistics() const;
  ::pixels::proto::BucketStatistic* _internal_mutable_bucketstatistics();
  public:
  void unsafe_arena_set_allocated_bucketstatistics(
      ::pixels::proto::BucketStatistic* bucketstatistics);
  ::pixels::proto::BucketStatistic* unsafe_arena_release_bucketstatistics();

  // optional .pixels.proto.BinaryStatistic binaryStatistics = 6;
  bool has_binarystatistics() const;
  private:
  bool _internal_has_binarystatistics() const;
  public:
  void clear_binarystatistics();
  const ::pixels::proto::BinaryStatistic& binarystatistics() const;
  PROTOBUF_NODISCARD ::pixels::proto::BinaryStatistic* release_binarystatistics();
  ::pixels::proto::BinaryStatistic* mutable_binarystatistics();
  void set_allocated_binarystatistics(::pixels::proto::BinaryStatistic* binarystatistics);
  private:
  const ::pixels::proto::BinaryStatistic& _internal_binarystatistics() const;
  ::pixels::proto::BinaryStatistic* _internal_mutable_binarystatistics();
  public:
  void unsafe_arena_set_allocated_binarystatistics(
      ::pixels::proto::BinaryStatistic* binarystatistics);
  ::pixels::proto::BinaryStatistic* unsafe_arena_release_binarystatistics();

  // optional .pixels.proto.TimestampStatistic timestampStatistics = 7;
  bool has_timestampstatistics() const;
  private:
  bool _internal_has_timestampstatistics() const;
  public:
  void clear_timestampstatistics();
  const ::pixels::proto::TimestampStatistic& timestampstatistics() const;
  PROTOBUF_NODISCARD ::pixels::proto::TimestampStatistic* release_timestampstatistics();
  ::pixels::proto::TimestampStatistic* mutable_timestampstatistics();
  void set_allocated_timestampstatistics(::pixels::proto::TimestampStatistic* timestampstatistics);
  private:
  const ::pixels::proto::TimestampStatistic& _internal_timestampstatistics() const;
  ::pixels::proto::TimestampStatistic* _internal_mutable_timestampstatistics();
  public:
  void unsafe_arena_set_allocated_timestampstatistics(
      ::pixels::proto::TimestampStatistic* timestampstatistics);
  ::pixels::proto::TimestampStatistic* unsafe_arena_release_timestampstatistics();

  // optional .pixels.proto.DateStatistic dateStatistics = 9;
  bool has_datestatistics() const;
  private:
  bool _internal_has_datestatistics() const;
  public:
  void clear_datestatistics();
  const ::pixels::proto::DateStatistic& datestatistics() const;
  PROTOBUF_NODISCARD ::pixels::proto::DateStatistic* release_datestatistics();
  ::pixels::proto::DateStatistic* mutable_datestatistics();
  void set_allocated_datestatistics(::pixels::proto::DateStatistic* datestatistics);
  private:
  const ::pixels::proto::DateStatistic& _internal_datestatistics() const;
  ::pixels::proto::DateStatistic* _internal_mutable_datestatistics();
  public:
  void unsafe_arena_set_allocated_datestatistics(
      ::pixels::proto::DateStatistic* datestatistics);
  ::pixels::proto::DateStatistic* unsafe_arena_release_datestatistics();

  // optional .pixels.proto.TimeStatistic timeStatistics = 10;
  bool has_timestatistics() const;
  private:
  bool _internal_has_timestatistics() const;
  public:
  void clear_timestatistics();
  const ::pixels::proto::TimeStatistic& timestatistics() const;
  PROTOBUF_NODISCARD ::pixels::proto::TimeStatistic* release_timestatistics();
  ::pixels::proto::TimeStatistic* mutable_timestatistics();
  void set_allocated_timestatistics(::pixels::proto::TimeStatistic* timestatistics);
  private:
  const ::pixels::proto::TimeStatistic& _internal_timestatistics() const;
  ::pixels::proto::TimeStatistic* _internal_mutable_timestatistics();
  public:
  void unsafe_arena_set_allocated_timestatistics(
      ::pixels::proto::TimeStatistic* timestatistics);
  ::pixels::proto::TimeStatistic* unsafe_arena_release_timestatistics();

  // optional .pixels.proto.Integer128Statistic int128Statistics = 11;
  bool has_int128statistics() const;
  private:
  bool _internal_has_int128statistics() const;
  public:
  void clear_int128statistics();
  const ::pixels::proto::Integer128Statistic& int128statistics() const;
  PROTOBUF_NODISCARD ::pixels::proto::Integer128Statistic* release_int128statistics();
  ::pixels::proto::Integer128Statistic* mutable_int128statistics();
  void set_allocated_int128statistics(::pixels::proto::Integer128Statistic* int128statistics);
  private:
  const ::pixels::proto::Integer128Statistic& _internal_int128statistics() const;
  ::pixels::proto::Integer128Statistic* _internal_mutable_int128statistics();
  public:
  void unsafe_arena_set_allocated_int128statistics(
      ::pixels::proto::Integer128Statistic* int128statistics);
  ::pixels::proto::Integer128Statistic* unsafe_arena_release_int128statistics();

  // optional uint64 numberOfValues = 1;
  bool has_numberofvalues() const;
  private:
  bool _internal_has_numberofvalues() const;
  public:
  void clear_numberofvalues();
  uint64_t numberofvalues() const;
  void set_numberofvalues(uint64_t value);
  private:
  uint64_t _internal_numberofvalues() const;
  void _internal_set_numberofvalues(uint64_t value);
  public:

  // optional bool hasNull = 8;
  bool has_hasnull() const;
  private:
  bool _internal_has_hasnull() const;
  public:
  void clear_hasnull();
  bool hasnull() const;
  void set_hasnull(bool value);
  private:
  bool _internal_hasnull() const;
  void _internal_set_hasnull(bool value);
  public:

  // @@protoc_insertion_point(class_scope:pixels.proto.ColumnStatistic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::pixels::proto::IntegerStatistic* intstatistics_;
    ::pixels::proto::DoubleStatistic* doublestatistics_;
    ::pixels::proto::StringStatistic* stringstatistics_;
    ::pixels::proto::BucketStatistic* bucketstatistics_;
    ::pixels::proto::BinaryStatistic* binarystatistics_;
    ::pixels::proto::TimestampStatistic* timestampstatistics_;
    ::pixels::proto::DateStatistic* datestatistics_;
    ::pixels::proto::TimeStatistic* timestatistics_;
    ::pixels::proto::Integer128Statistic* int128statistics_;
    uint64_t numberofvalues_;
    bool hasnull_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pixels_2eproto;
};
// -------------------------------------------------------------------

class PixelStatistic final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pixels.proto.PixelStatistic) */ {
 public:
  inline PixelStatistic() : PixelStatistic(nullptr) {}
  ~PixelStatistic() override;
  explicit PROTOBUF_CONSTEXPR PixelStatistic(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PixelStatistic(const PixelStatistic& from);
  PixelStatistic(PixelStatistic&& from) noexcept
    : PixelStatistic() {
    *this = ::std::move(from);
  }

  inline PixelStatistic& operator=(const PixelStatistic& from) {
    CopyFrom(from);
    return *this;
  }
  inline PixelStatistic& operator=(PixelStatistic&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PixelStatistic& default_instance() {
    return *internal_default_instance();
  }
  static inline const PixelStatistic* internal_default_instance() {
    return reinterpret_cast<const PixelStatistic*>(
               &_PixelStatistic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PixelStatistic& a, PixelStatistic& b) {
    a.Swap(&b);
  }
  inline void Swap(PixelStatistic* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PixelStatistic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PixelStatistic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PixelStatistic>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PixelStatistic& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PixelStatistic& from) {
    PixelStatistic::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PixelStatistic* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pixels.proto.PixelStatistic";
  }
  protected:
  explicit PixelStatistic(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatisticFieldNumber = 1,
  };
  // optional .pixels.proto.ColumnStatistic statistic = 1;
  bool has_statistic() const;
  private:
  bool _internal_has_statistic() const;
  public:
  void clear_statistic();
  const ::pixels::proto::ColumnStatistic& statistic() const;
  PROTOBUF_NODISCARD ::pixels::proto::ColumnStatistic* release_statistic();
  ::pixels::proto::ColumnStatistic* mutable_statistic();
  void set_allocated_statistic(::pixels::proto::ColumnStatistic* statistic);
  private:
  const ::pixels::proto::ColumnStatistic& _internal_statistic() const;
  ::pixels::proto::ColumnStatistic* _internal_mutable_statistic();
  public:
  void unsafe_arena_set_allocated_statistic(
      ::pixels::proto::ColumnStatistic* statistic);
  ::pixels::proto::ColumnStatistic* unsafe_arena_release_statistic();

  // @@protoc_insertion_point(class_scope:pixels.proto.PixelStatistic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::pixels::proto::ColumnStatistic* statistic_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pixels_2eproto;
};
// -------------------------------------------------------------------

class ColumnChunkIndex final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pixels.proto.ColumnChunkIndex) */ {
 public:
  inline ColumnChunkIndex() : ColumnChunkIndex(nullptr) {}
  ~ColumnChunkIndex() override;
  explicit PROTOBUF_CONSTEXPR ColumnChunkIndex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColumnChunkIndex(const ColumnChunkIndex& from);
  ColumnChunkIndex(ColumnChunkIndex&& from) noexcept
    : ColumnChunkIndex() {
    *this = ::std::move(from);
  }

  inline ColumnChunkIndex& operator=(const ColumnChunkIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnChunkIndex& operator=(ColumnChunkIndex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnChunkIndex& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnChunkIndex* internal_default_instance() {
    return reinterpret_cast<const ColumnChunkIndex*>(
               &_ColumnChunkIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ColumnChunkIndex& a, ColumnChunkIndex& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnChunkIndex* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnChunkIndex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnChunkIndex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColumnChunkIndex>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ColumnChunkIndex& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ColumnChunkIndex& from) {
    ColumnChunkIndex::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnChunkIndex* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pixels.proto.ColumnChunkIndex";
  }
  protected:
  explicit ColumnChunkIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPixelPositionsFieldNumber = 4,
    kPixelStatisticsFieldNumber = 5,
    kChunkOffsetFieldNumber = 1,
    kChunkLengthFieldNumber = 2,
    kIsNullOffsetFieldNumber = 3,
    kLittleEndianFieldNumber = 6,
    kNullsPaddingFieldNumber = 7,
    kIsNullAlignmentFieldNumber = 8,
  };
  // repeated uint32 pixelPositions = 4 [packed = true];
  int pixelpositions_size() const;
  private:
  int _internal_pixelpositions_size() const;
  public:
  void clear_pixelpositions();
  private:
  uint32_t _internal_pixelpositions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_pixelpositions() const;
  void _internal_add_pixelpositions(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_pixelpositions();
  public:
  uint32_t pixelpositions(int index) const;
  void set_pixelpositions(int index, uint32_t value);
  void add_pixelpositions(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      pixelpositions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_pixelpositions();

  // repeated .pixels.proto.PixelStatistic pixelStatistics = 5;
  int pixelstatistics_size() const;
  private:
  int _internal_pixelstatistics_size() const;
  public:
  void clear_pixelstatistics();
  ::pixels::proto::PixelStatistic* mutable_pixelstatistics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::PixelStatistic >*
      mutable_pixelstatistics();
  private:
  const ::pixels::proto::PixelStatistic& _internal_pixelstatistics(int index) const;
  ::pixels::proto::PixelStatistic* _internal_add_pixelstatistics();
  public:
  const ::pixels::proto::PixelStatistic& pixelstatistics(int index) const;
  ::pixels::proto::PixelStatistic* add_pixelstatistics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::PixelStatistic >&
      pixelstatistics() const;

  // optional uint64 chunkOffset = 1;
  bool has_chunkoffset() const;
  private:
  bool _internal_has_chunkoffset() const;
  public:
  void clear_chunkoffset();
  uint64_t chunkoffset() const;
  void set_chunkoffset(uint64_t value);
  private:
  uint64_t _internal_chunkoffset() const;
  void _internal_set_chunkoffset(uint64_t value);
  public:

  // optional uint32 chunkLength = 2;
  bool has_chunklength() const;
  private:
  bool _internal_has_chunklength() const;
  public:
  void clear_chunklength();
  uint32_t chunklength() const;
  void set_chunklength(uint32_t value);
  private:
  uint32_t _internal_chunklength() const;
  void _internal_set_chunklength(uint32_t value);
  public:

  // optional uint32 isNullOffset = 3;
  bool has_isnulloffset() const;
  private:
  bool _internal_has_isnulloffset() const;
  public:
  void clear_isnulloffset();
  uint32_t isnulloffset() const;
  void set_isnulloffset(uint32_t value);
  private:
  uint32_t _internal_isnulloffset() const;
  void _internal_set_isnulloffset(uint32_t value);
  public:

  // optional bool littleEndian = 6;
  bool has_littleendian() const;
  private:
  bool _internal_has_littleendian() const;
  public:
  void clear_littleendian();
  bool littleendian() const;
  void set_littleendian(bool value);
  private:
  bool _internal_littleendian() const;
  void _internal_set_littleendian(bool value);
  public:

  // optional bool nullsPadding = 7;
  bool has_nullspadding() const;
  private:
  bool _internal_has_nullspadding() const;
  public:
  void clear_nullspadding();
  bool nullspadding() const;
  void set_nullspadding(bool value);
  private:
  bool _internal_nullspadding() const;
  void _internal_set_nullspadding(bool value);
  public:

  // optional uint32 isNullAlignment = 8;
  bool has_isnullalignment() const;
  private:
  bool _internal_has_isnullalignment() const;
  public:
  void clear_isnullalignment();
  uint32_t isnullalignment() const;
  void set_isnullalignment(uint32_t value);
  private:
  uint32_t _internal_isnullalignment() const;
  void _internal_set_isnullalignment(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pixels.proto.ColumnChunkIndex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > pixelpositions_;
    mutable std::atomic<int> _pixelpositions_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::PixelStatistic > pixelstatistics_;
    uint64_t chunkoffset_;
    uint32_t chunklength_;
    uint32_t isnulloffset_;
    bool littleendian_;
    bool nullspadding_;
    uint32_t isnullalignment_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pixels_2eproto;
};
// -------------------------------------------------------------------

class RowGroupIndex final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pixels.proto.RowGroupIndex) */ {
 public:
  inline RowGroupIndex() : RowGroupIndex(nullptr) {}
  ~RowGroupIndex() override;
  explicit PROTOBUF_CONSTEXPR RowGroupIndex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RowGroupIndex(const RowGroupIndex& from);
  RowGroupIndex(RowGroupIndex&& from) noexcept
    : RowGroupIndex() {
    *this = ::std::move(from);
  }

  inline RowGroupIndex& operator=(const RowGroupIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline RowGroupIndex& operator=(RowGroupIndex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RowGroupIndex& default_instance() {
    return *internal_default_instance();
  }
  static inline const RowGroupIndex* internal_default_instance() {
    return reinterpret_cast<const RowGroupIndex*>(
               &_RowGroupIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(RowGroupIndex& a, RowGroupIndex& b) {
    a.Swap(&b);
  }
  inline void Swap(RowGroupIndex* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RowGroupIndex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RowGroupIndex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RowGroupIndex>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RowGroupIndex& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RowGroupIndex& from) {
    RowGroupIndex::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RowGroupIndex* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pixels.proto.RowGroupIndex";
  }
  protected:
  explicit RowGroupIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnChunkIndexEntriesFieldNumber = 1,
  };
  // repeated .pixels.proto.ColumnChunkIndex columnChunkIndexEntries = 1;
  int columnchunkindexentries_size() const;
  private:
  int _internal_columnchunkindexentries_size() const;
  public:
  void clear_columnchunkindexentries();
  ::pixels::proto::ColumnChunkIndex* mutable_columnchunkindexentries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::ColumnChunkIndex >*
      mutable_columnchunkindexentries();
  private:
  const ::pixels::proto::ColumnChunkIndex& _internal_columnchunkindexentries(int index) const;
  ::pixels::proto::ColumnChunkIndex* _internal_add_columnchunkindexentries();
  public:
  const ::pixels::proto::ColumnChunkIndex& columnchunkindexentries(int index) const;
  ::pixels::proto::ColumnChunkIndex* add_columnchunkindexentries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::ColumnChunkIndex >&
      columnchunkindexentries() const;

  // @@protoc_insertion_point(class_scope:pixels.proto.RowGroupIndex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::ColumnChunkIndex > columnchunkindexentries_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pixels_2eproto;
};
// -------------------------------------------------------------------

class RowGroupEncoding final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pixels.proto.RowGroupEncoding) */ {
 public:
  inline RowGroupEncoding() : RowGroupEncoding(nullptr) {}
  ~RowGroupEncoding() override;
  explicit PROTOBUF_CONSTEXPR RowGroupEncoding(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RowGroupEncoding(const RowGroupEncoding& from);
  RowGroupEncoding(RowGroupEncoding&& from) noexcept
    : RowGroupEncoding() {
    *this = ::std::move(from);
  }

  inline RowGroupEncoding& operator=(const RowGroupEncoding& from) {
    CopyFrom(from);
    return *this;
  }
  inline RowGroupEncoding& operator=(RowGroupEncoding&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RowGroupEncoding& default_instance() {
    return *internal_default_instance();
  }
  static inline const RowGroupEncoding* internal_default_instance() {
    return reinterpret_cast<const RowGroupEncoding*>(
               &_RowGroupEncoding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RowGroupEncoding& a, RowGroupEncoding& b) {
    a.Swap(&b);
  }
  inline void Swap(RowGroupEncoding* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RowGroupEncoding* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RowGroupEncoding* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RowGroupEncoding>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RowGroupEncoding& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RowGroupEncoding& from) {
    RowGroupEncoding::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RowGroupEncoding* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pixels.proto.RowGroupEncoding";
  }
  protected:
  explicit RowGroupEncoding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnChunkEncodingsFieldNumber = 1,
  };
  // repeated .pixels.proto.ColumnEncoding columnChunkEncodings = 1;
  int columnchunkencodings_size() const;
  private:
  int _internal_columnchunkencodings_size() const;
  public:
  void clear_columnchunkencodings();
  ::pixels::proto::ColumnEncoding* mutable_columnchunkencodings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::ColumnEncoding >*
      mutable_columnchunkencodings();
  private:
  const ::pixels::proto::ColumnEncoding& _internal_columnchunkencodings(int index) const;
  ::pixels::proto::ColumnEncoding* _internal_add_columnchunkencodings();
  public:
  const ::pixels::proto::ColumnEncoding& columnchunkencodings(int index) const;
  ::pixels::proto::ColumnEncoding* add_columnchunkencodings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::ColumnEncoding >&
      columnchunkencodings() const;

  // @@protoc_insertion_point(class_scope:pixels.proto.RowGroupEncoding)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::ColumnEncoding > columnchunkencodings_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pixels_2eproto;
};
// -------------------------------------------------------------------

class RowGroupFooter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pixels.proto.RowGroupFooter) */ {
 public:
  inline RowGroupFooter() : RowGroupFooter(nullptr) {}
  ~RowGroupFooter() override;
  explicit PROTOBUF_CONSTEXPR RowGroupFooter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RowGroupFooter(const RowGroupFooter& from);
  RowGroupFooter(RowGroupFooter&& from) noexcept
    : RowGroupFooter() {
    *this = ::std::move(from);
  }

  inline RowGroupFooter& operator=(const RowGroupFooter& from) {
    CopyFrom(from);
    return *this;
  }
  inline RowGroupFooter& operator=(RowGroupFooter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RowGroupFooter& default_instance() {
    return *internal_default_instance();
  }
  static inline const RowGroupFooter* internal_default_instance() {
    return reinterpret_cast<const RowGroupFooter*>(
               &_RowGroupFooter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(RowGroupFooter& a, RowGroupFooter& b) {
    a.Swap(&b);
  }
  inline void Swap(RowGroupFooter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RowGroupFooter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RowGroupFooter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RowGroupFooter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RowGroupFooter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RowGroupFooter& from) {
    RowGroupFooter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RowGroupFooter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pixels.proto.RowGroupFooter";
  }
  protected:
  explicit RowGroupFooter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowGroupIndexEntryFieldNumber = 1,
    kRowGroupEncodingFieldNumber = 2,
  };
  // optional .pixels.proto.RowGroupIndex rowGroupIndexEntry = 1;
  bool has_rowgroupindexentry() const;
  private:
  bool _internal_has_rowgroupindexentry() const;
  public:
  void clear_rowgroupindexentry();
  const ::pixels::proto::RowGroupIndex& rowgroupindexentry() const;
  PROTOBUF_NODISCARD ::pixels::proto::RowGroupIndex* release_rowgroupindexentry();
  ::pixels::proto::RowGroupIndex* mutable_rowgroupindexentry();
  void set_allocated_rowgroupindexentry(::pixels::proto::RowGroupIndex* rowgroupindexentry);
  private:
  const ::pixels::proto::RowGroupIndex& _internal_rowgroupindexentry() const;
  ::pixels::proto::RowGroupIndex* _internal_mutable_rowgroupindexentry();
  public:
  void unsafe_arena_set_allocated_rowgroupindexentry(
      ::pixels::proto::RowGroupIndex* rowgroupindexentry);
  ::pixels::proto::RowGroupIndex* unsafe_arena_release_rowgroupindexentry();

  // optional .pixels.proto.RowGroupEncoding rowGroupEncoding = 2;
  bool has_rowgroupencoding() const;
  private:
  bool _internal_has_rowgroupencoding() const;
  public:
  void clear_rowgroupencoding();
  const ::pixels::proto::RowGroupEncoding& rowgroupencoding() const;
  PROTOBUF_NODISCARD ::pixels::proto::RowGroupEncoding* release_rowgroupencoding();
  ::pixels::proto::RowGroupEncoding* mutable_rowgroupencoding();
  void set_allocated_rowgroupencoding(::pixels::proto::RowGroupEncoding* rowgroupencoding);
  private:
  const ::pixels::proto::RowGroupEncoding& _internal_rowgroupencoding() const;
  ::pixels::proto::RowGroupEncoding* _internal_mutable_rowgroupencoding();
  public:
  void unsafe_arena_set_allocated_rowgroupencoding(
      ::pixels::proto::RowGroupEncoding* rowgroupencoding);
  ::pixels::proto::RowGroupEncoding* unsafe_arena_release_rowgroupencoding();

  // @@protoc_insertion_point(class_scope:pixels.proto.RowGroupFooter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::pixels::proto::RowGroupIndex* rowgroupindexentry_;
    ::pixels::proto::RowGroupEncoding* rowgroupencoding_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pixels_2eproto;
};
// -------------------------------------------------------------------

class ColumnEncoding final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pixels.proto.ColumnEncoding) */ {
 public:
  inline ColumnEncoding() : ColumnEncoding(nullptr) {}
  ~ColumnEncoding() override;
  explicit PROTOBUF_CONSTEXPR ColumnEncoding(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColumnEncoding(const ColumnEncoding& from);
  ColumnEncoding(ColumnEncoding&& from) noexcept
    : ColumnEncoding() {
    *this = ::std::move(from);
  }

  inline ColumnEncoding& operator=(const ColumnEncoding& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnEncoding& operator=(ColumnEncoding&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnEncoding& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnEncoding* internal_default_instance() {
    return reinterpret_cast<const ColumnEncoding*>(
               &_ColumnEncoding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ColumnEncoding& a, ColumnEncoding& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnEncoding* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnEncoding* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnEncoding* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColumnEncoding>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ColumnEncoding& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ColumnEncoding& from) {
    ColumnEncoding::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnEncoding* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pixels.proto.ColumnEncoding";
  }
  protected:
  explicit ColumnEncoding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ColumnEncoding_Kind Kind;
  static constexpr Kind NONE =
    ColumnEncoding_Kind_NONE;
  static constexpr Kind RUNLENGTH =
    ColumnEncoding_Kind_RUNLENGTH;
  static constexpr Kind DICTIONARY =
    ColumnEncoding_Kind_DICTIONARY;
  static inline bool Kind_IsValid(int value) {
    return ColumnEncoding_Kind_IsValid(value);
  }
  static constexpr Kind Kind_MIN =
    ColumnEncoding_Kind_Kind_MIN;
  static constexpr Kind Kind_MAX =
    ColumnEncoding_Kind_Kind_MAX;
  static constexpr int Kind_ARRAYSIZE =
    ColumnEncoding_Kind_Kind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Kind_descriptor() {
    return ColumnEncoding_Kind_descriptor();
  }
  template<typename T>
  static inline const std::string& Kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Kind_Name.");
    return ColumnEncoding_Kind_Name(enum_t_value);
  }
  static inline bool Kind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Kind* value) {
    return ColumnEncoding_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCascadeEncodingFieldNumber = 3,
    kKindFieldNumber = 1,
    kDictionarySizeFieldNumber = 2,
  };
  // optional .pixels.proto.ColumnEncoding cascadeEncoding = 3;
  bool has_cascadeencoding() const;
  private:
  bool _internal_has_cascadeencoding() const;
  public:
  void clear_cascadeencoding();
  const ::pixels::proto::ColumnEncoding& cascadeencoding() const;
  PROTOBUF_NODISCARD ::pixels::proto::ColumnEncoding* release_cascadeencoding();
  ::pixels::proto::ColumnEncoding* mutable_cascadeencoding();
  void set_allocated_cascadeencoding(::pixels::proto::ColumnEncoding* cascadeencoding);
  private:
  const ::pixels::proto::ColumnEncoding& _internal_cascadeencoding() const;
  ::pixels::proto::ColumnEncoding* _internal_mutable_cascadeencoding();
  public:
  void unsafe_arena_set_allocated_cascadeencoding(
      ::pixels::proto::ColumnEncoding* cascadeencoding);
  ::pixels::proto::ColumnEncoding* unsafe_arena_release_cascadeencoding();

  // required .pixels.proto.ColumnEncoding.Kind kind = 1;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  ::pixels::proto::ColumnEncoding_Kind kind() const;
  void set_kind(::pixels::proto::ColumnEncoding_Kind value);
  private:
  ::pixels::proto::ColumnEncoding_Kind _internal_kind() const;
  void _internal_set_kind(::pixels::proto::ColumnEncoding_Kind value);
  public:

  // optional uint32 dictionarySize = 2;
  bool has_dictionarysize() const;
  private:
  bool _internal_has_dictionarysize() const;
  public:
  void clear_dictionarysize();
  uint32_t dictionarysize() const;
  void set_dictionarysize(uint32_t value);
  private:
  uint32_t _internal_dictionarysize() const;
  void _internal_set_dictionarysize(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pixels.proto.ColumnEncoding)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::pixels::proto::ColumnEncoding* cascadeencoding_;
    int kind_;
    uint32_t dictionarysize_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pixels_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FileTail

// optional .pixels.proto.Footer footer = 1;
inline bool FileTail::_internal_has_footer() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.footer_ != nullptr);
  return value;
}
inline bool FileTail::has_footer() const {
  return _internal_has_footer();
}
inline void FileTail::clear_footer() {
  if (_impl_.footer_ != nullptr) _impl_.footer_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::pixels::proto::Footer& FileTail::_internal_footer() const {
  const ::pixels::proto::Footer* p = _impl_.footer_;
  return p != nullptr ? *p : reinterpret_cast<const ::pixels::proto::Footer&>(
      ::pixels::proto::_Footer_default_instance_);
}
inline const ::pixels::proto::Footer& FileTail::footer() const {
  // @@protoc_insertion_point(field_get:pixels.proto.FileTail.footer)
  return _internal_footer();
}
inline void FileTail::unsafe_arena_set_allocated_footer(
    ::pixels::proto::Footer* footer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.footer_);
  }
  _impl_.footer_ = footer;
  if (footer) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pixels.proto.FileTail.footer)
}
inline ::pixels::proto::Footer* FileTail::release_footer() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pixels::proto::Footer* temp = _impl_.footer_;
  _impl_.footer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pixels::proto::Footer* FileTail::unsafe_arena_release_footer() {
  // @@protoc_insertion_point(field_release:pixels.proto.FileTail.footer)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pixels::proto::Footer* temp = _impl_.footer_;
  _impl_.footer_ = nullptr;
  return temp;
}
inline ::pixels::proto::Footer* FileTail::_internal_mutable_footer() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.footer_ == nullptr) {
    auto* p = CreateMaybeMessage<::pixels::proto::Footer>(GetArenaForAllocation());
    _impl_.footer_ = p;
  }
  return _impl_.footer_;
}
inline ::pixels::proto::Footer* FileTail::mutable_footer() {
  ::pixels::proto::Footer* _msg = _internal_mutable_footer();
  // @@protoc_insertion_point(field_mutable:pixels.proto.FileTail.footer)
  return _msg;
}
inline void FileTail::set_allocated_footer(::pixels::proto::Footer* footer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.footer_;
  }
  if (footer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(footer);
    if (message_arena != submessage_arena) {
      footer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, footer, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.footer_ = footer;
  // @@protoc_insertion_point(field_set_allocated:pixels.proto.FileTail.footer)
}

// optional .pixels.proto.PostScript postscript = 2;
inline bool FileTail::_internal_has_postscript() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.postscript_ != nullptr);
  return value;
}
inline bool FileTail::has_postscript() const {
  return _internal_has_postscript();
}
inline void FileTail::clear_postscript() {
  if (_impl_.postscript_ != nullptr) _impl_.postscript_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::pixels::proto::PostScript& FileTail::_internal_postscript() const {
  const ::pixels::proto::PostScript* p = _impl_.postscript_;
  return p != nullptr ? *p : reinterpret_cast<const ::pixels::proto::PostScript&>(
      ::pixels::proto::_PostScript_default_instance_);
}
inline const ::pixels::proto::PostScript& FileTail::postscript() const {
  // @@protoc_insertion_point(field_get:pixels.proto.FileTail.postscript)
  return _internal_postscript();
}
inline void FileTail::unsafe_arena_set_allocated_postscript(
    ::pixels::proto::PostScript* postscript) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.postscript_);
  }
  _impl_.postscript_ = postscript;
  if (postscript) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pixels.proto.FileTail.postscript)
}
inline ::pixels::proto::PostScript* FileTail::release_postscript() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::pixels::proto::PostScript* temp = _impl_.postscript_;
  _impl_.postscript_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pixels::proto::PostScript* FileTail::unsafe_arena_release_postscript() {
  // @@protoc_insertion_point(field_release:pixels.proto.FileTail.postscript)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::pixels::proto::PostScript* temp = _impl_.postscript_;
  _impl_.postscript_ = nullptr;
  return temp;
}
inline ::pixels::proto::PostScript* FileTail::_internal_mutable_postscript() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.postscript_ == nullptr) {
    auto* p = CreateMaybeMessage<::pixels::proto::PostScript>(GetArenaForAllocation());
    _impl_.postscript_ = p;
  }
  return _impl_.postscript_;
}
inline ::pixels::proto::PostScript* FileTail::mutable_postscript() {
  ::pixels::proto::PostScript* _msg = _internal_mutable_postscript();
  // @@protoc_insertion_point(field_mutable:pixels.proto.FileTail.postscript)
  return _msg;
}
inline void FileTail::set_allocated_postscript(::pixels::proto::PostScript* postscript) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.postscript_;
  }
  if (postscript) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(postscript);
    if (message_arena != submessage_arena) {
      postscript = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, postscript, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.postscript_ = postscript;
  // @@protoc_insertion_point(field_set_allocated:pixels.proto.FileTail.postscript)
}

// optional uint32 footerLength = 3;
inline bool FileTail::_internal_has_footerlength() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FileTail::has_footerlength() const {
  return _internal_has_footerlength();
}
inline void FileTail::clear_footerlength() {
  _impl_.footerlength_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t FileTail::_internal_footerlength() const {
  return _impl_.footerlength_;
}
inline uint32_t FileTail::footerlength() const {
  // @@protoc_insertion_point(field_get:pixels.proto.FileTail.footerLength)
  return _internal_footerlength();
}
inline void FileTail::_internal_set_footerlength(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.footerlength_ = value;
}
inline void FileTail::set_footerlength(uint32_t value) {
  _internal_set_footerlength(value);
  // @@protoc_insertion_point(field_set:pixels.proto.FileTail.footerLength)
}

// optional uint32 postscriptLength = 4;
inline bool FileTail::_internal_has_postscriptlength() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FileTail::has_postscriptlength() const {
  return _internal_has_postscriptlength();
}
inline void FileTail::clear_postscriptlength() {
  _impl_.postscriptlength_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t FileTail::_internal_postscriptlength() const {
  return _impl_.postscriptlength_;
}
inline uint32_t FileTail::postscriptlength() const {
  // @@protoc_insertion_point(field_get:pixels.proto.FileTail.postscriptLength)
  return _internal_postscriptlength();
}
inline void FileTail::_internal_set_postscriptlength(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.postscriptlength_ = value;
}
inline void FileTail::set_postscriptlength(uint32_t value) {
  _internal_set_postscriptlength(value);
  // @@protoc_insertion_point(field_set:pixels.proto.FileTail.postscriptLength)
}

// -------------------------------------------------------------------

// PostScript

// optional uint32 version = 1;
inline bool PostScript::_internal_has_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PostScript::has_version() const {
  return _internal_has_version();
}
inline void PostScript::clear_version() {
  _impl_.version_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t PostScript::_internal_version() const {
  return _impl_.version_;
}
inline uint32_t PostScript::version() const {
  // @@protoc_insertion_point(field_get:pixels.proto.PostScript.version)
  return _internal_version();
}
inline void PostScript::_internal_set_version(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.version_ = value;
}
inline void PostScript::set_version(uint32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:pixels.proto.PostScript.version)
}

// optional uint64 contentLength = 2;
inline bool PostScript::_internal_has_contentlength() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PostScript::has_contentlength() const {
  return _internal_has_contentlength();
}
inline void PostScript::clear_contentlength() {
  _impl_.contentlength_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint64_t PostScript::_internal_contentlength() const {
  return _impl_.contentlength_;
}
inline uint64_t PostScript::contentlength() const {
  // @@protoc_insertion_point(field_get:pixels.proto.PostScript.contentLength)
  return _internal_contentlength();
}
inline void PostScript::_internal_set_contentlength(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.contentlength_ = value;
}
inline void PostScript::set_contentlength(uint64_t value) {
  _internal_set_contentlength(value);
  // @@protoc_insertion_point(field_set:pixels.proto.PostScript.contentLength)
}

// optional uint32 numberOfRows = 3;
inline bool PostScript::_internal_has_numberofrows() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PostScript::has_numberofrows() const {
  return _internal_has_numberofrows();
}
inline void PostScript::clear_numberofrows() {
  _impl_.numberofrows_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t PostScript::_internal_numberofrows() const {
  return _impl_.numberofrows_;
}
inline uint32_t PostScript::numberofrows() const {
  // @@protoc_insertion_point(field_get:pixels.proto.PostScript.numberOfRows)
  return _internal_numberofrows();
}
inline void PostScript::_internal_set_numberofrows(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.numberofrows_ = value;
}
inline void PostScript::set_numberofrows(uint32_t value) {
  _internal_set_numberofrows(value);
  // @@protoc_insertion_point(field_set:pixels.proto.PostScript.numberOfRows)
}

// optional .pixels.proto.CompressionKind compression = 4;
inline bool PostScript::_internal_has_compression() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PostScript::has_compression() const {
  return _internal_has_compression();
}
inline void PostScript::clear_compression() {
  _impl_.compression_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::pixels::proto::CompressionKind PostScript::_internal_compression() const {
  return static_cast< ::pixels::proto::CompressionKind >(_impl_.compression_);
}
inline ::pixels::proto::CompressionKind PostScript::compression() const {
  // @@protoc_insertion_point(field_get:pixels.proto.PostScript.compression)
  return _internal_compression();
}
inline void PostScript::_internal_set_compression(::pixels::proto::CompressionKind value) {
  assert(::pixels::proto::CompressionKind_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.compression_ = value;
}
inline void PostScript::set_compression(::pixels::proto::CompressionKind value) {
  _internal_set_compression(value);
  // @@protoc_insertion_point(field_set:pixels.proto.PostScript.compression)
}

// optional uint32 compressionBlockSize = 5;
inline bool PostScript::_internal_has_compressionblocksize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PostScript::has_compressionblocksize() const {
  return _internal_has_compressionblocksize();
}
inline void PostScript::clear_compressionblocksize() {
  _impl_.compressionblocksize_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t PostScript::_internal_compressionblocksize() const {
  return _impl_.compressionblocksize_;
}
inline uint32_t PostScript::compressionblocksize() const {
  // @@protoc_insertion_point(field_get:pixels.proto.PostScript.compressionBlockSize)
  return _internal_compressionblocksize();
}
inline void PostScript::_internal_set_compressionblocksize(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.compressionblocksize_ = value;
}
inline void PostScript::set_compressionblocksize(uint32_t value) {
  _internal_set_compressionblocksize(value);
  // @@protoc_insertion_point(field_set:pixels.proto.PostScript.compressionBlockSize)
}

// optional uint32 pixelStride = 6;
inline bool PostScript::_internal_has_pixelstride() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool PostScript::has_pixelstride() const {
  return _internal_has_pixelstride();
}
inline void PostScript::clear_pixelstride() {
  _impl_.pixelstride_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t PostScript::_internal_pixelstride() const {
  return _impl_.pixelstride_;
}
inline uint32_t PostScript::pixelstride() const {
  // @@protoc_insertion_point(field_get:pixels.proto.PostScript.pixelStride)
  return _internal_pixelstride();
}
inline void PostScript::_internal_set_pixelstride(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.pixelstride_ = value;
}
inline void PostScript::set_pixelstride(uint32_t value) {
  _internal_set_pixelstride(value);
  // @@protoc_insertion_point(field_set:pixels.proto.PostScript.pixelStride)
}

// optional string writerTimezone = 7;
inline bool PostScript::_internal_has_writertimezone() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PostScript::has_writertimezone() const {
  return _internal_has_writertimezone();
}
inline void PostScript::clear_writertimezone() {
  _impl_.writertimezone_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PostScript::writertimezone() const {
  // @@protoc_insertion_point(field_get:pixels.proto.PostScript.writerTimezone)
  return _internal_writertimezone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostScript::set_writertimezone(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.writertimezone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pixels.proto.PostScript.writerTimezone)
}
inline std::string* PostScript::mutable_writertimezone() {
  std::string* _s = _internal_mutable_writertimezone();
  // @@protoc_insertion_point(field_mutable:pixels.proto.PostScript.writerTimezone)
  return _s;
}
inline const std::string& PostScript::_internal_writertimezone() const {
  return _impl_.writertimezone_.Get();
}
inline void PostScript::_internal_set_writertimezone(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.writertimezone_.Set(value, GetArenaForAllocation());
}
inline std::string* PostScript::_internal_mutable_writertimezone() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.writertimezone_.Mutable(GetArenaForAllocation());
}
inline std::string* PostScript::release_writertimezone() {
  // @@protoc_insertion_point(field_release:pixels.proto.PostScript.writerTimezone)
  if (!_internal_has_writertimezone()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.writertimezone_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.writertimezone_.IsDefault()) {
    _impl_.writertimezone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PostScript::set_allocated_writertimezone(std::string* writertimezone) {
  if (writertimezone != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.writertimezone_.SetAllocated(writertimezone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.writertimezone_.IsDefault()) {
    _impl_.writertimezone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pixels.proto.PostScript.writerTimezone)
}

// optional bool partitioned = 8;
inline bool PostScript::_internal_has_partitioned() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool PostScript::has_partitioned() const {
  return _internal_has_partitioned();
}
inline void PostScript::clear_partitioned() {
  _impl_.partitioned_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool PostScript::_internal_partitioned() const {
  return _impl_.partitioned_;
}
inline bool PostScript::partitioned() const {
  // @@protoc_insertion_point(field_get:pixels.proto.PostScript.partitioned)
  return _internal_partitioned();
}
inline void PostScript::_internal_set_partitioned(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.partitioned_ = value;
}
inline void PostScript::set_partitioned(bool value) {
  _internal_set_partitioned(value);
  // @@protoc_insertion_point(field_set:pixels.proto.PostScript.partitioned)
}

// optional uint32 columnChunkAlignment = 9;
inline bool PostScript::_internal_has_columnchunkalignment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool PostScript::has_columnchunkalignment() const {
  return _internal_has_columnchunkalignment();
}
inline void PostScript::clear_columnchunkalignment() {
  _impl_.columnchunkalignment_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint32_t PostScript::_internal_columnchunkalignment() const {
  return _impl_.columnchunkalignment_;
}
inline uint32_t PostScript::columnchunkalignment() const {
  // @@protoc_insertion_point(field_get:pixels.proto.PostScript.columnChunkAlignment)
  return _internal_columnchunkalignment();
}
inline void PostScript::_internal_set_columnchunkalignment(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.columnchunkalignment_ = value;
}
inline void PostScript::set_columnchunkalignment(uint32_t value) {
  _internal_set_columnchunkalignment(value);
  // @@protoc_insertion_point(field_set:pixels.proto.PostScript.columnChunkAlignment)
}

// optional string magic = 8000;
inline bool PostScript::_internal_has_magic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PostScript::has_magic() const {
  return _internal_has_magic();
}
inline void PostScript::clear_magic() {
  _impl_.magic_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PostScript::magic() const {
  // @@protoc_insertion_point(field_get:pixels.proto.PostScript.magic)
  return _internal_magic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PostScript::set_magic(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.magic_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pixels.proto.PostScript.magic)
}
inline std::string* PostScript::mutable_magic() {
  std::string* _s = _internal_mutable_magic();
  // @@protoc_insertion_point(field_mutable:pixels.proto.PostScript.magic)
  return _s;
}
inline const std::string& PostScript::_internal_magic() const {
  return _impl_.magic_.Get();
}
inline void PostScript::_internal_set_magic(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.magic_.Set(value, GetArenaForAllocation());
}
inline std::string* PostScript::_internal_mutable_magic() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.magic_.Mutable(GetArenaForAllocation());
}
inline std::string* PostScript::release_magic() {
  // @@protoc_insertion_point(field_release:pixels.proto.PostScript.magic)
  if (!_internal_has_magic()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.magic_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.magic_.IsDefault()) {
    _impl_.magic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PostScript::set_allocated_magic(std::string* magic) {
  if (magic != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.magic_.SetAllocated(magic, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.magic_.IsDefault()) {
    _impl_.magic_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pixels.proto.PostScript.magic)
}

// -------------------------------------------------------------------

// Footer

// repeated .pixels.proto.Type types = 1;
inline int Footer::_internal_types_size() const {
  return _impl_.types_.size();
}
inline int Footer::types_size() const {
  return _internal_types_size();
}
inline void Footer::clear_types() {
  _impl_.types_.Clear();
}
inline ::pixels::proto::Type* Footer::mutable_types(int index) {
  // @@protoc_insertion_point(field_mutable:pixels.proto.Footer.types)
  return _impl_.types_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::Type >*
Footer::mutable_types() {
  // @@protoc_insertion_point(field_mutable_list:pixels.proto.Footer.types)
  return &_impl_.types_;
}
inline const ::pixels::proto::Type& Footer::_internal_types(int index) const {
  return _impl_.types_.Get(index);
}
inline const ::pixels::proto::Type& Footer::types(int index) const {
  // @@protoc_insertion_point(field_get:pixels.proto.Footer.types)
  return _internal_types(index);
}
inline ::pixels::proto::Type* Footer::_internal_add_types() {
  return _impl_.types_.Add();
}
inline ::pixels::proto::Type* Footer::add_types() {
  ::pixels::proto::Type* _add = _internal_add_types();
  // @@protoc_insertion_point(field_add:pixels.proto.Footer.types)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::Type >&
Footer::types() const {
  // @@protoc_insertion_point(field_list:pixels.proto.Footer.types)
  return _impl_.types_;
}

// repeated .pixels.proto.ColumnStatistic columnStats = 2;
inline int Footer::_internal_columnstats_size() const {
  return _impl_.columnstats_.size();
}
inline int Footer::columnstats_size() const {
  return _internal_columnstats_size();
}
inline void Footer::clear_columnstats() {
  _impl_.columnstats_.Clear();
}
inline ::pixels::proto::ColumnStatistic* Footer::mutable_columnstats(int index) {
  // @@protoc_insertion_point(field_mutable:pixels.proto.Footer.columnStats)
  return _impl_.columnstats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::ColumnStatistic >*
Footer::mutable_columnstats() {
  // @@protoc_insertion_point(field_mutable_list:pixels.proto.Footer.columnStats)
  return &_impl_.columnstats_;
}
inline const ::pixels::proto::ColumnStatistic& Footer::_internal_columnstats(int index) const {
  return _impl_.columnstats_.Get(index);
}
inline const ::pixels::proto::ColumnStatistic& Footer::columnstats(int index) const {
  // @@protoc_insertion_point(field_get:pixels.proto.Footer.columnStats)
  return _internal_columnstats(index);
}
inline ::pixels::proto::ColumnStatistic* Footer::_internal_add_columnstats() {
  return _impl_.columnstats_.Add();
}
inline ::pixels::proto::ColumnStatistic* Footer::add_columnstats() {
  ::pixels::proto::ColumnStatistic* _add = _internal_add_columnstats();
  // @@protoc_insertion_point(field_add:pixels.proto.Footer.columnStats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::ColumnStatistic >&
Footer::columnstats() const {
  // @@protoc_insertion_point(field_list:pixels.proto.Footer.columnStats)
  return _impl_.columnstats_;
}

// repeated .pixels.proto.RowGroupInformation rowGroupInfos = 3;
inline int Footer::_internal_rowgroupinfos_size() const {
  return _impl_.rowgroupinfos_.size();
}
inline int Footer::rowgroupinfos_size() const {
  return _internal_rowgroupinfos_size();
}
inline void Footer::clear_rowgroupinfos() {
  _impl_.rowgroupinfos_.Clear();
}
inline ::pixels::proto::RowGroupInformation* Footer::mutable_rowgroupinfos(int index) {
  // @@protoc_insertion_point(field_mutable:pixels.proto.Footer.rowGroupInfos)
  return _impl_.rowgroupinfos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::RowGroupInformation >*
Footer::mutable_rowgroupinfos() {
  // @@protoc_insertion_point(field_mutable_list:pixels.proto.Footer.rowGroupInfos)
  return &_impl_.rowgroupinfos_;
}
inline const ::pixels::proto::RowGroupInformation& Footer::_internal_rowgroupinfos(int index) const {
  return _impl_.rowgroupinfos_.Get(index);
}
inline const ::pixels::proto::RowGroupInformation& Footer::rowgroupinfos(int index) const {
  // @@protoc_insertion_point(field_get:pixels.proto.Footer.rowGroupInfos)
  return _internal_rowgroupinfos(index);
}
inline ::pixels::proto::RowGroupInformation* Footer::_internal_add_rowgroupinfos() {
  return _impl_.rowgroupinfos_.Add();
}
inline ::pixels::proto::RowGroupInformation* Footer::add_rowgroupinfos() {
  ::pixels::proto::RowGroupInformation* _add = _internal_add_rowgroupinfos();
  // @@protoc_insertion_point(field_add:pixels.proto.Footer.rowGroupInfos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::RowGroupInformation >&
Footer::rowgroupinfos() const {
  // @@protoc_insertion_point(field_list:pixels.proto.Footer.rowGroupInfos)
  return _impl_.rowgroupinfos_;
}

// repeated .pixels.proto.RowGroupStatistic rowGroupStats = 4;
inline int Footer::_internal_rowgroupstats_size() const {
  return _impl_.rowgroupstats_.size();
}
inline int Footer::rowgroupstats_size() const {
  return _internal_rowgroupstats_size();
}
inline void Footer::clear_rowgroupstats() {
  _impl_.rowgroupstats_.Clear();
}
inline ::pixels::proto::RowGroupStatistic* Footer::mutable_rowgroupstats(int index) {
  // @@protoc_insertion_point(field_mutable:pixels.proto.Footer.rowGroupStats)
  return _impl_.rowgroupstats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::RowGroupStatistic >*
Footer::mutable_rowgroupstats() {
  // @@protoc_insertion_point(field_mutable_list:pixels.proto.Footer.rowGroupStats)
  return &_impl_.rowgroupstats_;
}
inline const ::pixels::proto::RowGroupStatistic& Footer::_internal_rowgroupstats(int index) const {
  return _impl_.rowgroupstats_.Get(index);
}
inline const ::pixels::proto::RowGroupStatistic& Footer::rowgroupstats(int index) const {
  // @@protoc_insertion_point(field_get:pixels.proto.Footer.rowGroupStats)
  return _internal_rowgroupstats(index);
}
inline ::pixels::proto::RowGroupStatistic* Footer::_internal_add_rowgroupstats() {
  return _impl_.rowgroupstats_.Add();
}
inline ::pixels::proto::RowGroupStatistic* Footer::add_rowgroupstats() {
  ::pixels::proto::RowGroupStatistic* _add = _internal_add_rowgroupstats();
  // @@protoc_insertion_point(field_add:pixels.proto.Footer.rowGroupStats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::RowGroupStatistic >&
Footer::rowgroupstats() const {
  // @@protoc_insertion_point(field_list:pixels.proto.Footer.rowGroupStats)
  return _impl_.rowgroupstats_;
}

// -------------------------------------------------------------------

// Type

// optional .pixels.proto.Type.Kind kind = 1;
inline bool Type::_internal_has_kind() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Type::has_kind() const {
  return _internal_has_kind();
}
inline void Type::clear_kind() {
  _impl_.kind_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::pixels::proto::Type_Kind Type::_internal_kind() const {
  return static_cast< ::pixels::proto::Type_Kind >(_impl_.kind_);
}
inline ::pixels::proto::Type_Kind Type::kind() const {
  // @@protoc_insertion_point(field_get:pixels.proto.Type.kind)
  return _internal_kind();
}
inline void Type::_internal_set_kind(::pixels::proto::Type_Kind value) {
  assert(::pixels::proto::Type_Kind_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.kind_ = value;
}
inline void Type::set_kind(::pixels::proto::Type_Kind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:pixels.proto.Type.kind)
}

// optional string name = 2;
inline bool Type::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Type::has_name() const {
  return _internal_has_name();
}
inline void Type::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Type::name() const {
  // @@protoc_insertion_point(field_get:pixels.proto.Type.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Type::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pixels.proto.Type.name)
}
inline std::string* Type::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:pixels.proto.Type.name)
  return _s;
}
inline const std::string& Type::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Type::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Type::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Type::release_name() {
  // @@protoc_insertion_point(field_release:pixels.proto.Type.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Type::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pixels.proto.Type.name)
}

// repeated uint32 subtypes = 3 [packed = true];
inline int Type::_internal_subtypes_size() const {
  return _impl_.subtypes_.size();
}
inline int Type::subtypes_size() const {
  return _internal_subtypes_size();
}
inline void Type::clear_subtypes() {
  _impl_.subtypes_.Clear();
}
inline uint32_t Type::_internal_subtypes(int index) const {
  return _impl_.subtypes_.Get(index);
}
inline uint32_t Type::subtypes(int index) const {
  // @@protoc_insertion_point(field_get:pixels.proto.Type.subtypes)
  return _internal_subtypes(index);
}
inline void Type::set_subtypes(int index, uint32_t value) {
  _impl_.subtypes_.Set(index, value);
  // @@protoc_insertion_point(field_set:pixels.proto.Type.subtypes)
}
inline void Type::_internal_add_subtypes(uint32_t value) {
  _impl_.subtypes_.Add(value);
}
inline void Type::add_subtypes(uint32_t value) {
  _internal_add_subtypes(value);
  // @@protoc_insertion_point(field_add:pixels.proto.Type.subtypes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Type::_internal_subtypes() const {
  return _impl_.subtypes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Type::subtypes() const {
  // @@protoc_insertion_point(field_list:pixels.proto.Type.subtypes)
  return _internal_subtypes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Type::_internal_mutable_subtypes() {
  return &_impl_.subtypes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Type::mutable_subtypes() {
  // @@protoc_insertion_point(field_mutable_list:pixels.proto.Type.subtypes)
  return _internal_mutable_subtypes();
}

// optional uint32 maximumLength = 4;
inline bool Type::_internal_has_maximumlength() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Type::has_maximumlength() const {
  return _internal_has_maximumlength();
}
inline void Type::clear_maximumlength() {
  _impl_.maximumlength_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t Type::_internal_maximumlength() const {
  return _impl_.maximumlength_;
}
inline uint32_t Type::maximumlength() const {
  // @@protoc_insertion_point(field_get:pixels.proto.Type.maximumLength)
  return _internal_maximumlength();
}
inline void Type::_internal_set_maximumlength(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.maximumlength_ = value;
}
inline void Type::set_maximumlength(uint32_t value) {
  _internal_set_maximumlength(value);
  // @@protoc_insertion_point(field_set:pixels.proto.Type.maximumLength)
}

// optional uint32 precision = 5;
inline bool Type::_internal_has_precision() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Type::has_precision() const {
  return _internal_has_precision();
}
inline void Type::clear_precision() {
  _impl_.precision_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t Type::_internal_precision() const {
  return _impl_.precision_;
}
inline uint32_t Type::precision() const {
  // @@protoc_insertion_point(field_get:pixels.proto.Type.precision)
  return _internal_precision();
}
inline void Type::_internal_set_precision(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.precision_ = value;
}
inline void Type::set_precision(uint32_t value) {
  _internal_set_precision(value);
  // @@protoc_insertion_point(field_set:pixels.proto.Type.precision)
}

// optional uint32 scale = 6;
inline bool Type::_internal_has_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Type::has_scale() const {
  return _internal_has_scale();
}
inline void Type::clear_scale() {
  _impl_.scale_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t Type::_internal_scale() const {
  return _impl_.scale_;
}
inline uint32_t Type::scale() const {
  // @@protoc_insertion_point(field_get:pixels.proto.Type.scale)
  return _internal_scale();
}
inline void Type::_internal_set_scale(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.scale_ = value;
}
inline void Type::set_scale(uint32_t value) {
  _internal_set_scale(value);
  // @@protoc_insertion_point(field_set:pixels.proto.Type.scale)
}

// optional uint32 dimension = 7;
inline bool Type::_internal_has_dimension() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Type::has_dimension() const {
  return _internal_has_dimension();
}
inline void Type::clear_dimension() {
  _impl_.dimension_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t Type::_internal_dimension() const {
  return _impl_.dimension_;
}
inline uint32_t Type::dimension() const {
  // @@protoc_insertion_point(field_get:pixels.proto.Type.dimension)
  return _internal_dimension();
}
inline void Type::_internal_set_dimension(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.dimension_ = value;
}
inline void Type::set_dimension(uint32_t value) {
  _internal_set_dimension(value);
  // @@protoc_insertion_point(field_set:pixels.proto.Type.dimension)
}

// -------------------------------------------------------------------

// PartitionInformation

// repeated uint32 columnIds = 1;
inline int PartitionInformation::_internal_columnids_size() const {
  return _impl_.columnids_.size();
}
inline int PartitionInformation::columnids_size() const {
  return _internal_columnids_size();
}
inline void PartitionInformation::clear_columnids() {
  _impl_.columnids_.Clear();
}
inline uint32_t PartitionInformation::_internal_columnids(int index) const {
  return _impl_.columnids_.Get(index);
}
inline uint32_t PartitionInformation::columnids(int index) const {
  // @@protoc_insertion_point(field_get:pixels.proto.PartitionInformation.columnIds)
  return _internal_columnids(index);
}
inline void PartitionInformation::set_columnids(int index, uint32_t value) {
  _impl_.columnids_.Set(index, value);
  // @@protoc_insertion_point(field_set:pixels.proto.PartitionInformation.columnIds)
}
inline void PartitionInformation::_internal_add_columnids(uint32_t value) {
  _impl_.columnids_.Add(value);
}
inline void PartitionInformation::add_columnids(uint32_t value) {
  _internal_add_columnids(value);
  // @@protoc_insertion_point(field_add:pixels.proto.PartitionInformation.columnIds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
PartitionInformation::_internal_columnids() const {
  return _impl_.columnids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
PartitionInformation::columnids() const {
  // @@protoc_insertion_point(field_list:pixels.proto.PartitionInformation.columnIds)
  return _internal_columnids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
PartitionInformation::_internal_mutable_columnids() {
  return &_impl_.columnids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
PartitionInformation::mutable_columnids() {
  // @@protoc_insertion_point(field_mutable_list:pixels.proto.PartitionInformation.columnIds)
  return _internal_mutable_columnids();
}

// optional int32 hashValue = 2;
inline bool PartitionInformation::_internal_has_hashvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PartitionInformation::has_hashvalue() const {
  return _internal_has_hashvalue();
}
inline void PartitionInformation::clear_hashvalue() {
  _impl_.hashvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t PartitionInformation::_internal_hashvalue() const {
  return _impl_.hashvalue_;
}
inline int32_t PartitionInformation::hashvalue() const {
  // @@protoc_insertion_point(field_get:pixels.proto.PartitionInformation.hashValue)
  return _internal_hashvalue();
}
inline void PartitionInformation::_internal_set_hashvalue(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.hashvalue_ = value;
}
inline void PartitionInformation::set_hashvalue(int32_t value) {
  _internal_set_hashvalue(value);
  // @@protoc_insertion_point(field_set:pixels.proto.PartitionInformation.hashValue)
}

// -------------------------------------------------------------------

// RowGroupInformation

// optional uint64 footerOffset = 1;
inline bool RowGroupInformation::_internal_has_footeroffset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RowGroupInformation::has_footeroffset() const {
  return _internal_has_footeroffset();
}
inline void RowGroupInformation::clear_footeroffset() {
  _impl_.footeroffset_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t RowGroupInformation::_internal_footeroffset() const {
  return _impl_.footeroffset_;
}
inline uint64_t RowGroupInformation::footeroffset() const {
  // @@protoc_insertion_point(field_get:pixels.proto.RowGroupInformation.footerOffset)
  return _internal_footeroffset();
}
inline void RowGroupInformation::_internal_set_footeroffset(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.footeroffset_ = value;
}
inline void RowGroupInformation::set_footeroffset(uint64_t value) {
  _internal_set_footeroffset(value);
  // @@protoc_insertion_point(field_set:pixels.proto.RowGroupInformation.footerOffset)
}

// optional uint32 dataLength = 2;
inline bool RowGroupInformation::_internal_has_datalength() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RowGroupInformation::has_datalength() const {
  return _internal_has_datalength();
}
inline void RowGroupInformation::clear_datalength() {
  _impl_.datalength_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t RowGroupInformation::_internal_datalength() const {
  return _impl_.datalength_;
}
inline uint32_t RowGroupInformation::datalength() const {
  // @@protoc_insertion_point(field_get:pixels.proto.RowGroupInformation.dataLength)
  return _internal_datalength();
}
inline void RowGroupInformation::_internal_set_datalength(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.datalength_ = value;
}
inline void RowGroupInformation::set_datalength(uint32_t value) {
  _internal_set_datalength(value);
  // @@protoc_insertion_point(field_set:pixels.proto.RowGroupInformation.dataLength)
}

// optional uint32 footerLength = 3;
inline bool RowGroupInformation::_internal_has_footerlength() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RowGroupInformation::has_footerlength() const {
  return _internal_has_footerlength();
}
inline void RowGroupInformation::clear_footerlength() {
  _impl_.footerlength_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t RowGroupInformation::_internal_footerlength() const {
  return _impl_.footerlength_;
}
inline uint32_t RowGroupInformation::footerlength() const {
  // @@protoc_insertion_point(field_get:pixels.proto.RowGroupInformation.footerLength)
  return _internal_footerlength();
}
inline void RowGroupInformation::_internal_set_footerlength(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.footerlength_ = value;
}
inline void RowGroupInformation::set_footerlength(uint32_t value) {
  _internal_set_footerlength(value);
  // @@protoc_insertion_point(field_set:pixels.proto.RowGroupInformation.footerLength)
}

// optional uint64 numberOfRows = 4;
inline bool RowGroupInformation::_internal_has_numberofrows() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RowGroupInformation::has_numberofrows() const {
  return _internal_has_numberofrows();
}
inline void RowGroupInformation::clear_numberofrows() {
  _impl_.numberofrows_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint64_t RowGroupInformation::_internal_numberofrows() const {
  return _impl_.numberofrows_;
}
inline uint64_t RowGroupInformation::numberofrows() const {
  // @@protoc_insertion_point(field_get:pixels.proto.RowGroupInformation.numberOfRows)
  return _internal_numberofrows();
}
inline void RowGroupInformation::_internal_set_numberofrows(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.numberofrows_ = value;
}
inline void RowGroupInformation::set_numberofrows(uint64_t value) {
  _internal_set_numberofrows(value);
  // @@protoc_insertion_point(field_set:pixels.proto.RowGroupInformation.numberOfRows)
}

// optional .pixels.proto.PartitionInformation partitionInfo = 5;
inline bool RowGroupInformation::_internal_has_partitioninfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.partitioninfo_ != nullptr);
  return value;
}
inline bool RowGroupInformation::has_partitioninfo() const {
  return _internal_has_partitioninfo();
}
inline void RowGroupInformation::clear_partitioninfo() {
  if (_impl_.partitioninfo_ != nullptr) _impl_.partitioninfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::pixels::proto::PartitionInformation& RowGroupInformation::_internal_partitioninfo() const {
  const ::pixels::proto::PartitionInformation* p = _impl_.partitioninfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::pixels::proto::PartitionInformation&>(
      ::pixels::proto::_PartitionInformation_default_instance_);
}
inline const ::pixels::proto::PartitionInformation& RowGroupInformation::partitioninfo() const {
  // @@protoc_insertion_point(field_get:pixels.proto.RowGroupInformation.partitionInfo)
  return _internal_partitioninfo();
}
inline void RowGroupInformation::unsafe_arena_set_allocated_partitioninfo(
    ::pixels::proto::PartitionInformation* partitioninfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.partitioninfo_);
  }
  _impl_.partitioninfo_ = partitioninfo;
  if (partitioninfo) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pixels.proto.RowGroupInformation.partitionInfo)
}
inline ::pixels::proto::PartitionInformation* RowGroupInformation::release_partitioninfo() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pixels::proto::PartitionInformation* temp = _impl_.partitioninfo_;
  _impl_.partitioninfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pixels::proto::PartitionInformation* RowGroupInformation::unsafe_arena_release_partitioninfo() {
  // @@protoc_insertion_point(field_release:pixels.proto.RowGroupInformation.partitionInfo)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pixels::proto::PartitionInformation* temp = _impl_.partitioninfo_;
  _impl_.partitioninfo_ = nullptr;
  return temp;
}
inline ::pixels::proto::PartitionInformation* RowGroupInformation::_internal_mutable_partitioninfo() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.partitioninfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::pixels::proto::PartitionInformation>(GetArenaForAllocation());
    _impl_.partitioninfo_ = p;
  }
  return _impl_.partitioninfo_;
}
inline ::pixels::proto::PartitionInformation* RowGroupInformation::mutable_partitioninfo() {
  ::pixels::proto::PartitionInformation* _msg = _internal_mutable_partitioninfo();
  // @@protoc_insertion_point(field_mutable:pixels.proto.RowGroupInformation.partitionInfo)
  return _msg;
}
inline void RowGroupInformation::set_allocated_partitioninfo(::pixels::proto::PartitionInformation* partitioninfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.partitioninfo_;
  }
  if (partitioninfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(partitioninfo);
    if (message_arena != submessage_arena) {
      partitioninfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, partitioninfo, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.partitioninfo_ = partitioninfo;
  // @@protoc_insertion_point(field_set_allocated:pixels.proto.RowGroupInformation.partitionInfo)
}

// -------------------------------------------------------------------

// RowGroupStatistic

// repeated .pixels.proto.ColumnStatistic columnChunkStats = 1;
inline int RowGroupStatistic::_internal_columnchunkstats_size() const {
  return _impl_.columnchunkstats_.size();
}
inline int RowGroupStatistic::columnchunkstats_size() const {
  return _internal_columnchunkstats_size();
}
inline void RowGroupStatistic::clear_columnchunkstats() {
  _impl_.columnchunkstats_.Clear();
}
inline ::pixels::proto::ColumnStatistic* RowGroupStatistic::mutable_columnchunkstats(int index) {
  // @@protoc_insertion_point(field_mutable:pixels.proto.RowGroupStatistic.columnChunkStats)
  return _impl_.columnchunkstats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::ColumnStatistic >*
RowGroupStatistic::mutable_columnchunkstats() {
  // @@protoc_insertion_point(field_mutable_list:pixels.proto.RowGroupStatistic.columnChunkStats)
  return &_impl_.columnchunkstats_;
}
inline const ::pixels::proto::ColumnStatistic& RowGroupStatistic::_internal_columnchunkstats(int index) const {
  return _impl_.columnchunkstats_.Get(index);
}
inline const ::pixels::proto::ColumnStatistic& RowGroupStatistic::columnchunkstats(int index) const {
  // @@protoc_insertion_point(field_get:pixels.proto.RowGroupStatistic.columnChunkStats)
  return _internal_columnchunkstats(index);
}
inline ::pixels::proto::ColumnStatistic* RowGroupStatistic::_internal_add_columnchunkstats() {
  return _impl_.columnchunkstats_.Add();
}
inline ::pixels::proto::ColumnStatistic* RowGroupStatistic::add_columnchunkstats() {
  ::pixels::proto::ColumnStatistic* _add = _internal_add_columnchunkstats();
  // @@protoc_insertion_point(field_add:pixels.proto.RowGroupStatistic.columnChunkStats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::ColumnStatistic >&
RowGroupStatistic::columnchunkstats() const {
  // @@protoc_insertion_point(field_list:pixels.proto.RowGroupStatistic.columnChunkStats)
  return _impl_.columnchunkstats_;
}

// -------------------------------------------------------------------

// IntegerStatistic

// optional sint64 minimum = 1;
inline bool IntegerStatistic::_internal_has_minimum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool IntegerStatistic::has_minimum() const {
  return _internal_has_minimum();
}
inline void IntegerStatistic::clear_minimum() {
  _impl_.minimum_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t IntegerStatistic::_internal_minimum() const {
  return _impl_.minimum_;
}
inline int64_t IntegerStatistic::minimum() const {
  // @@protoc_insertion_point(field_get:pixels.proto.IntegerStatistic.minimum)
  return _internal_minimum();
}
inline void IntegerStatistic::_internal_set_minimum(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.minimum_ = value;
}
inline void IntegerStatistic::set_minimum(int64_t value) {
  _internal_set_minimum(value);
  // @@protoc_insertion_point(field_set:pixels.proto.IntegerStatistic.minimum)
}

// optional sint64 maximum = 2;
inline bool IntegerStatistic::_internal_has_maximum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool IntegerStatistic::has_maximum() const {
  return _internal_has_maximum();
}
inline void IntegerStatistic::clear_maximum() {
  _impl_.maximum_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t IntegerStatistic::_internal_maximum() const {
  return _impl_.maximum_;
}
inline int64_t IntegerStatistic::maximum() const {
  // @@protoc_insertion_point(field_get:pixels.proto.IntegerStatistic.maximum)
  return _internal_maximum();
}
inline void IntegerStatistic::_internal_set_maximum(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.maximum_ = value;
}
inline void IntegerStatistic::set_maximum(int64_t value) {
  _internal_set_maximum(value);
  // @@protoc_insertion_point(field_set:pixels.proto.IntegerStatistic.maximum)
}

// optional sint64 sum = 3;
inline bool IntegerStatistic::_internal_has_sum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool IntegerStatistic::has_sum() const {
  return _internal_has_sum();
}
inline void IntegerStatistic::clear_sum() {
  _impl_.sum_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t IntegerStatistic::_internal_sum() const {
  return _impl_.sum_;
}
inline int64_t IntegerStatistic::sum() const {
  // @@protoc_insertion_point(field_get:pixels.proto.IntegerStatistic.sum)
  return _internal_sum();
}
inline void IntegerStatistic::_internal_set_sum(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.sum_ = value;
}
inline void IntegerStatistic::set_sum(int64_t value) {
  _internal_set_sum(value);
  // @@protoc_insertion_point(field_set:pixels.proto.IntegerStatistic.sum)
}

// -------------------------------------------------------------------

// Integer128Statistic

// optional uint64 minimum_high = 1;
inline bool Integer128Statistic::_internal_has_minimum_high() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Integer128Statistic::has_minimum_high() const {
  return _internal_has_minimum_high();
}
inline void Integer128Statistic::clear_minimum_high() {
  _impl_.minimum_high_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t Integer128Statistic::_internal_minimum_high() const {
  return _impl_.minimum_high_;
}
inline uint64_t Integer128Statistic::minimum_high() const {
  // @@protoc_insertion_point(field_get:pixels.proto.Integer128Statistic.minimum_high)
  return _internal_minimum_high();
}
inline void Integer128Statistic::_internal_set_minimum_high(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.minimum_high_ = value;
}
inline void Integer128Statistic::set_minimum_high(uint64_t value) {
  _internal_set_minimum_high(value);
  // @@protoc_insertion_point(field_set:pixels.proto.Integer128Statistic.minimum_high)
}

// optional uint64 minimum_low = 2;
inline bool Integer128Statistic::_internal_has_minimum_low() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Integer128Statistic::has_minimum_low() const {
  return _internal_has_minimum_low();
}
inline void Integer128Statistic::clear_minimum_low() {
  _impl_.minimum_low_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint64_t Integer128Statistic::_internal_minimum_low() const {
  return _impl_.minimum_low_;
}
inline uint64_t Integer128Statistic::minimum_low() const {
  // @@protoc_insertion_point(field_get:pixels.proto.Integer128Statistic.minimum_low)
  return _internal_minimum_low();
}
inline void Integer128Statistic::_internal_set_minimum_low(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.minimum_low_ = value;
}
inline void Integer128Statistic::set_minimum_low(uint64_t value) {
  _internal_set_minimum_low(value);
  // @@protoc_insertion_point(field_set:pixels.proto.Integer128Statistic.minimum_low)
}

// optional sint64 maximum_high = 3;
inline bool Integer128Statistic::_internal_has_maximum_high() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Integer128Statistic::has_maximum_high() const {
  return _internal_has_maximum_high();
}
inline void Integer128Statistic::clear_maximum_high() {
  _impl_.maximum_high_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t Integer128Statistic::_internal_maximum_high() const {
  return _impl_.maximum_high_;
}
inline int64_t Integer128Statistic::maximum_high() const {
  // @@protoc_insertion_point(field_get:pixels.proto.Integer128Statistic.maximum_high)
  return _internal_maximum_high();
}
inline void Integer128Statistic::_internal_set_maximum_high(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.maximum_high_ = value;
}
inline void Integer128Statistic::set_maximum_high(int64_t value) {
  _internal_set_maximum_high(value);
  // @@protoc_insertion_point(field_set:pixels.proto.Integer128Statistic.maximum_high)
}

// optional sint64 maximum_low = 4;
inline bool Integer128Statistic::_internal_has_maximum_low() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Integer128Statistic::has_maximum_low() const {
  return _internal_has_maximum_low();
}
inline void Integer128Statistic::clear_maximum_low() {
  _impl_.maximum_low_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t Integer128Statistic::_internal_maximum_low() const {
  return _impl_.maximum_low_;
}
inline int64_t Integer128Statistic::maximum_low() const {
  // @@protoc_insertion_point(field_get:pixels.proto.Integer128Statistic.maximum_low)
  return _internal_maximum_low();
}
inline void Integer128Statistic::_internal_set_maximum_low(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.maximum_low_ = value;
}
inline void Integer128Statistic::set_maximum_low(int64_t value) {
  _internal_set_maximum_low(value);
  // @@protoc_insertion_point(field_set:pixels.proto.Integer128Statistic.maximum_low)
}

// -------------------------------------------------------------------

// DoubleStatistic

// optional double minimum = 1;
inline bool DoubleStatistic::_internal_has_minimum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DoubleStatistic::has_minimum() const {
  return _internal_has_minimum();
}
inline void DoubleStatistic::clear_minimum() {
  _impl_.minimum_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double DoubleStatistic::_internal_minimum() const {
  return _impl_.minimum_;
}
inline double DoubleStatistic::minimum() const {
  // @@protoc_insertion_point(field_get:pixels.proto.DoubleStatistic.minimum)
  return _internal_minimum();
}
inline void DoubleStatistic::_internal_set_minimum(double value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.minimum_ = value;
}
inline void DoubleStatistic::set_minimum(double value) {
  _internal_set_minimum(value);
  // @@protoc_insertion_point(field_set:pixels.proto.DoubleStatistic.minimum)
}

// optional double maximum = 2;
inline bool DoubleStatistic::_internal_has_maximum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DoubleStatistic::has_maximum() const {
  return _internal_has_maximum();
}
inline void DoubleStatistic::clear_maximum() {
  _impl_.maximum_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline double DoubleStatistic::_internal_maximum() const {
  return _impl_.maximum_;
}
inline double DoubleStatistic::maximum() const {
  // @@protoc_insertion_point(field_get:pixels.proto.DoubleStatistic.maximum)
  return _internal_maximum();
}
inline void DoubleStatistic::_internal_set_maximum(double value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.maximum_ = value;
}
inline void DoubleStatistic::set_maximum(double value) {
  _internal_set_maximum(value);
  // @@protoc_insertion_point(field_set:pixels.proto.DoubleStatistic.maximum)
}

// optional double sum = 3;
inline bool DoubleStatistic::_internal_has_sum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DoubleStatistic::has_sum() const {
  return _internal_has_sum();
}
inline void DoubleStatistic::clear_sum() {
  _impl_.sum_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline double DoubleStatistic::_internal_sum() const {
  return _impl_.sum_;
}
inline double DoubleStatistic::sum() const {
  // @@protoc_insertion_point(field_get:pixels.proto.DoubleStatistic.sum)
  return _internal_sum();
}
inline void DoubleStatistic::_internal_set_sum(double value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.sum_ = value;
}
inline void DoubleStatistic::set_sum(double value) {
  _internal_set_sum(value);
  // @@protoc_insertion_point(field_set:pixels.proto.DoubleStatistic.sum)
}

// -------------------------------------------------------------------

// StringStatistic

// optional string minimum = 1;
inline bool StringStatistic::_internal_has_minimum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StringStatistic::has_minimum() const {
  return _internal_has_minimum();
}
inline void StringStatistic::clear_minimum() {
  _impl_.minimum_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StringStatistic::minimum() const {
  // @@protoc_insertion_point(field_get:pixels.proto.StringStatistic.minimum)
  return _internal_minimum();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StringStatistic::set_minimum(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.minimum_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pixels.proto.StringStatistic.minimum)
}
inline std::string* StringStatistic::mutable_minimum() {
  std::string* _s = _internal_mutable_minimum();
  // @@protoc_insertion_point(field_mutable:pixels.proto.StringStatistic.minimum)
  return _s;
}
inline const std::string& StringStatistic::_internal_minimum() const {
  return _impl_.minimum_.Get();
}
inline void StringStatistic::_internal_set_minimum(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.minimum_.Set(value, GetArenaForAllocation());
}
inline std::string* StringStatistic::_internal_mutable_minimum() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.minimum_.Mutable(GetArenaForAllocation());
}
inline std::string* StringStatistic::release_minimum() {
  // @@protoc_insertion_point(field_release:pixels.proto.StringStatistic.minimum)
  if (!_internal_has_minimum()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.minimum_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.minimum_.IsDefault()) {
    _impl_.minimum_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StringStatistic::set_allocated_minimum(std::string* minimum) {
  if (minimum != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.minimum_.SetAllocated(minimum, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.minimum_.IsDefault()) {
    _impl_.minimum_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pixels.proto.StringStatistic.minimum)
}

// optional string maximum = 2;
inline bool StringStatistic::_internal_has_maximum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StringStatistic::has_maximum() const {
  return _internal_has_maximum();
}
inline void StringStatistic::clear_maximum() {
  _impl_.maximum_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StringStatistic::maximum() const {
  // @@protoc_insertion_point(field_get:pixels.proto.StringStatistic.maximum)
  return _internal_maximum();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StringStatistic::set_maximum(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.maximum_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pixels.proto.StringStatistic.maximum)
}
inline std::string* StringStatistic::mutable_maximum() {
  std::string* _s = _internal_mutable_maximum();
  // @@protoc_insertion_point(field_mutable:pixels.proto.StringStatistic.maximum)
  return _s;
}
inline const std::string& StringStatistic::_internal_maximum() const {
  return _impl_.maximum_.Get();
}
inline void StringStatistic::_internal_set_maximum(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.maximum_.Set(value, GetArenaForAllocation());
}
inline std::string* StringStatistic::_internal_mutable_maximum() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.maximum_.Mutable(GetArenaForAllocation());
}
inline std::string* StringStatistic::release_maximum() {
  // @@protoc_insertion_point(field_release:pixels.proto.StringStatistic.maximum)
  if (!_internal_has_maximum()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.maximum_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.maximum_.IsDefault()) {
    _impl_.maximum_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StringStatistic::set_allocated_maximum(std::string* maximum) {
  if (maximum != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.maximum_.SetAllocated(maximum, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.maximum_.IsDefault()) {
    _impl_.maximum_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pixels.proto.StringStatistic.maximum)
}

// optional sint64 sum = 3;
inline bool StringStatistic::_internal_has_sum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StringStatistic::has_sum() const {
  return _internal_has_sum();
}
inline void StringStatistic::clear_sum() {
  _impl_.sum_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t StringStatistic::_internal_sum() const {
  return _impl_.sum_;
}
inline int64_t StringStatistic::sum() const {
  // @@protoc_insertion_point(field_get:pixels.proto.StringStatistic.sum)
  return _internal_sum();
}
inline void StringStatistic::_internal_set_sum(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.sum_ = value;
}
inline void StringStatistic::set_sum(int64_t value) {
  _internal_set_sum(value);
  // @@protoc_insertion_point(field_set:pixels.proto.StringStatistic.sum)
}

// -------------------------------------------------------------------

// BucketStatistic

// repeated uint64 count = 1 [packed = true];
inline int BucketStatistic::_internal_count_size() const {
  return _impl_.count_.size();
}
inline int BucketStatistic::count_size() const {
  return _internal_count_size();
}
inline void BucketStatistic::clear_count() {
  _impl_.count_.Clear();
}
inline uint64_t BucketStatistic::_internal_count(int index) const {
  return _impl_.count_.Get(index);
}
inline uint64_t BucketStatistic::count(int index) const {
  // @@protoc_insertion_point(field_get:pixels.proto.BucketStatistic.count)
  return _internal_count(index);
}
inline void BucketStatistic::set_count(int index, uint64_t value) {
  _impl_.count_.Set(index, value);
  // @@protoc_insertion_point(field_set:pixels.proto.BucketStatistic.count)
}
inline void BucketStatistic::_internal_add_count(uint64_t value) {
  _impl_.count_.Add(value);
}
inline void BucketStatistic::add_count(uint64_t value) {
  _internal_add_count(value);
  // @@protoc_insertion_point(field_add:pixels.proto.BucketStatistic.count)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
BucketStatistic::_internal_count() const {
  return _impl_.count_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
BucketStatistic::count() const {
  // @@protoc_insertion_point(field_list:pixels.proto.BucketStatistic.count)
  return _internal_count();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
BucketStatistic::_internal_mutable_count() {
  return &_impl_.count_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
BucketStatistic::mutable_count() {
  // @@protoc_insertion_point(field_mutable_list:pixels.proto.BucketStatistic.count)
  return _internal_mutable_count();
}

// -------------------------------------------------------------------

// TimestampStatistic

// optional sint64 minimum = 1;
inline bool TimestampStatistic::_internal_has_minimum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TimestampStatistic::has_minimum() const {
  return _internal_has_minimum();
}
inline void TimestampStatistic::clear_minimum() {
  _impl_.minimum_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t TimestampStatistic::_internal_minimum() const {
  return _impl_.minimum_;
}
inline int64_t TimestampStatistic::minimum() const {
  // @@protoc_insertion_point(field_get:pixels.proto.TimestampStatistic.minimum)
  return _internal_minimum();
}
inline void TimestampStatistic::_internal_set_minimum(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.minimum_ = value;
}
inline void TimestampStatistic::set_minimum(int64_t value) {
  _internal_set_minimum(value);
  // @@protoc_insertion_point(field_set:pixels.proto.TimestampStatistic.minimum)
}

// optional sint64 maximum = 2;
inline bool TimestampStatistic::_internal_has_maximum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TimestampStatistic::has_maximum() const {
  return _internal_has_maximum();
}
inline void TimestampStatistic::clear_maximum() {
  _impl_.maximum_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t TimestampStatistic::_internal_maximum() const {
  return _impl_.maximum_;
}
inline int64_t TimestampStatistic::maximum() const {
  // @@protoc_insertion_point(field_get:pixels.proto.TimestampStatistic.maximum)
  return _internal_maximum();
}
inline void TimestampStatistic::_internal_set_maximum(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.maximum_ = value;
}
inline void TimestampStatistic::set_maximum(int64_t value) {
  _internal_set_maximum(value);
  // @@protoc_insertion_point(field_set:pixels.proto.TimestampStatistic.maximum)
}

// -------------------------------------------------------------------

// DateStatistic

// optional sint32 minimum = 1;
inline bool DateStatistic::_internal_has_minimum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DateStatistic::has_minimum() const {
  return _internal_has_minimum();
}
inline void DateStatistic::clear_minimum() {
  _impl_.minimum_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t DateStatistic::_internal_minimum() const {
  return _impl_.minimum_;
}
inline int32_t DateStatistic::minimum() const {
  // @@protoc_insertion_point(field_get:pixels.proto.DateStatistic.minimum)
  return _internal_minimum();
}
inline void DateStatistic::_internal_set_minimum(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.minimum_ = value;
}
inline void DateStatistic::set_minimum(int32_t value) {
  _internal_set_minimum(value);
  // @@protoc_insertion_point(field_set:pixels.proto.DateStatistic.minimum)
}

// optional sint32 maximum = 2;
inline bool DateStatistic::_internal_has_maximum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DateStatistic::has_maximum() const {
  return _internal_has_maximum();
}
inline void DateStatistic::clear_maximum() {
  _impl_.maximum_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t DateStatistic::_internal_maximum() const {
  return _impl_.maximum_;
}
inline int32_t DateStatistic::maximum() const {
  // @@protoc_insertion_point(field_get:pixels.proto.DateStatistic.maximum)
  return _internal_maximum();
}
inline void DateStatistic::_internal_set_maximum(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.maximum_ = value;
}
inline void DateStatistic::set_maximum(int32_t value) {
  _internal_set_maximum(value);
  // @@protoc_insertion_point(field_set:pixels.proto.DateStatistic.maximum)
}

// -------------------------------------------------------------------

// TimeStatistic

// optional sint32 minimum = 1;
inline bool TimeStatistic::_internal_has_minimum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TimeStatistic::has_minimum() const {
  return _internal_has_minimum();
}
inline void TimeStatistic::clear_minimum() {
  _impl_.minimum_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t TimeStatistic::_internal_minimum() const {
  return _impl_.minimum_;
}
inline int32_t TimeStatistic::minimum() const {
  // @@protoc_insertion_point(field_get:pixels.proto.TimeStatistic.minimum)
  return _internal_minimum();
}
inline void TimeStatistic::_internal_set_minimum(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.minimum_ = value;
}
inline void TimeStatistic::set_minimum(int32_t value) {
  _internal_set_minimum(value);
  // @@protoc_insertion_point(field_set:pixels.proto.TimeStatistic.minimum)
}

// optional sint32 maximum = 2;
inline bool TimeStatistic::_internal_has_maximum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TimeStatistic::has_maximum() const {
  return _internal_has_maximum();
}
inline void TimeStatistic::clear_maximum() {
  _impl_.maximum_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t TimeStatistic::_internal_maximum() const {
  return _impl_.maximum_;
}
inline int32_t TimeStatistic::maximum() const {
  // @@protoc_insertion_point(field_get:pixels.proto.TimeStatistic.maximum)
  return _internal_maximum();
}
inline void TimeStatistic::_internal_set_maximum(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.maximum_ = value;
}
inline void TimeStatistic::set_maximum(int32_t value) {
  _internal_set_maximum(value);
  // @@protoc_insertion_point(field_set:pixels.proto.TimeStatistic.maximum)
}

// -------------------------------------------------------------------

// BinaryStatistic

// optional sint64 sum = 1;
inline bool BinaryStatistic::_internal_has_sum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BinaryStatistic::has_sum() const {
  return _internal_has_sum();
}
inline void BinaryStatistic::clear_sum() {
  _impl_.sum_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t BinaryStatistic::_internal_sum() const {
  return _impl_.sum_;
}
inline int64_t BinaryStatistic::sum() const {
  // @@protoc_insertion_point(field_get:pixels.proto.BinaryStatistic.sum)
  return _internal_sum();
}
inline void BinaryStatistic::_internal_set_sum(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sum_ = value;
}
inline void BinaryStatistic::set_sum(int64_t value) {
  _internal_set_sum(value);
  // @@protoc_insertion_point(field_set:pixels.proto.BinaryStatistic.sum)
}

// -------------------------------------------------------------------

// ColumnStatistic

// optional uint64 numberOfValues = 1;
inline bool ColumnStatistic::_internal_has_numberofvalues() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ColumnStatistic::has_numberofvalues() const {
  return _internal_has_numberofvalues();
}
inline void ColumnStatistic::clear_numberofvalues() {
  _impl_.numberofvalues_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline uint64_t ColumnStatistic::_internal_numberofvalues() const {
  return _impl_.numberofvalues_;
}
inline uint64_t ColumnStatistic::numberofvalues() const {
  // @@protoc_insertion_point(field_get:pixels.proto.ColumnStatistic.numberOfValues)
  return _internal_numberofvalues();
}
inline void ColumnStatistic::_internal_set_numberofvalues(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.numberofvalues_ = value;
}
inline void ColumnStatistic::set_numberofvalues(uint64_t value) {
  _internal_set_numberofvalues(value);
  // @@protoc_insertion_point(field_set:pixels.proto.ColumnStatistic.numberOfValues)
}

// optional .pixels.proto.IntegerStatistic intStatistics = 2;
inline bool ColumnStatistic::_internal_has_intstatistics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.intstatistics_ != nullptr);
  return value;
}
inline bool ColumnStatistic::has_intstatistics() const {
  return _internal_has_intstatistics();
}
inline void ColumnStatistic::clear_intstatistics() {
  if (_impl_.intstatistics_ != nullptr) _impl_.intstatistics_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::pixels::proto::IntegerStatistic& ColumnStatistic::_internal_intstatistics() const {
  const ::pixels::proto::IntegerStatistic* p = _impl_.intstatistics_;
  return p != nullptr ? *p : reinterpret_cast<const ::pixels::proto::IntegerStatistic&>(
      ::pixels::proto::_IntegerStatistic_default_instance_);
}
inline const ::pixels::proto::IntegerStatistic& ColumnStatistic::intstatistics() const {
  // @@protoc_insertion_point(field_get:pixels.proto.ColumnStatistic.intStatistics)
  return _internal_intstatistics();
}
inline void ColumnStatistic::unsafe_arena_set_allocated_intstatistics(
    ::pixels::proto::IntegerStatistic* intstatistics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.intstatistics_);
  }
  _impl_.intstatistics_ = intstatistics;
  if (intstatistics) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pixels.proto.ColumnStatistic.intStatistics)
}
inline ::pixels::proto::IntegerStatistic* ColumnStatistic::release_intstatistics() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pixels::proto::IntegerStatistic* temp = _impl_.intstatistics_;
  _impl_.intstatistics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pixels::proto::IntegerStatistic* ColumnStatistic::unsafe_arena_release_intstatistics() {
  // @@protoc_insertion_point(field_release:pixels.proto.ColumnStatistic.intStatistics)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pixels::proto::IntegerStatistic* temp = _impl_.intstatistics_;
  _impl_.intstatistics_ = nullptr;
  return temp;
}
inline ::pixels::proto::IntegerStatistic* ColumnStatistic::_internal_mutable_intstatistics() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.intstatistics_ == nullptr) {
    auto* p = CreateMaybeMessage<::pixels::proto::IntegerStatistic>(GetArenaForAllocation());
    _impl_.intstatistics_ = p;
  }
  return _impl_.intstatistics_;
}
inline ::pixels::proto::IntegerStatistic* ColumnStatistic::mutable_intstatistics() {
  ::pixels::proto::IntegerStatistic* _msg = _internal_mutable_intstatistics();
  // @@protoc_insertion_point(field_mutable:pixels.proto.ColumnStatistic.intStatistics)
  return _msg;
}
inline void ColumnStatistic::set_allocated_intstatistics(::pixels::proto::IntegerStatistic* intstatistics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.intstatistics_;
  }
  if (intstatistics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(intstatistics);
    if (message_arena != submessage_arena) {
      intstatistics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, intstatistics, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.intstatistics_ = intstatistics;
  // @@protoc_insertion_point(field_set_allocated:pixels.proto.ColumnStatistic.intStatistics)
}

// optional .pixels.proto.DoubleStatistic doubleStatistics = 3;
inline bool ColumnStatistic::_internal_has_doublestatistics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.doublestatistics_ != nullptr);
  return value;
}
inline bool ColumnStatistic::has_doublestatistics() const {
  return _internal_has_doublestatistics();
}
inline void ColumnStatistic::clear_doublestatistics() {
  if (_impl_.doublestatistics_ != nullptr) _impl_.doublestatistics_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::pixels::proto::DoubleStatistic& ColumnStatistic::_internal_doublestatistics() const {
  const ::pixels::proto::DoubleStatistic* p = _impl_.doublestatistics_;
  return p != nullptr ? *p : reinterpret_cast<const ::pixels::proto::DoubleStatistic&>(
      ::pixels::proto::_DoubleStatistic_default_instance_);
}
inline const ::pixels::proto::DoubleStatistic& ColumnStatistic::doublestatistics() const {
  // @@protoc_insertion_point(field_get:pixels.proto.ColumnStatistic.doubleStatistics)
  return _internal_doublestatistics();
}
inline void ColumnStatistic::unsafe_arena_set_allocated_doublestatistics(
    ::pixels::proto::DoubleStatistic* doublestatistics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.doublestatistics_);
  }
  _impl_.doublestatistics_ = doublestatistics;
  if (doublestatistics) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pixels.proto.ColumnStatistic.doubleStatistics)
}
inline ::pixels::proto::DoubleStatistic* ColumnStatistic::release_doublestatistics() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::pixels::proto::DoubleStatistic* temp = _impl_.doublestatistics_;
  _impl_.doublestatistics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pixels::proto::DoubleStatistic* ColumnStatistic::unsafe_arena_release_doublestatistics() {
  // @@protoc_insertion_point(field_release:pixels.proto.ColumnStatistic.doubleStatistics)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::pixels::proto::DoubleStatistic* temp = _impl_.doublestatistics_;
  _impl_.doublestatistics_ = nullptr;
  return temp;
}
inline ::pixels::proto::DoubleStatistic* ColumnStatistic::_internal_mutable_doublestatistics() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.doublestatistics_ == nullptr) {
    auto* p = CreateMaybeMessage<::pixels::proto::DoubleStatistic>(GetArenaForAllocation());
    _impl_.doublestatistics_ = p;
  }
  return _impl_.doublestatistics_;
}
inline ::pixels::proto::DoubleStatistic* ColumnStatistic::mutable_doublestatistics() {
  ::pixels::proto::DoubleStatistic* _msg = _internal_mutable_doublestatistics();
  // @@protoc_insertion_point(field_mutable:pixels.proto.ColumnStatistic.doubleStatistics)
  return _msg;
}
inline void ColumnStatistic::set_allocated_doublestatistics(::pixels::proto::DoubleStatistic* doublestatistics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.doublestatistics_;
  }
  if (doublestatistics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(doublestatistics);
    if (message_arena != submessage_arena) {
      doublestatistics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, doublestatistics, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.doublestatistics_ = doublestatistics;
  // @@protoc_insertion_point(field_set_allocated:pixels.proto.ColumnStatistic.doubleStatistics)
}

// optional .pixels.proto.StringStatistic stringStatistics = 4;
inline bool ColumnStatistic::_internal_has_stringstatistics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.stringstatistics_ != nullptr);
  return value;
}
inline bool ColumnStatistic::has_stringstatistics() const {
  return _internal_has_stringstatistics();
}
inline void ColumnStatistic::clear_stringstatistics() {
  if (_impl_.stringstatistics_ != nullptr) _impl_.stringstatistics_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::pixels::proto::StringStatistic& ColumnStatistic::_internal_stringstatistics() const {
  const ::pixels::proto::StringStatistic* p = _impl_.stringstatistics_;
  return p != nullptr ? *p : reinterpret_cast<const ::pixels::proto::StringStatistic&>(
      ::pixels::proto::_StringStatistic_default_instance_);
}
inline const ::pixels::proto::StringStatistic& ColumnStatistic::stringstatistics() const {
  // @@protoc_insertion_point(field_get:pixels.proto.ColumnStatistic.stringStatistics)
  return _internal_stringstatistics();
}
inline void ColumnStatistic::unsafe_arena_set_allocated_stringstatistics(
    ::pixels::proto::StringStatistic* stringstatistics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stringstatistics_);
  }
  _impl_.stringstatistics_ = stringstatistics;
  if (stringstatistics) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pixels.proto.ColumnStatistic.stringStatistics)
}
inline ::pixels::proto::StringStatistic* ColumnStatistic::release_stringstatistics() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::pixels::proto::StringStatistic* temp = _impl_.stringstatistics_;
  _impl_.stringstatistics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pixels::proto::StringStatistic* ColumnStatistic::unsafe_arena_release_stringstatistics() {
  // @@protoc_insertion_point(field_release:pixels.proto.ColumnStatistic.stringStatistics)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::pixels::proto::StringStatistic* temp = _impl_.stringstatistics_;
  _impl_.stringstatistics_ = nullptr;
  return temp;
}
inline ::pixels::proto::StringStatistic* ColumnStatistic::_internal_mutable_stringstatistics() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.stringstatistics_ == nullptr) {
    auto* p = CreateMaybeMessage<::pixels::proto::StringStatistic>(GetArenaForAllocation());
    _impl_.stringstatistics_ = p;
  }
  return _impl_.stringstatistics_;
}
inline ::pixels::proto::StringStatistic* ColumnStatistic::mutable_stringstatistics() {
  ::pixels::proto::StringStatistic* _msg = _internal_mutable_stringstatistics();
  // @@protoc_insertion_point(field_mutable:pixels.proto.ColumnStatistic.stringStatistics)
  return _msg;
}
inline void ColumnStatistic::set_allocated_stringstatistics(::pixels::proto::StringStatistic* stringstatistics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.stringstatistics_;
  }
  if (stringstatistics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stringstatistics);
    if (message_arena != submessage_arena) {
      stringstatistics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stringstatistics, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.stringstatistics_ = stringstatistics;
  // @@protoc_insertion_point(field_set_allocated:pixels.proto.ColumnStatistic.stringStatistics)
}

// optional .pixels.proto.BucketStatistic bucketStatistics = 5;
inline bool ColumnStatistic::_internal_has_bucketstatistics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bucketstatistics_ != nullptr);
  return value;
}
inline bool ColumnStatistic::has_bucketstatistics() const {
  return _internal_has_bucketstatistics();
}
inline void ColumnStatistic::clear_bucketstatistics() {
  if (_impl_.bucketstatistics_ != nullptr) _impl_.bucketstatistics_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::pixels::proto::BucketStatistic& ColumnStatistic::_internal_bucketstatistics() const {
  const ::pixels::proto::BucketStatistic* p = _impl_.bucketstatistics_;
  return p != nullptr ? *p : reinterpret_cast<const ::pixels::proto::BucketStatistic&>(
      ::pixels::proto::_BucketStatistic_default_instance_);
}
inline const ::pixels::proto::BucketStatistic& ColumnStatistic::bucketstatistics() const {
  // @@protoc_insertion_point(field_get:pixels.proto.ColumnStatistic.bucketStatistics)
  return _internal_bucketstatistics();
}
inline void ColumnStatistic::unsafe_arena_set_allocated_bucketstatistics(
    ::pixels::proto::BucketStatistic* bucketstatistics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bucketstatistics_);
  }
  _impl_.bucketstatistics_ = bucketstatistics;
  if (bucketstatistics) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pixels.proto.ColumnStatistic.bucketStatistics)
}
inline ::pixels::proto::BucketStatistic* ColumnStatistic::release_bucketstatistics() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::pixels::proto::BucketStatistic* temp = _impl_.bucketstatistics_;
  _impl_.bucketstatistics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pixels::proto::BucketStatistic* ColumnStatistic::unsafe_arena_release_bucketstatistics() {
  // @@protoc_insertion_point(field_release:pixels.proto.ColumnStatistic.bucketStatistics)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::pixels::proto::BucketStatistic* temp = _impl_.bucketstatistics_;
  _impl_.bucketstatistics_ = nullptr;
  return temp;
}
inline ::pixels::proto::BucketStatistic* ColumnStatistic::_internal_mutable_bucketstatistics() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.bucketstatistics_ == nullptr) {
    auto* p = CreateMaybeMessage<::pixels::proto::BucketStatistic>(GetArenaForAllocation());
    _impl_.bucketstatistics_ = p;
  }
  return _impl_.bucketstatistics_;
}
inline ::pixels::proto::BucketStatistic* ColumnStatistic::mutable_bucketstatistics() {
  ::pixels::proto::BucketStatistic* _msg = _internal_mutable_bucketstatistics();
  // @@protoc_insertion_point(field_mutable:pixels.proto.ColumnStatistic.bucketStatistics)
  return _msg;
}
inline void ColumnStatistic::set_allocated_bucketstatistics(::pixels::proto::BucketStatistic* bucketstatistics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bucketstatistics_;
  }
  if (bucketstatistics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bucketstatistics);
    if (message_arena != submessage_arena) {
      bucketstatistics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bucketstatistics, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.bucketstatistics_ = bucketstatistics;
  // @@protoc_insertion_point(field_set_allocated:pixels.proto.ColumnStatistic.bucketStatistics)
}

// optional .pixels.proto.BinaryStatistic binaryStatistics = 6;
inline bool ColumnStatistic::_internal_has_binarystatistics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.binarystatistics_ != nullptr);
  return value;
}
inline bool ColumnStatistic::has_binarystatistics() const {
  return _internal_has_binarystatistics();
}
inline void ColumnStatistic::clear_binarystatistics() {
  if (_impl_.binarystatistics_ != nullptr) _impl_.binarystatistics_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::pixels::proto::BinaryStatistic& ColumnStatistic::_internal_binarystatistics() const {
  const ::pixels::proto::BinaryStatistic* p = _impl_.binarystatistics_;
  return p != nullptr ? *p : reinterpret_cast<const ::pixels::proto::BinaryStatistic&>(
      ::pixels::proto::_BinaryStatistic_default_instance_);
}
inline const ::pixels::proto::BinaryStatistic& ColumnStatistic::binarystatistics() const {
  // @@protoc_insertion_point(field_get:pixels.proto.ColumnStatistic.binaryStatistics)
  return _internal_binarystatistics();
}
inline void ColumnStatistic::unsafe_arena_set_allocated_binarystatistics(
    ::pixels::proto::BinaryStatistic* binarystatistics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.binarystatistics_);
  }
  _impl_.binarystatistics_ = binarystatistics;
  if (binarystatistics) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pixels.proto.ColumnStatistic.binaryStatistics)
}
inline ::pixels::proto::BinaryStatistic* ColumnStatistic::release_binarystatistics() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::pixels::proto::BinaryStatistic* temp = _impl_.binarystatistics_;
  _impl_.binarystatistics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pixels::proto::BinaryStatistic* ColumnStatistic::unsafe_arena_release_binarystatistics() {
  // @@protoc_insertion_point(field_release:pixels.proto.ColumnStatistic.binaryStatistics)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::pixels::proto::BinaryStatistic* temp = _impl_.binarystatistics_;
  _impl_.binarystatistics_ = nullptr;
  return temp;
}
inline ::pixels::proto::BinaryStatistic* ColumnStatistic::_internal_mutable_binarystatistics() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.binarystatistics_ == nullptr) {
    auto* p = CreateMaybeMessage<::pixels::proto::BinaryStatistic>(GetArenaForAllocation());
    _impl_.binarystatistics_ = p;
  }
  return _impl_.binarystatistics_;
}
inline ::pixels::proto::BinaryStatistic* ColumnStatistic::mutable_binarystatistics() {
  ::pixels::proto::BinaryStatistic* _msg = _internal_mutable_binarystatistics();
  // @@protoc_insertion_point(field_mutable:pixels.proto.ColumnStatistic.binaryStatistics)
  return _msg;
}
inline void ColumnStatistic::set_allocated_binarystatistics(::pixels::proto::BinaryStatistic* binarystatistics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.binarystatistics_;
  }
  if (binarystatistics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(binarystatistics);
    if (message_arena != submessage_arena) {
      binarystatistics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, binarystatistics, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.binarystatistics_ = binarystatistics;
  // @@protoc_insertion_point(field_set_allocated:pixels.proto.ColumnStatistic.binaryStatistics)
}

// optional .pixels.proto.TimestampStatistic timestampStatistics = 7;
inline bool ColumnStatistic::_internal_has_timestampstatistics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestampstatistics_ != nullptr);
  return value;
}
inline bool ColumnStatistic::has_timestampstatistics() const {
  return _internal_has_timestampstatistics();
}
inline void ColumnStatistic::clear_timestampstatistics() {
  if (_impl_.timestampstatistics_ != nullptr) _impl_.timestampstatistics_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::pixels::proto::TimestampStatistic& ColumnStatistic::_internal_timestampstatistics() const {
  const ::pixels::proto::TimestampStatistic* p = _impl_.timestampstatistics_;
  return p != nullptr ? *p : reinterpret_cast<const ::pixels::proto::TimestampStatistic&>(
      ::pixels::proto::_TimestampStatistic_default_instance_);
}
inline const ::pixels::proto::TimestampStatistic& ColumnStatistic::timestampstatistics() const {
  // @@protoc_insertion_point(field_get:pixels.proto.ColumnStatistic.timestampStatistics)
  return _internal_timestampstatistics();
}
inline void ColumnStatistic::unsafe_arena_set_allocated_timestampstatistics(
    ::pixels::proto::TimestampStatistic* timestampstatistics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestampstatistics_);
  }
  _impl_.timestampstatistics_ = timestampstatistics;
  if (timestampstatistics) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pixels.proto.ColumnStatistic.timestampStatistics)
}
inline ::pixels::proto::TimestampStatistic* ColumnStatistic::release_timestampstatistics() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::pixels::proto::TimestampStatistic* temp = _impl_.timestampstatistics_;
  _impl_.timestampstatistics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pixels::proto::TimestampStatistic* ColumnStatistic::unsafe_arena_release_timestampstatistics() {
  // @@protoc_insertion_point(field_release:pixels.proto.ColumnStatistic.timestampStatistics)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::pixels::proto::TimestampStatistic* temp = _impl_.timestampstatistics_;
  _impl_.timestampstatistics_ = nullptr;
  return temp;
}
inline ::pixels::proto::TimestampStatistic* ColumnStatistic::_internal_mutable_timestampstatistics() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.timestampstatistics_ == nullptr) {
    auto* p = CreateMaybeMessage<::pixels::proto::TimestampStatistic>(GetArenaForAllocation());
    _impl_.timestampstatistics_ = p;
  }
  return _impl_.timestampstatistics_;
}
inline ::pixels::proto::TimestampStatistic* ColumnStatistic::mutable_timestampstatistics() {
  ::pixels::proto::TimestampStatistic* _msg = _internal_mutable_timestampstatistics();
  // @@protoc_insertion_point(field_mutable:pixels.proto.ColumnStatistic.timestampStatistics)
  return _msg;
}
inline void ColumnStatistic::set_allocated_timestampstatistics(::pixels::proto::TimestampStatistic* timestampstatistics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.timestampstatistics_;
  }
  if (timestampstatistics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(timestampstatistics);
    if (message_arena != submessage_arena) {
      timestampstatistics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestampstatistics, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.timestampstatistics_ = timestampstatistics;
  // @@protoc_insertion_point(field_set_allocated:pixels.proto.ColumnStatistic.timestampStatistics)
}

// optional .pixels.proto.DateStatistic dateStatistics = 9;
inline bool ColumnStatistic::_internal_has_datestatistics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.datestatistics_ != nullptr);
  return value;
}
inline bool ColumnStatistic::has_datestatistics() const {
  return _internal_has_datestatistics();
}
inline void ColumnStatistic::clear_datestatistics() {
  if (_impl_.datestatistics_ != nullptr) _impl_.datestatistics_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::pixels::proto::DateStatistic& ColumnStatistic::_internal_datestatistics() const {
  const ::pixels::proto::DateStatistic* p = _impl_.datestatistics_;
  return p != nullptr ? *p : reinterpret_cast<const ::pixels::proto::DateStatistic&>(
      ::pixels::proto::_DateStatistic_default_instance_);
}
inline const ::pixels::proto::DateStatistic& ColumnStatistic::datestatistics() const {
  // @@protoc_insertion_point(field_get:pixels.proto.ColumnStatistic.dateStatistics)
  return _internal_datestatistics();
}
inline void ColumnStatistic::unsafe_arena_set_allocated_datestatistics(
    ::pixels::proto::DateStatistic* datestatistics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.datestatistics_);
  }
  _impl_.datestatistics_ = datestatistics;
  if (datestatistics) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pixels.proto.ColumnStatistic.dateStatistics)
}
inline ::pixels::proto::DateStatistic* ColumnStatistic::release_datestatistics() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::pixels::proto::DateStatistic* temp = _impl_.datestatistics_;
  _impl_.datestatistics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pixels::proto::DateStatistic* ColumnStatistic::unsafe_arena_release_datestatistics() {
  // @@protoc_insertion_point(field_release:pixels.proto.ColumnStatistic.dateStatistics)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::pixels::proto::DateStatistic* temp = _impl_.datestatistics_;
  _impl_.datestatistics_ = nullptr;
  return temp;
}
inline ::pixels::proto::DateStatistic* ColumnStatistic::_internal_mutable_datestatistics() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.datestatistics_ == nullptr) {
    auto* p = CreateMaybeMessage<::pixels::proto::DateStatistic>(GetArenaForAllocation());
    _impl_.datestatistics_ = p;
  }
  return _impl_.datestatistics_;
}
inline ::pixels::proto::DateStatistic* ColumnStatistic::mutable_datestatistics() {
  ::pixels::proto::DateStatistic* _msg = _internal_mutable_datestatistics();
  // @@protoc_insertion_point(field_mutable:pixels.proto.ColumnStatistic.dateStatistics)
  return _msg;
}
inline void ColumnStatistic::set_allocated_datestatistics(::pixels::proto::DateStatistic* datestatistics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.datestatistics_;
  }
  if (datestatistics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(datestatistics);
    if (message_arena != submessage_arena) {
      datestatistics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, datestatistics, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.datestatistics_ = datestatistics;
  // @@protoc_insertion_point(field_set_allocated:pixels.proto.ColumnStatistic.dateStatistics)
}

// optional .pixels.proto.TimeStatistic timeStatistics = 10;
inline bool ColumnStatistic::_internal_has_timestatistics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timestatistics_ != nullptr);
  return value;
}
inline bool ColumnStatistic::has_timestatistics() const {
  return _internal_has_timestatistics();
}
inline void ColumnStatistic::clear_timestatistics() {
  if (_impl_.timestatistics_ != nullptr) _impl_.timestatistics_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::pixels::proto::TimeStatistic& ColumnStatistic::_internal_timestatistics() const {
  const ::pixels::proto::TimeStatistic* p = _impl_.timestatistics_;
  return p != nullptr ? *p : reinterpret_cast<const ::pixels::proto::TimeStatistic&>(
      ::pixels::proto::_TimeStatistic_default_instance_);
}
inline const ::pixels::proto::TimeStatistic& ColumnStatistic::timestatistics() const {
  // @@protoc_insertion_point(field_get:pixels.proto.ColumnStatistic.timeStatistics)
  return _internal_timestatistics();
}
inline void ColumnStatistic::unsafe_arena_set_allocated_timestatistics(
    ::pixels::proto::TimeStatistic* timestatistics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestatistics_);
  }
  _impl_.timestatistics_ = timestatistics;
  if (timestatistics) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pixels.proto.ColumnStatistic.timeStatistics)
}
inline ::pixels::proto::TimeStatistic* ColumnStatistic::release_timestatistics() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::pixels::proto::TimeStatistic* temp = _impl_.timestatistics_;
  _impl_.timestatistics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pixels::proto::TimeStatistic* ColumnStatistic::unsafe_arena_release_timestatistics() {
  // @@protoc_insertion_point(field_release:pixels.proto.ColumnStatistic.timeStatistics)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::pixels::proto::TimeStatistic* temp = _impl_.timestatistics_;
  _impl_.timestatistics_ = nullptr;
  return temp;
}
inline ::pixels::proto::TimeStatistic* ColumnStatistic::_internal_mutable_timestatistics() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.timestatistics_ == nullptr) {
    auto* p = CreateMaybeMessage<::pixels::proto::TimeStatistic>(GetArenaForAllocation());
    _impl_.timestatistics_ = p;
  }
  return _impl_.timestatistics_;
}
inline ::pixels::proto::TimeStatistic* ColumnStatistic::mutable_timestatistics() {
  ::pixels::proto::TimeStatistic* _msg = _internal_mutable_timestatistics();
  // @@protoc_insertion_point(field_mutable:pixels.proto.ColumnStatistic.timeStatistics)
  return _msg;
}
inline void ColumnStatistic::set_allocated_timestatistics(::pixels::proto::TimeStatistic* timestatistics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.timestatistics_;
  }
  if (timestatistics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(timestatistics);
    if (message_arena != submessage_arena) {
      timestatistics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestatistics, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.timestatistics_ = timestatistics;
  // @@protoc_insertion_point(field_set_allocated:pixels.proto.ColumnStatistic.timeStatistics)
}

// optional .pixels.proto.Integer128Statistic int128Statistics = 11;
inline bool ColumnStatistic::_internal_has_int128statistics() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.int128statistics_ != nullptr);
  return value;
}
inline bool ColumnStatistic::has_int128statistics() const {
  return _internal_has_int128statistics();
}
inline void ColumnStatistic::clear_int128statistics() {
  if (_impl_.int128statistics_ != nullptr) _impl_.int128statistics_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::pixels::proto::Integer128Statistic& ColumnStatistic::_internal_int128statistics() const {
  const ::pixels::proto::Integer128Statistic* p = _impl_.int128statistics_;
  return p != nullptr ? *p : reinterpret_cast<const ::pixels::proto::Integer128Statistic&>(
      ::pixels::proto::_Integer128Statistic_default_instance_);
}
inline const ::pixels::proto::Integer128Statistic& ColumnStatistic::int128statistics() const {
  // @@protoc_insertion_point(field_get:pixels.proto.ColumnStatistic.int128Statistics)
  return _internal_int128statistics();
}
inline void ColumnStatistic::unsafe_arena_set_allocated_int128statistics(
    ::pixels::proto::Integer128Statistic* int128statistics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.int128statistics_);
  }
  _impl_.int128statistics_ = int128statistics;
  if (int128statistics) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pixels.proto.ColumnStatistic.int128Statistics)
}
inline ::pixels::proto::Integer128Statistic* ColumnStatistic::release_int128statistics() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::pixels::proto::Integer128Statistic* temp = _impl_.int128statistics_;
  _impl_.int128statistics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pixels::proto::Integer128Statistic* ColumnStatistic::unsafe_arena_release_int128statistics() {
  // @@protoc_insertion_point(field_release:pixels.proto.ColumnStatistic.int128Statistics)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::pixels::proto::Integer128Statistic* temp = _impl_.int128statistics_;
  _impl_.int128statistics_ = nullptr;
  return temp;
}
inline ::pixels::proto::Integer128Statistic* ColumnStatistic::_internal_mutable_int128statistics() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.int128statistics_ == nullptr) {
    auto* p = CreateMaybeMessage<::pixels::proto::Integer128Statistic>(GetArenaForAllocation());
    _impl_.int128statistics_ = p;
  }
  return _impl_.int128statistics_;
}
inline ::pixels::proto::Integer128Statistic* ColumnStatistic::mutable_int128statistics() {
  ::pixels::proto::Integer128Statistic* _msg = _internal_mutable_int128statistics();
  // @@protoc_insertion_point(field_mutable:pixels.proto.ColumnStatistic.int128Statistics)
  return _msg;
}
inline void ColumnStatistic::set_allocated_int128statistics(::pixels::proto::Integer128Statistic* int128statistics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.int128statistics_;
  }
  if (int128statistics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(int128statistics);
    if (message_arena != submessage_arena) {
      int128statistics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, int128statistics, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.int128statistics_ = int128statistics;
  // @@protoc_insertion_point(field_set_allocated:pixels.proto.ColumnStatistic.int128Statistics)
}

// optional bool hasNull = 8;
inline bool ColumnStatistic::_internal_has_hasnull() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ColumnStatistic::has_hasnull() const {
  return _internal_has_hasnull();
}
inline void ColumnStatistic::clear_hasnull() {
  _impl_.hasnull_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool ColumnStatistic::_internal_hasnull() const {
  return _impl_.hasnull_;
}
inline bool ColumnStatistic::hasnull() const {
  // @@protoc_insertion_point(field_get:pixels.proto.ColumnStatistic.hasNull)
  return _internal_hasnull();
}
inline void ColumnStatistic::_internal_set_hasnull(bool value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.hasnull_ = value;
}
inline void ColumnStatistic::set_hasnull(bool value) {
  _internal_set_hasnull(value);
  // @@protoc_insertion_point(field_set:pixels.proto.ColumnStatistic.hasNull)
}

// -------------------------------------------------------------------

// PixelStatistic

// optional .pixels.proto.ColumnStatistic statistic = 1;
inline bool PixelStatistic::_internal_has_statistic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.statistic_ != nullptr);
  return value;
}
inline bool PixelStatistic::has_statistic() const {
  return _internal_has_statistic();
}
inline void PixelStatistic::clear_statistic() {
  if (_impl_.statistic_ != nullptr) _impl_.statistic_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::pixels::proto::ColumnStatistic& PixelStatistic::_internal_statistic() const {
  const ::pixels::proto::ColumnStatistic* p = _impl_.statistic_;
  return p != nullptr ? *p : reinterpret_cast<const ::pixels::proto::ColumnStatistic&>(
      ::pixels::proto::_ColumnStatistic_default_instance_);
}
inline const ::pixels::proto::ColumnStatistic& PixelStatistic::statistic() const {
  // @@protoc_insertion_point(field_get:pixels.proto.PixelStatistic.statistic)
  return _internal_statistic();
}
inline void PixelStatistic::unsafe_arena_set_allocated_statistic(
    ::pixels::proto::ColumnStatistic* statistic) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.statistic_);
  }
  _impl_.statistic_ = statistic;
  if (statistic) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pixels.proto.PixelStatistic.statistic)
}
inline ::pixels::proto::ColumnStatistic* PixelStatistic::release_statistic() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pixels::proto::ColumnStatistic* temp = _impl_.statistic_;
  _impl_.statistic_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pixels::proto::ColumnStatistic* PixelStatistic::unsafe_arena_release_statistic() {
  // @@protoc_insertion_point(field_release:pixels.proto.PixelStatistic.statistic)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pixels::proto::ColumnStatistic* temp = _impl_.statistic_;
  _impl_.statistic_ = nullptr;
  return temp;
}
inline ::pixels::proto::ColumnStatistic* PixelStatistic::_internal_mutable_statistic() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.statistic_ == nullptr) {
    auto* p = CreateMaybeMessage<::pixels::proto::ColumnStatistic>(GetArenaForAllocation());
    _impl_.statistic_ = p;
  }
  return _impl_.statistic_;
}
inline ::pixels::proto::ColumnStatistic* PixelStatistic::mutable_statistic() {
  ::pixels::proto::ColumnStatistic* _msg = _internal_mutable_statistic();
  // @@protoc_insertion_point(field_mutable:pixels.proto.PixelStatistic.statistic)
  return _msg;
}
inline void PixelStatistic::set_allocated_statistic(::pixels::proto::ColumnStatistic* statistic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.statistic_;
  }
  if (statistic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(statistic);
    if (message_arena != submessage_arena) {
      statistic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statistic, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.statistic_ = statistic;
  // @@protoc_insertion_point(field_set_allocated:pixels.proto.PixelStatistic.statistic)
}

// -------------------------------------------------------------------

// ColumnChunkIndex

// optional uint64 chunkOffset = 1;
inline bool ColumnChunkIndex::_internal_has_chunkoffset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ColumnChunkIndex::has_chunkoffset() const {
  return _internal_has_chunkoffset();
}
inline void ColumnChunkIndex::clear_chunkoffset() {
  _impl_.chunkoffset_ = uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint64_t ColumnChunkIndex::_internal_chunkoffset() const {
  return _impl_.chunkoffset_;
}
inline uint64_t ColumnChunkIndex::chunkoffset() const {
  // @@protoc_insertion_point(field_get:pixels.proto.ColumnChunkIndex.chunkOffset)
  return _internal_chunkoffset();
}
inline void ColumnChunkIndex::_internal_set_chunkoffset(uint64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.chunkoffset_ = value;
}
inline void ColumnChunkIndex::set_chunkoffset(uint64_t value) {
  _internal_set_chunkoffset(value);
  // @@protoc_insertion_point(field_set:pixels.proto.ColumnChunkIndex.chunkOffset)
}

// optional uint32 chunkLength = 2;
inline bool ColumnChunkIndex::_internal_has_chunklength() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ColumnChunkIndex::has_chunklength() const {
  return _internal_has_chunklength();
}
inline void ColumnChunkIndex::clear_chunklength() {
  _impl_.chunklength_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ColumnChunkIndex::_internal_chunklength() const {
  return _impl_.chunklength_;
}
inline uint32_t ColumnChunkIndex::chunklength() const {
  // @@protoc_insertion_point(field_get:pixels.proto.ColumnChunkIndex.chunkLength)
  return _internal_chunklength();
}
inline void ColumnChunkIndex::_internal_set_chunklength(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.chunklength_ = value;
}
inline void ColumnChunkIndex::set_chunklength(uint32_t value) {
  _internal_set_chunklength(value);
  // @@protoc_insertion_point(field_set:pixels.proto.ColumnChunkIndex.chunkLength)
}

// optional uint32 isNullOffset = 3;
inline bool ColumnChunkIndex::_internal_has_isnulloffset() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ColumnChunkIndex::has_isnulloffset() const {
  return _internal_has_isnulloffset();
}
inline void ColumnChunkIndex::clear_isnulloffset() {
  _impl_.isnulloffset_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ColumnChunkIndex::_internal_isnulloffset() const {
  return _impl_.isnulloffset_;
}
inline uint32_t ColumnChunkIndex::isnulloffset() const {
  // @@protoc_insertion_point(field_get:pixels.proto.ColumnChunkIndex.isNullOffset)
  return _internal_isnulloffset();
}
inline void ColumnChunkIndex::_internal_set_isnulloffset(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.isnulloffset_ = value;
}
inline void ColumnChunkIndex::set_isnulloffset(uint32_t value) {
  _internal_set_isnulloffset(value);
  // @@protoc_insertion_point(field_set:pixels.proto.ColumnChunkIndex.isNullOffset)
}

// repeated uint32 pixelPositions = 4 [packed = true];
inline int ColumnChunkIndex::_internal_pixelpositions_size() const {
  return _impl_.pixelpositions_.size();
}
inline int ColumnChunkIndex::pixelpositions_size() const {
  return _internal_pixelpositions_size();
}
inline void ColumnChunkIndex::clear_pixelpositions() {
  _impl_.pixelpositions_.Clear();
}
inline uint32_t ColumnChunkIndex::_internal_pixelpositions(int index) const {
  return _impl_.pixelpositions_.Get(index);
}
inline uint32_t ColumnChunkIndex::pixelpositions(int index) const {
  // @@protoc_insertion_point(field_get:pixels.proto.ColumnChunkIndex.pixelPositions)
  return _internal_pixelpositions(index);
}
inline void ColumnChunkIndex::set_pixelpositions(int index, uint32_t value) {
  _impl_.pixelpositions_.Set(index, value);
  // @@protoc_insertion_point(field_set:pixels.proto.ColumnChunkIndex.pixelPositions)
}
inline void ColumnChunkIndex::_internal_add_pixelpositions(uint32_t value) {
  _impl_.pixelpositions_.Add(value);
}
inline void ColumnChunkIndex::add_pixelpositions(uint32_t value) {
  _internal_add_pixelpositions(value);
  // @@protoc_insertion_point(field_add:pixels.proto.ColumnChunkIndex.pixelPositions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
ColumnChunkIndex::_internal_pixelpositions() const {
  return _impl_.pixelpositions_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
ColumnChunkIndex::pixelpositions() const {
  // @@protoc_insertion_point(field_list:pixels.proto.ColumnChunkIndex.pixelPositions)
  return _internal_pixelpositions();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
ColumnChunkIndex::_internal_mutable_pixelpositions() {
  return &_impl_.pixelpositions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
ColumnChunkIndex::mutable_pixelpositions() {
  // @@protoc_insertion_point(field_mutable_list:pixels.proto.ColumnChunkIndex.pixelPositions)
  return _internal_mutable_pixelpositions();
}

// repeated .pixels.proto.PixelStatistic pixelStatistics = 5;
inline int ColumnChunkIndex::_internal_pixelstatistics_size() const {
  return _impl_.pixelstatistics_.size();
}
inline int ColumnChunkIndex::pixelstatistics_size() const {
  return _internal_pixelstatistics_size();
}
inline void ColumnChunkIndex::clear_pixelstatistics() {
  _impl_.pixelstatistics_.Clear();
}
inline ::pixels::proto::PixelStatistic* ColumnChunkIndex::mutable_pixelstatistics(int index) {
  // @@protoc_insertion_point(field_mutable:pixels.proto.ColumnChunkIndex.pixelStatistics)
  return _impl_.pixelstatistics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::PixelStatistic >*
ColumnChunkIndex::mutable_pixelstatistics() {
  // @@protoc_insertion_point(field_mutable_list:pixels.proto.ColumnChunkIndex.pixelStatistics)
  return &_impl_.pixelstatistics_;
}
inline const ::pixels::proto::PixelStatistic& ColumnChunkIndex::_internal_pixelstatistics(int index) const {
  return _impl_.pixelstatistics_.Get(index);
}
inline const ::pixels::proto::PixelStatistic& ColumnChunkIndex::pixelstatistics(int index) const {
  // @@protoc_insertion_point(field_get:pixels.proto.ColumnChunkIndex.pixelStatistics)
  return _internal_pixelstatistics(index);
}
inline ::pixels::proto::PixelStatistic* ColumnChunkIndex::_internal_add_pixelstatistics() {
  return _impl_.pixelstatistics_.Add();
}
inline ::pixels::proto::PixelStatistic* ColumnChunkIndex::add_pixelstatistics() {
  ::pixels::proto::PixelStatistic* _add = _internal_add_pixelstatistics();
  // @@protoc_insertion_point(field_add:pixels.proto.ColumnChunkIndex.pixelStatistics)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::PixelStatistic >&
ColumnChunkIndex::pixelstatistics() const {
  // @@protoc_insertion_point(field_list:pixels.proto.ColumnChunkIndex.pixelStatistics)
  return _impl_.pixelstatistics_;
}

// optional bool littleEndian = 6;
inline bool ColumnChunkIndex::_internal_has_littleendian() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ColumnChunkIndex::has_littleendian() const {
  return _internal_has_littleendian();
}
inline void ColumnChunkIndex::clear_littleendian() {
  _impl_.littleendian_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool ColumnChunkIndex::_internal_littleendian() const {
  return _impl_.littleendian_;
}
inline bool ColumnChunkIndex::littleendian() const {
  // @@protoc_insertion_point(field_get:pixels.proto.ColumnChunkIndex.littleEndian)
  return _internal_littleendian();
}
inline void ColumnChunkIndex::_internal_set_littleendian(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.littleendian_ = value;
}
inline void ColumnChunkIndex::set_littleendian(bool value) {
  _internal_set_littleendian(value);
  // @@protoc_insertion_point(field_set:pixels.proto.ColumnChunkIndex.littleEndian)
}

// optional bool nullsPadding = 7;
inline bool ColumnChunkIndex::_internal_has_nullspadding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ColumnChunkIndex::has_nullspadding() const {
  return _internal_has_nullspadding();
}
inline void ColumnChunkIndex::clear_nullspadding() {
  _impl_.nullspadding_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool ColumnChunkIndex::_internal_nullspadding() const {
  return _impl_.nullspadding_;
}
inline bool ColumnChunkIndex::nullspadding() const {
  // @@protoc_insertion_point(field_get:pixels.proto.ColumnChunkIndex.nullsPadding)
  return _internal_nullspadding();
}
inline void ColumnChunkIndex::_internal_set_nullspadding(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.nullspadding_ = value;
}
inline void ColumnChunkIndex::set_nullspadding(bool value) {
  _internal_set_nullspadding(value);
  // @@protoc_insertion_point(field_set:pixels.proto.ColumnChunkIndex.nullsPadding)
}

// optional uint32 isNullAlignment = 8;
inline bool ColumnChunkIndex::_internal_has_isnullalignment() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ColumnChunkIndex::has_isnullalignment() const {
  return _internal_has_isnullalignment();
}
inline void ColumnChunkIndex::clear_isnullalignment() {
  _impl_.isnullalignment_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline uint32_t ColumnChunkIndex::_internal_isnullalignment() const {
  return _impl_.isnullalignment_;
}
inline uint32_t ColumnChunkIndex::isnullalignment() const {
  // @@protoc_insertion_point(field_get:pixels.proto.ColumnChunkIndex.isNullAlignment)
  return _internal_isnullalignment();
}
inline void ColumnChunkIndex::_internal_set_isnullalignment(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.isnullalignment_ = value;
}
inline void ColumnChunkIndex::set_isnullalignment(uint32_t value) {
  _internal_set_isnullalignment(value);
  // @@protoc_insertion_point(field_set:pixels.proto.ColumnChunkIndex.isNullAlignment)
}

// -------------------------------------------------------------------

// RowGroupIndex

// repeated .pixels.proto.ColumnChunkIndex columnChunkIndexEntries = 1;
inline int RowGroupIndex::_internal_columnchunkindexentries_size() const {
  return _impl_.columnchunkindexentries_.size();
}
inline int RowGroupIndex::columnchunkindexentries_size() const {
  return _internal_columnchunkindexentries_size();
}
inline void RowGroupIndex::clear_columnchunkindexentries() {
  _impl_.columnchunkindexentries_.Clear();
}
inline ::pixels::proto::ColumnChunkIndex* RowGroupIndex::mutable_columnchunkindexentries(int index) {
  // @@protoc_insertion_point(field_mutable:pixels.proto.RowGroupIndex.columnChunkIndexEntries)
  return _impl_.columnchunkindexentries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::ColumnChunkIndex >*
RowGroupIndex::mutable_columnchunkindexentries() {
  // @@protoc_insertion_point(field_mutable_list:pixels.proto.RowGroupIndex.columnChunkIndexEntries)
  return &_impl_.columnchunkindexentries_;
}
inline const ::pixels::proto::ColumnChunkIndex& RowGroupIndex::_internal_columnchunkindexentries(int index) const {
  return _impl_.columnchunkindexentries_.Get(index);
}
inline const ::pixels::proto::ColumnChunkIndex& RowGroupIndex::columnchunkindexentries(int index) const {
  // @@protoc_insertion_point(field_get:pixels.proto.RowGroupIndex.columnChunkIndexEntries)
  return _internal_columnchunkindexentries(index);
}
inline ::pixels::proto::ColumnChunkIndex* RowGroupIndex::_internal_add_columnchunkindexentries() {
  return _impl_.columnchunkindexentries_.Add();
}
inline ::pixels::proto::ColumnChunkIndex* RowGroupIndex::add_columnchunkindexentries() {
  ::pixels::proto::ColumnChunkIndex* _add = _internal_add_columnchunkindexentries();
  // @@protoc_insertion_point(field_add:pixels.proto.RowGroupIndex.columnChunkIndexEntries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::ColumnChunkIndex >&
RowGroupIndex::columnchunkindexentries() const {
  // @@protoc_insertion_point(field_list:pixels.proto.RowGroupIndex.columnChunkIndexEntries)
  return _impl_.columnchunkindexentries_;
}

// -------------------------------------------------------------------

// RowGroupEncoding

// repeated .pixels.proto.ColumnEncoding columnChunkEncodings = 1;
inline int RowGroupEncoding::_internal_columnchunkencodings_size() const {
  return _impl_.columnchunkencodings_.size();
}
inline int RowGroupEncoding::columnchunkencodings_size() const {
  return _internal_columnchunkencodings_size();
}
inline void RowGroupEncoding::clear_columnchunkencodings() {
  _impl_.columnchunkencodings_.Clear();
}
inline ::pixels::proto::ColumnEncoding* RowGroupEncoding::mutable_columnchunkencodings(int index) {
  // @@protoc_insertion_point(field_mutable:pixels.proto.RowGroupEncoding.columnChunkEncodings)
  return _impl_.columnchunkencodings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::ColumnEncoding >*
RowGroupEncoding::mutable_columnchunkencodings() {
  // @@protoc_insertion_point(field_mutable_list:pixels.proto.RowGroupEncoding.columnChunkEncodings)
  return &_impl_.columnchunkencodings_;
}
inline const ::pixels::proto::ColumnEncoding& RowGroupEncoding::_internal_columnchunkencodings(int index) const {
  return _impl_.columnchunkencodings_.Get(index);
}
inline const ::pixels::proto::ColumnEncoding& RowGroupEncoding::columnchunkencodings(int index) const {
  // @@protoc_insertion_point(field_get:pixels.proto.RowGroupEncoding.columnChunkEncodings)
  return _internal_columnchunkencodings(index);
}
inline ::pixels::proto::ColumnEncoding* RowGroupEncoding::_internal_add_columnchunkencodings() {
  return _impl_.columnchunkencodings_.Add();
}
inline ::pixels::proto::ColumnEncoding* RowGroupEncoding::add_columnchunkencodings() {
  ::pixels::proto::ColumnEncoding* _add = _internal_add_columnchunkencodings();
  // @@protoc_insertion_point(field_add:pixels.proto.RowGroupEncoding.columnChunkEncodings)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pixels::proto::ColumnEncoding >&
RowGroupEncoding::columnchunkencodings() const {
  // @@protoc_insertion_point(field_list:pixels.proto.RowGroupEncoding.columnChunkEncodings)
  return _impl_.columnchunkencodings_;
}

// -------------------------------------------------------------------

// RowGroupFooter

// optional .pixels.proto.RowGroupIndex rowGroupIndexEntry = 1;
inline bool RowGroupFooter::_internal_has_rowgroupindexentry() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rowgroupindexentry_ != nullptr);
  return value;
}
inline bool RowGroupFooter::has_rowgroupindexentry() const {
  return _internal_has_rowgroupindexentry();
}
inline void RowGroupFooter::clear_rowgroupindexentry() {
  if (_impl_.rowgroupindexentry_ != nullptr) _impl_.rowgroupindexentry_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::pixels::proto::RowGroupIndex& RowGroupFooter::_internal_rowgroupindexentry() const {
  const ::pixels::proto::RowGroupIndex* p = _impl_.rowgroupindexentry_;
  return p != nullptr ? *p : reinterpret_cast<const ::pixels::proto::RowGroupIndex&>(
      ::pixels::proto::_RowGroupIndex_default_instance_);
}
inline const ::pixels::proto::RowGroupIndex& RowGroupFooter::rowgroupindexentry() const {
  // @@protoc_insertion_point(field_get:pixels.proto.RowGroupFooter.rowGroupIndexEntry)
  return _internal_rowgroupindexentry();
}
inline void RowGroupFooter::unsafe_arena_set_allocated_rowgroupindexentry(
    ::pixels::proto::RowGroupIndex* rowgroupindexentry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rowgroupindexentry_);
  }
  _impl_.rowgroupindexentry_ = rowgroupindexentry;
  if (rowgroupindexentry) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pixels.proto.RowGroupFooter.rowGroupIndexEntry)
}
inline ::pixels::proto::RowGroupIndex* RowGroupFooter::release_rowgroupindexentry() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pixels::proto::RowGroupIndex* temp = _impl_.rowgroupindexentry_;
  _impl_.rowgroupindexentry_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pixels::proto::RowGroupIndex* RowGroupFooter::unsafe_arena_release_rowgroupindexentry() {
  // @@protoc_insertion_point(field_release:pixels.proto.RowGroupFooter.rowGroupIndexEntry)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pixels::proto::RowGroupIndex* temp = _impl_.rowgroupindexentry_;
  _impl_.rowgroupindexentry_ = nullptr;
  return temp;
}
inline ::pixels::proto::RowGroupIndex* RowGroupFooter::_internal_mutable_rowgroupindexentry() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.rowgroupindexentry_ == nullptr) {
    auto* p = CreateMaybeMessage<::pixels::proto::RowGroupIndex>(GetArenaForAllocation());
    _impl_.rowgroupindexentry_ = p;
  }
  return _impl_.rowgroupindexentry_;
}
inline ::pixels::proto::RowGroupIndex* RowGroupFooter::mutable_rowgroupindexentry() {
  ::pixels::proto::RowGroupIndex* _msg = _internal_mutable_rowgroupindexentry();
  // @@protoc_insertion_point(field_mutable:pixels.proto.RowGroupFooter.rowGroupIndexEntry)
  return _msg;
}
inline void RowGroupFooter::set_allocated_rowgroupindexentry(::pixels::proto::RowGroupIndex* rowgroupindexentry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rowgroupindexentry_;
  }
  if (rowgroupindexentry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rowgroupindexentry);
    if (message_arena != submessage_arena) {
      rowgroupindexentry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rowgroupindexentry, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.rowgroupindexentry_ = rowgroupindexentry;
  // @@protoc_insertion_point(field_set_allocated:pixels.proto.RowGroupFooter.rowGroupIndexEntry)
}

// optional .pixels.proto.RowGroupEncoding rowGroupEncoding = 2;
inline bool RowGroupFooter::_internal_has_rowgroupencoding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rowgroupencoding_ != nullptr);
  return value;
}
inline bool RowGroupFooter::has_rowgroupencoding() const {
  return _internal_has_rowgroupencoding();
}
inline void RowGroupFooter::clear_rowgroupencoding() {
  if (_impl_.rowgroupencoding_ != nullptr) _impl_.rowgroupencoding_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::pixels::proto::RowGroupEncoding& RowGroupFooter::_internal_rowgroupencoding() const {
  const ::pixels::proto::RowGroupEncoding* p = _impl_.rowgroupencoding_;
  return p != nullptr ? *p : reinterpret_cast<const ::pixels::proto::RowGroupEncoding&>(
      ::pixels::proto::_RowGroupEncoding_default_instance_);
}
inline const ::pixels::proto::RowGroupEncoding& RowGroupFooter::rowgroupencoding() const {
  // @@protoc_insertion_point(field_get:pixels.proto.RowGroupFooter.rowGroupEncoding)
  return _internal_rowgroupencoding();
}
inline void RowGroupFooter::unsafe_arena_set_allocated_rowgroupencoding(
    ::pixels::proto::RowGroupEncoding* rowgroupencoding) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rowgroupencoding_);
  }
  _impl_.rowgroupencoding_ = rowgroupencoding;
  if (rowgroupencoding) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pixels.proto.RowGroupFooter.rowGroupEncoding)
}
inline ::pixels::proto::RowGroupEncoding* RowGroupFooter::release_rowgroupencoding() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::pixels::proto::RowGroupEncoding* temp = _impl_.rowgroupencoding_;
  _impl_.rowgroupencoding_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pixels::proto::RowGroupEncoding* RowGroupFooter::unsafe_arena_release_rowgroupencoding() {
  // @@protoc_insertion_point(field_release:pixels.proto.RowGroupFooter.rowGroupEncoding)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::pixels::proto::RowGroupEncoding* temp = _impl_.rowgroupencoding_;
  _impl_.rowgroupencoding_ = nullptr;
  return temp;
}
inline ::pixels::proto::RowGroupEncoding* RowGroupFooter::_internal_mutable_rowgroupencoding() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.rowgroupencoding_ == nullptr) {
    auto* p = CreateMaybeMessage<::pixels::proto::RowGroupEncoding>(GetArenaForAllocation());
    _impl_.rowgroupencoding_ = p;
  }
  return _impl_.rowgroupencoding_;
}
inline ::pixels::proto::RowGroupEncoding* RowGroupFooter::mutable_rowgroupencoding() {
  ::pixels::proto::RowGroupEncoding* _msg = _internal_mutable_rowgroupencoding();
  // @@protoc_insertion_point(field_mutable:pixels.proto.RowGroupFooter.rowGroupEncoding)
  return _msg;
}
inline void RowGroupFooter::set_allocated_rowgroupencoding(::pixels::proto::RowGroupEncoding* rowgroupencoding) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rowgroupencoding_;
  }
  if (rowgroupencoding) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rowgroupencoding);
    if (message_arena != submessage_arena) {
      rowgroupencoding = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rowgroupencoding, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.rowgroupencoding_ = rowgroupencoding;
  // @@protoc_insertion_point(field_set_allocated:pixels.proto.RowGroupFooter.rowGroupEncoding)
}

// -------------------------------------------------------------------

// ColumnEncoding

// required .pixels.proto.ColumnEncoding.Kind kind = 1;
inline bool ColumnEncoding::_internal_has_kind() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ColumnEncoding::has_kind() const {
  return _internal_has_kind();
}
inline void ColumnEncoding::clear_kind() {
  _impl_.kind_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::pixels::proto::ColumnEncoding_Kind ColumnEncoding::_internal_kind() const {
  return static_cast< ::pixels::proto::ColumnEncoding_Kind >(_impl_.kind_);
}
inline ::pixels::proto::ColumnEncoding_Kind ColumnEncoding::kind() const {
  // @@protoc_insertion_point(field_get:pixels.proto.ColumnEncoding.kind)
  return _internal_kind();
}
inline void ColumnEncoding::_internal_set_kind(::pixels::proto::ColumnEncoding_Kind value) {
  assert(::pixels::proto::ColumnEncoding_Kind_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.kind_ = value;
}
inline void ColumnEncoding::set_kind(::pixels::proto::ColumnEncoding_Kind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:pixels.proto.ColumnEncoding.kind)
}

// optional uint32 dictionarySize = 2;
inline bool ColumnEncoding::_internal_has_dictionarysize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ColumnEncoding::has_dictionarysize() const {
  return _internal_has_dictionarysize();
}
inline void ColumnEncoding::clear_dictionarysize() {
  _impl_.dictionarysize_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t ColumnEncoding::_internal_dictionarysize() const {
  return _impl_.dictionarysize_;
}
inline uint32_t ColumnEncoding::dictionarysize() const {
  // @@protoc_insertion_point(field_get:pixels.proto.ColumnEncoding.dictionarySize)
  return _internal_dictionarysize();
}
inline void ColumnEncoding::_internal_set_dictionarysize(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.dictionarysize_ = value;
}
inline void ColumnEncoding::set_dictionarysize(uint32_t value) {
  _internal_set_dictionarysize(value);
  // @@protoc_insertion_point(field_set:pixels.proto.ColumnEncoding.dictionarySize)
}

// optional .pixels.proto.ColumnEncoding cascadeEncoding = 3;
inline bool ColumnEncoding::_internal_has_cascadeencoding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.cascadeencoding_ != nullptr);
  return value;
}
inline bool ColumnEncoding::has_cascadeencoding() const {
  return _internal_has_cascadeencoding();
}
inline void ColumnEncoding::clear_cascadeencoding() {
  if (_impl_.cascadeencoding_ != nullptr) _impl_.cascadeencoding_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::pixels::proto::ColumnEncoding& ColumnEncoding::_internal_cascadeencoding() const {
  const ::pixels::proto::ColumnEncoding* p = _impl_.cascadeencoding_;
  return p != nullptr ? *p : reinterpret_cast<const ::pixels::proto::ColumnEncoding&>(
      ::pixels::proto::_ColumnEncoding_default_instance_);
}
inline const ::pixels::proto::ColumnEncoding& ColumnEncoding::cascadeencoding() const {
  // @@protoc_insertion_point(field_get:pixels.proto.ColumnEncoding.cascadeEncoding)
  return _internal_cascadeencoding();
}
inline void ColumnEncoding::unsafe_arena_set_allocated_cascadeencoding(
    ::pixels::proto::ColumnEncoding* cascadeencoding) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cascadeencoding_);
  }
  _impl_.cascadeencoding_ = cascadeencoding;
  if (cascadeencoding) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pixels.proto.ColumnEncoding.cascadeEncoding)
}
inline ::pixels::proto::ColumnEncoding* ColumnEncoding::release_cascadeencoding() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pixels::proto::ColumnEncoding* temp = _impl_.cascadeencoding_;
  _impl_.cascadeencoding_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pixels::proto::ColumnEncoding* ColumnEncoding::unsafe_arena_release_cascadeencoding() {
  // @@protoc_insertion_point(field_release:pixels.proto.ColumnEncoding.cascadeEncoding)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pixels::proto::ColumnEncoding* temp = _impl_.cascadeencoding_;
  _impl_.cascadeencoding_ = nullptr;
  return temp;
}
inline ::pixels::proto::ColumnEncoding* ColumnEncoding::_internal_mutable_cascadeencoding() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.cascadeencoding_ == nullptr) {
    auto* p = CreateMaybeMessage<::pixels::proto::ColumnEncoding>(GetArenaForAllocation());
    _impl_.cascadeencoding_ = p;
  }
  return _impl_.cascadeencoding_;
}
inline ::pixels::proto::ColumnEncoding* ColumnEncoding::mutable_cascadeencoding() {
  ::pixels::proto::ColumnEncoding* _msg = _internal_mutable_cascadeencoding();
  // @@protoc_insertion_point(field_mutable:pixels.proto.ColumnEncoding.cascadeEncoding)
  return _msg;
}
inline void ColumnEncoding::set_allocated_cascadeencoding(::pixels::proto::ColumnEncoding* cascadeencoding) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cascadeencoding_;
  }
  if (cascadeencoding) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cascadeencoding);
    if (message_arena != submessage_arena) {
      cascadeencoding = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cascadeencoding, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cascadeencoding_ = cascadeencoding;
  // @@protoc_insertion_point(field_set_allocated:pixels.proto.ColumnEncoding.cascadeEncoding)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace pixels

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::pixels::proto::Type_Kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pixels::proto::Type_Kind>() {
  return ::pixels::proto::Type_Kind_descriptor();
}
template <> struct is_proto_enum< ::pixels::proto::ColumnEncoding_Kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pixels::proto::ColumnEncoding_Kind>() {
  return ::pixels::proto::ColumnEncoding_Kind_descriptor();
}
template <> struct is_proto_enum< ::pixels::proto::CompressionKind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pixels::proto::CompressionKind>() {
  return ::pixels::proto::CompressionKind_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_pixels_2eproto
